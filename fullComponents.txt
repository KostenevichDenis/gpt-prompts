The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
umbfileicon.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbFileIcon
@restrict E
@scope

@description
Use this directive to render a file icon.

<h3>Markup example</h3>
<pre>
    <div>

        <umb-file-icon
            extension="pdf"
            size="s">
        </umb-file-icon>

	</div>
</pre>

@param {string} size (<code>attribute</code>): This parameter defines the size of the file icon (s, m).
**/

(function () {
    'use strict';

    function umbFileIconController() {

        var vm = this;

        if (!vm.icon) {
            vm.icon = 'icon-document';
        }
    }

    var component = {
        templateUrl: 'views/components/umb-file-icon.html',
        bindings: {
            extension: "@?",
            icon: "@?",
            size: "@?",
            text: "@?"
        },
        controllerAs: 'vm',
        controller: umbFileIconController
    };

    angular.module('umbraco.directives').component('umbFileIcon', component);

})();

----
umbkeyboardshortcutsoverview.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbkeyboardShortcutsOverview
@restrict E
@scope

@description

<p>Use this directive to show an overview of keyboard shortcuts in an editor.
The directive will render an overview trigger wich shows how the overview is opened.
When this combination is hit an overview is opened with shortcuts based on the model sent to the directive.</p>

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-keyboard-shortcuts-overview
            model="vm.keyboardShortcutsOverview">
        </umb-keyboard-shortcuts-overview>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {

        "use strict";

        function Controller() {

            var vm = this;

            vm.keyboardShortcutsOverview = [
                {
                    "name": "Sections",
                    "shortcuts": [
                        {
                            "description": "Navigate sections",
                            "keys": [
                                {"key": "1"},
                                {"key": "4"}
                            ],
                            "keyRange": true
                        }
                    ]
                },
                {
                    "name": "Design",
                    "shortcuts": [
                        {
                            "description": "Add group",
                            "keys": [
                                {"key": "alt"},
                                {"key": "shift"},
                                {"key": "g"}
                            ]
                        }
                    ]
                }
            ];

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

<h3>Model description</h3>
<ul>
    <li>
        <strong>name</strong>
        <small>(string)</small> -
        Sets the shortcut section name.
    </li>
    <li>
        <strong>shortcuts</strong>
        <small>(array)</small> -
        Array of available shortcuts in the section.
    </li>
    <ul>
        <li>
            <strong>description</strong>
            <small>(string)</small> -
            Short description of the shortcut.
        </li>
        <li>
            <strong>keys</strong>
            <small>(array)</small> -
            Array of keys in the shortcut.
        </li>
        <ul>
            <li>
                <strong>key</strong>
                <small>(string)</small> -
                The invidual key in the shortcut.
            </li>
        </ul>
        <li>
            <strong>keyRange</strong>
            <small>(boolean)</small> -
            Set to <code>true</code> to show a key range. It combines the shortcut keys with "-" instead of "+".
        </li>
    </ul>
</ul>

@param {object} model keyboard shortcut model. See description and example above.
**/

(function () {
    'use strict';

    function KeyboardShortcutsOverviewDirective(platformService, overlayService) {

        function link(scope, el, attr, ctrl) {

            var eventBindings = [];
            var isMac = platformService.isMac();
            var overlay = null;

            scope.toggleShortcutsOverlay = function () {

                if (overlay) {
                    scope.close();
                } else {
                    scope.open();
                }

                if (scope.onToggle) {
                    scope.onToggle();
                }

            };

            scope.open = function () {
                if (!overlay) {
                    overlay = {
                        title: "Keyboard shortcuts",
                        view: "keyboardshortcuts",
                        hideSubmitButton: true,
                        shortcuts: scope.model,
                        close: function () {
                            scope.close();
                        }
                    };
                    overlayService.open(overlay);
                }
            };

            scope.close = function () {
                if (overlay) {
                    overlayService.close();
                    overlay = null;
                    if (scope.onClose) {
                        scope.onClose();
                    }
                }
            };

            function onInit() {
                Utilities.forEach(scope.model, shortcutGroup => {

                    Utilities.forEach(shortcutGroup.shortcuts, shortcut => {
                        shortcut.platformKeys = [];

                        // get shortcut keys for mac
                        if (isMac && shortcut.keys && shortcut.keys.mac) {
                            shortcut.platformKeys = shortcut.keys.mac;
                            // get shortcut keys for windows
                        } else if (!isMac && shortcut.keys && shortcut.keys.win) {
                            shortcut.platformKeys = shortcut.keys.win;
                            // get default shortcut keys
                        } else if (shortcut.keys && shortcut && shortcut.keys.length > 0) {
                            shortcut.platformKeys = shortcut.keys;
                        }
                    })
                });
            }

            onInit();

            eventBindings.push(scope.$watch('model', function (newValue, oldValue) {
                if (newValue !== oldValue) {
                    onInit();
                }
            }));

            eventBindings.push(scope.$watch('showOverlay', function (newValue, oldValue) {

                if (newValue === oldValue) {
                    return;
                }

                if (newValue === true) {
                    scope.open();
                }

                if (newValue === false) {
                    scope.close();
                }

            }));

            // clean up
            scope.$on('$destroy', function () {
                // unbind watchers
                for (var e in eventBindings) {
                    eventBindings[e]();
                }
            });

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-keyboard-shortcuts-overview.html',
            link: link,
            scope: {
                model: "=",
                onToggle: "&",
                showOverlay: "=?",
                onClose: "&"
            }
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbKeyboardShortcutsOverview', KeyboardShortcutsOverviewDirective);

})();

----
umbprogressbar.directive.js

/**
@ngdoc directive
@name umbraco.directives.directive:umbProgressBar
@restrict E
@scope

@description
Use this directive to generate a progress bar.

<h3>Markup example</h3>
<pre>
    <umb-progress-bar
        percentage="60">
    </umb-progress-bar>
</pre>

@param {number} percentage (<code>attribute</code>): The progress in percentage.
@param {string} size (<code>attribute</code>): The size (s, m).
@param {string} color (<code>attribute</code>): The color of the progress (primary, secondary, success, warning, danger). Success by default.

**/

(function() {
    'use strict';

    function ProgressBarDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-progress-bar.html',
            scope: {
                percentage: "@",
                size: "@?",
                color: "@?"
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbProgressBar', ProgressBarDirective);

})();

----
umbdropdown.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbDropdown
@restrict E
@scope

@description
<b>Added in versions 7.7.0</b>: Use this component to render a dropdown menu.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MyDropdown.Controller as vm">

        <div style="position: relative;">

            <umb-button
                type="button"
                label="Toggle dropdown"
                action="vm.toggle()">
            </umb-button>

            <umb-dropdown ng-if="vm.dropdownOpen" on-close="vm.close()" umb-keyboard-list>
                <umb-dropdown-item
                    ng-repeat="item in vm.items">
                    <button type="button" class="btn-reset" ng-click="vm.select(item)">{{ item.name }}</button>
                </umb-dropdown-item>
            </umb-dropdown>

        </div>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;

            vm.dropdownOpen = false;
            vm.items = [
                { "name": "Item 1" },
                { "name": "Item 2" },
                { "name": "Item 3" }
            ];

            vm.toggle = toggle;
            vm.close = close;
            vm.select = select;

            function toggle() {
                vm.dropdownOpen = true;
            }

            function close() {
                vm.dropdownOpen = false;
            }

            function select(item) {
                // Do your magic here
            }

        }

        angular.module("umbraco").controller("MyDropdown.Controller", Controller);
    })();
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbDropdownItem umbDropdownItem}</li>
    <li>{@link umbraco.directives.directive:umbKeyboardList umbKeyboardList}</li>
</ul>

@param {callback} onClose Callback when the dropdown menu closes. When you click outside or press esc.

**/

(function() {
    'use strict';

    function umbDropdown($document) {

        function link(scope, element, attr, ctrl) {

            scope.close = function() {
                if (scope.onClose) {
                    scope.onClose();
                }
            };

            // Handle keydown events
            function keydown(event) {
                // press escape
                if(event.keyCode === 27) {
                    scope.onClose();
                }
            }

            // Stop to listen typing.
            function stopListening() {
                $document.off('keydown', keydown);
            }

            // Start listening to key typing.
            $document.on('keydown', keydown);

            // Stop listening when scope is destroyed.
            scope.$on('$destroy', stopListening);

        }

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/umb-dropdown.html',
            scope: {
                onClose: "&"
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbDropdown', umbDropdown);

})();

----
umbtable.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTable
@restrict E
@scope

@description
<strong>Added in Umbraco v. 7.4:</strong> Use this directive to render a data table.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.TableController as vm">
        
        <umb-table
            ng-if="vm.items"
            items="vm.items"
            item-properties="vm.options.includeProperties"
            allow-select-all="vm.allowSelectAll"
            on-select="vm.selectItem"
            on-click="vm.clickItem"
            on-select-all="vm.selectAll"
            on-selected-all="vm.isSelectedAll"
            on-sorting-direction="vm.isSortDirection"
            on-sort="vm.sort">
        </umb-table>
    
    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";
    
        function Controller() {
    
            var vm = this;
    
            vm.items = [
                {
                    "icon": "icon-document",
                    "name": "My node 1",
                    "published": true,
                    "description": "A short description of my node",
                    "author": "Author 1"
                },
                {
                    "icon": "icon-document",
                    "name": "My node 2",
                    "published": true,
                    "description": "A short description of my node",
                    "author": "Author 2"
                }
            ];

            vm.options = {
                includeProperties: [
                    { alias: "description", header: "Description" },
                    { alias: "author", header: "Author" }
                ]
            };
    
            vm.selectItem = selectItem;
            vm.clickItem = clickItem;
            vm.selectAll = selectAll;
            vm.isSelectedAll = isSelectedAll;
            vm.isSortDirection = isSortDirection;
            vm.sort = sort;

            function selectAll($event) {
                alert("select all");
            }

            function isSelectedAll() {
                
            }
    
            function clickItem(item) {
                alert("click node");
            }

            function selectItem(selectedItem, $index, $event) {
                alert("select node");
            }
            
            function isSortDirection(col, direction) {
                
            }
            
            function sort(field, allow, isSystem) {
                
            }
    
        }
    
        angular.module("umbraco").controller("My.TableController", Controller);
    
    })();
</pre>

@param {array} items (<code>binding</code>): The items for the table.
@param {array} itemProperties (<code>binding</code>): The properties for the items to use in table.
@param {boolean} allowSelectAll (<code>binding</code>): Specify whether to allow select all.
@param {function} onSelect (<code>expression</code>): Callback function when the row is selected.
@param {function} onClick (<code>expression</code>): Callback function when the "Name" column link is clicked.
@param {function} onSelectAll (<code>expression</code>): Callback function when selecting all items.
@param {function} onSelectedAll (<code>expression</code>): Callback function when all items are selected.
@param {function} onSortingDirection (<code>expression</code>): Callback function when sorting direction is changed.
@param {function} onSort (<code>expression</code>): Callback function when sorting items.
**/

(function () {
    'use strict';

    function TableController(iconHelper) {

        var vm = this;

        vm.clickItem = function (item, $event) {
            if (vm.onClick && !($event.metaKey || $event.ctrlKey)) {
                vm.onClick({ item: item});
                $event.preventDefault();
            }
            $event.stopPropagation();
        };

        vm.selectItem = function (item, $index, $event) {
            if (vm.allowSelect !== false && vm.onSelect) {
                vm.onSelect({ item: item, $index: $index, $event: $event });
                $event.stopPropagation();
            }
        };

        vm.selectAll = function ($event) {
            if (vm.onSelectAll) {
                vm.onSelectAll({ $event: $event});
            }
        };

        vm.isSelectedAll = function () {
            if (vm.onSelectedAll && vm.items && vm.items.length > 0) {
                return vm.onSelectedAll();
            }
        };

        vm.isSortDirection = function (col, direction) {
            if (vm.onSortingDirection) {
                return vm.onSortingDirection({ col: col, direction: direction });
            }
        };

        vm.sort = function (field, allow, isSystem) {
            if (vm.onSort) {
                vm.onSort({ field: field, allow: allow, isSystem: isSystem  });
            }
        };

        vm.getIcon = function (entry) {
            return iconHelper.convertFromLegacyIcon(entry.icon);
        };
    }

    angular
        .module('umbraco.directives')
        .component('umbTable', {
            templateUrl: 'views/components/umb-table.html',
            controller: TableController,
            controllerAs: 'vm',
            bindings: {
                items: '<',
                itemProperties: '<',
                allowSelect: '<',
                allowSelectAll: '<',
                onSelect: '&',
                onClick: '&',
                onSelectAll: '&',
                onSelectedAll: '&',
                onSortingDirection: '&',
                onSort: '&'
            }
        });

})();

----
umbimagelazyload.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbImageLazyLoad
@restrict E
@scope

@description
Use this directive to lazy-load an image only when it is scrolled into view.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">
        <img umb-image-lazy-load="{{vm.imageUrl}}" />
    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;
            vm.imageUrl = "/media/TODO";
        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

**/

(function () {
    'use strict';

    function ImageLazyLoadDirective() {

      const placeholder = "assets/img/transparent.png";

      function link(scope, element, attrs) {

            const observer = new IntersectionObserver(loadImg);
            const img = element[0];
            img.src = placeholder;
            img.classList.add("lazy");
            observer.observe(img);

            function loadImg(entries) {
                entries.forEach(entry => {
                  if (entry.intersectionRatio > 0 && entry.target.src.indexOf(placeholder) > 0) {
                      let lazyImage = entry.target;
                      lazyImage.src = attrs.umbImageLazyLoad;
                      lazyImage.classList.add("loaded");
                      observer.unobserve(lazyImage);
                    }
                });
            }

            // make sure to disconnect the observer when the scope is destroyed
            scope.$on('$destroy', function () {
                observer.disconnect();
            });
        }

        var directive = {
            restrict: "A",
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbImageLazyLoad', ImageLazyLoadDirective);

})();

----
umbchildselector.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbChildSelector
@restrict E
@scope

@description
Use this directive to render a ui component for selecting child items to a parent node.

<h3>Markup example</h3>
<pre>
	<div ng-controller="My.Controller as vm">

        <umb-child-selector
                selected-children="vm.selectedChildren"
                available-children="vm.availableChildren"
                parent-name="vm.name"
                parent-icon="vm.icon"
                parent-id="vm.id"
                on-add="vm.addChild"
                on-remove="vm.removeChild">
        </umb-child-selector>

	</div>
</pre>

<h3>Controller example</h3>
<pre>
	(function () {
		"use strict";

		function Controller(overlayService) {

            var vm = this;

            vm.id = 1;
            vm.name = "My Parent element";
            vm.icon = "icon-document";
            vm.selectedChildren = [];
            vm.availableChildren = [
                {
                    id: 1,
                    alias: "item1",
                    name: "Item 1",
                    icon: "icon-document"
                },
                {
                    id: 2,
                    alias: "item2",
                    name: "Item 2",
                    icon: "icon-document"
                }
            ];

            vm.addChild = addChild;
            vm.removeChild = removeChild;

            function addChild($event) {
                
                const dialog = {
                    view: "itempicker",
                    title: "Choose child",
                    availableItems: vm.availableChildren,
                    selectedItems: vm.selectedChildren,
                    event: $event,
                    submit: function(model) {
                        
                        if (model.selectedItem) {
                            // add selected child
                            vm.selectedChildren.push(model.selectedItem);
                        }

                        // close overlay
                        overlayService.close();
                    },
                    close: function() {
                        overlayService.close();
                    }
                };

                overlayService.open(dialog);
            }

            function removeChild($index) {
                vm.selectedChildren.splice($index, 1);
            }

        }

		angular.module("umbraco").controller("My.Controller", Controller);

	})();
</pre>

@param {array} selectedChildren (<code>binding</code>): Array of selected children.
@param {array} availableChildren (<code>binding</code>: Array of items available for selection.
@param {string} parentName (<code>binding</code>): The parent name.
@param {string} parentIcon (<code>binding</code>): The parent icon.
@param {number} parentId (<code>binding</code>): The parent id.
@param {callback} onRemove (<code>binding</code>): Callback when removing an item.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>child</code>: The selected item.</li>
        <li><code>$index</code>: The selected item index.</li>
    </ul>
@param {callback} onAdd (<code>binding</code>): Callback when adding an item.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>$event</code>: The select event.</li>
    </ul>
@param {callback} onSort (<code>binding</code>): Callback when sorting an item.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>$event</code>: The select event.</li>
    </ul>
**/

(function() {
    'use strict';

    function ChildSelectorDirective(overlayService, localizationService) {

        function link(scope, el, attr, ctrl) {

            var eventBindings = [];
            scope.dialogModel = {};
            scope.showDialog = false;

            scope.removeChild = (selectedChild, $index, event) => {
               const dialog = {
                    view: "views/components/overlays/umb-template-remove-confirm.html",
                    layout: selectedChild,
                    submitButtonLabelKey: "defaultdialogs_yesRemove",
                    submitButtonStyle: "danger",
                    submit: function () {
                        if(scope.onRemove) {
                            scope.onRemove(selectedChild, $index);
                            overlayService.close();
                        }
                    },
                    close: function () {
                        overlayService.close();
                    }
                };

                localizationService.localize("general_delete").then(value => {
                    dialog.title = value;
                    overlayService.open(dialog);
                });

                event.preventDefault();
                event.stopPropagation();
            };

            scope.addChild = $event => {
               if (scope.onAdd) {
                  scope.onAdd($event);
               }
            };

            function syncParentName() {

              // update name on available item
              Utilities.forEach(scope.availableChildren, availableChild => {
                if (availableChild.id === scope.parentId) {
                   availableChild.name = scope.parentName;
                }
              });

              // update name on selected child
              Utilities.forEach(scope.selectedChildren, selectedChild => {
                if (selectedChild.id === scope.parentId) {
                   selectedChild.name = scope.parentName;
                }
              });

            }

            function syncParentIcon() {

              // update icon on available item
              Utilities.forEach(scope.availableChildren, availableChild => {
                if (availableChild.id === scope.parentId) {
                   availableChild.icon = scope.parentIcon;
                }
              });

              // update icon on selected child
              Utilities.forEach(scope.selectedChildren, selectedChild => {
                if (selectedChild.id === scope.parentId) {
                   selectedChild.icon = scope.parentIcon;
                }
              });

            }

            eventBindings.push(scope.$watch('parentName', function(newValue, oldValue){

              if (newValue === oldValue) { return; }
              if (oldValue === undefined || newValue === undefined) { return; }

              syncParentName();
            }));

            eventBindings.push(scope.$watch('parentIcon', function(newValue, oldValue){

              if (newValue === oldValue) { return; }
              if (oldValue === undefined || newValue === undefined) { return; }

              syncParentIcon();
            }));

            // sortable options for allowed child content types
            scope.sortableOptions = {
                axis: "y",
                cancel: ".unsortable",
                containment: "parent",
                distance: 10,
                opacity: 0.7,
                tolerance: "pointer",
                scroll: true,
                zIndex: 6000,
                update: function (e, ui) {
                    if(scope.onSort) {
                       scope.onSort();
                    }
                }
            };

            // clean up
            scope.$on('$destroy', function(){
              // unbind watchers
              for(var e in eventBindings) {
                eventBindings[e]();
               }
            });

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-child-selector.html',
            scope: {
                selectedChildren: '=',
                availableChildren: "=",
                parentName: "=",
                parentIcon: "=",
                parentId: "=",
                onRemove: "=",
                onAdd: "=",
                onSort: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbChildSelector', ChildSelectorDirective);

})();

----
umbfoldergrid.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbFolderGrid
@restrict E
@scope

@description
Use this directive to generate a list of folders presented as a flexbox grid.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">
        <umb-folder-grid
            ng-if="vm.folders.length > 0"
            folders="vm.folders"
            on-click="vm.clickFolder"
            on-select="vm.selectFolder">
        </umb-folder-grid>
    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller(myService) {

            var vm = this;
            vm.folders = [
                {
                    "name": "Folder 1",
                    "icon": "icon-folder",
                    "selected": false
                },
                {
                    "name": "Folder 2",
                    "icon": "icon-folder",
                    "selected": false
                }

            ];

            vm.clickFolder = clickFolder;
            vm.selectFolder = selectFolder;

            myService.getFolders().then(function(folders){
                vm.folders = folders;
            });

            function clickFolder(folder){
                // Execute when clicking folder name/link
            }

            function selectFolder(folder, event, index) {
                // Execute when clicking folder
                // set folder.selected = true; to show checkmark icon
            }

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {array} folders (<code>binding</code>): Array of folders
@param {callback=} onClick (<code>binding</code>): Callback method to handle click events on the folder.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>folder</code>: The selected folder</li>
    </ul>
@param {callback=} onSelect (<code>binding</code>): Callback method to handle click events on the checkmark icon.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>folder</code>: The selected folder</li>
        <li><code>$event</code>: The select event</li>
        <li><code>$index</code>: The folder index</li>
    </ul>
**/

(function() {
   'use strict';

   function FolderGridDirective() {

      function link(scope, el, attr, ctrl) {

         scope.clickFolder = function(folder, $event, $index) {
            if(scope.onClick) {
                scope.onClick(folder, $event, $index);
                $event.stopPropagation();
            }
         };

         scope.clickFolderName = function(folder, $event, $index) {
            if(scope.onClickName) {
               scope.onClickName(folder, $event, $index);
               $event.stopPropagation();
            }
         };

      }

      var directive = {
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/umb-folder-grid.html',
         scope: {
            folders: '=',
            onClick: "=",
            onClickName: "="
         },
         link: link
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbFolderGrid', FolderGridDirective);

})();

----
umbconfirm.directive.js
﻿/**
@ngdoc directive
@name umbraco.directives.directive:umbConfirm
@restrict E
@scope

@description
A confirmation dialog


<h3>Markup example</h3>
<pre>
	<div ng-controller="My.Controller as vm">

       <umb-confirm caption="Title" on-confirm="vm.onConfirm()" on-cancel="vm.onCancel()"></umb-confirm>

	</div>
</pre>

<h3>Controller example</h3>
<pre>
	(function () {
		"use strict";

		function Controller() {

            var vm = this;

            vm.onConfirm = function() {
                alert('Confirm clicked');
            };

            vm.onCancel = function() {
                alert('Cancel clicked');
            }


        }

		angular.module("umbraco").controller("My.Controller", Controller);

	})();
</pre>

@param {string} caption (<code>attribute</code>): The caption shown above the buttons
@param {callback} on-confirm (<code>attribute</code>): The call back when the "OK" button is clicked. If not set the button will not be shown
@param {callback} on-cancel (<code>atribute</code>): The call back when the "Cancel" button is clicked. If not set the button will not be shown
**/
function confirmDirective() {
    return {
        restrict: "E",    // restrict to an element
        replace: true,   // replace the html element with the template
        templateUrl: 'views/components/umb-confirm.html',
        scope: {
            onConfirm: '=',
            onCancel: '=',
            caption: '@',
            confirmButtonStyle: '@',
            confirmDisabled: '<?',
            confirmLabelKey: '@'
        },
        link: function (scope, element, attr, ctrl) {
            scope.showCancel = false;
            scope.showConfirm = false;
            scope.confirmButtonState = "init";

            if (scope.onConfirm) {
                scope.showConfirm = true;
            }

            if (scope.onCancel) {
                scope.showCancel = true;
            }

            scope.confirm = function () {
                if (!scope.onConfirm) {
                    return;
                }

                scope.confirmButtonState = "busy";
                scope.onConfirm();
            }
        }
    };
}
angular.module('umbraco.directives').directive("umbConfirm", confirmDirective);

----
umbaceeditor.directive.js
(function() {
    'use strict';

    function AceEditorDirective(umbAceEditorConfig, assetsService, angularHelper) {

        /**
         * Sets editor options such as the wrapping mode or the syntax checker.
         *
         * The supported options are:
         *
         *   <ul>
         *     <li>showGutter</li>
         *     <li>useWrapMode</li>
         *     <li>onLoad</li>
         *     <li>theme</li>
         *     <li>mode</li>
         *   </ul>
         *
         * @param acee
         * @param session ACE editor session
         * @param {object} opts Options to be set
         */
        var setOptions = function(acee, session, opts) {

            // sets the ace worker path, if running from concatenated
            // or minified source
            if (Utilities.isDefined(opts.workerPath)) {
                var config = window.ace.require('ace/config');
                config.set('workerPath', opts.workerPath);
            }

            // ace requires loading
            if (Utilities.isDefined(opts.require)) {
                opts.require.forEach(function(n) {
                    window.ace.require(n);
                });
            }

            // Boolean options
            if (Utilities.isDefined(opts.showGutter)) {
                acee.renderer.setShowGutter(opts.showGutter);
            }
            if (Utilities.isDefined(opts.useWrapMode)) {
                session.setUseWrapMode(opts.useWrapMode);
            }
            if (Utilities.isDefined(opts.showInvisibles)) {
                acee.renderer.setShowInvisibles(opts.showInvisibles);
            }
            if (Utilities.isDefined(opts.showIndentGuides)) {
                acee.renderer.setDisplayIndentGuides(opts.showIndentGuides);
            }
            if (Utilities.isDefined(opts.useSoftTabs)) {
                session.setUseSoftTabs(opts.useSoftTabs);
            }
            if (Utilities.isDefined(opts.showPrintMargin)) {
                acee.setShowPrintMargin(opts.showPrintMargin);
            }

            // commands
            if (Utilities.isDefined(opts.disableSearch) && opts.disableSearch) {
                acee.commands.addCommands([{
                    name: 'unfind',
                    bindKey: {
                        win: 'Ctrl-F',
                        mac: 'Command-F'
                    },
                    exec: function() {
                        return false;
                    },
                    readOnly: true
                }]);
            }

            // Basic options
            if (Utilities.isString(opts.theme)) {
                acee.setTheme('ace/theme/' + opts.theme);
            }
            if (Utilities.isString(opts.mode)) {
                session.setMode('ace/mode/' + opts.mode);
            }
            // Advanced options
            if (Utilities.isDefined(opts.firstLineNumber)) {
                if (Utilities.isNumber(opts.firstLineNumber)) {
                    session.setOption('firstLineNumber', opts.firstLineNumber);
                } else if (Utilities.isFunction(opts.firstLineNumber)) {
                    session.setOption('firstLineNumber', opts.firstLineNumber());
                }
            }

            // advanced options
            var key, obj;
            if (Utilities.isDefined(opts.advanced)) {
                for (key in opts.advanced) {
                    // create a javascript object with the key and value
                    obj = {
                        name: key,
                        value: opts.advanced[key]
                    };
                    // try to assign the option to the ace editor
                    acee.setOption(obj.name, obj.value);
                }
            }

            // advanced options for the renderer
            if (Utilities.isDefined(opts.rendererOptions)) {
                for (key in opts.rendererOptions) {
                    // create a javascript object with the key and value
                    obj = {
                        name: key,
                        value: opts.rendererOptions[key]
                    };
                    // try to assign the option to the ace editor
                    acee.renderer.setOption(obj.name, obj.value);
                }
            }

            // onLoad callbacks
            Utilities.forEach(opts.callbacks, cb => {
                if (Utilities.isFunction(cb)) {
                    cb(acee);
                }
            });
        };

        function link(scope, el, attr, ngModel) {

            // Load in ace library
            assetsService.load(['lib/ace-builds/src-min-noconflict/ace.js', 'lib/ace-builds/src-min-noconflict/ext-language_tools.js'], scope).then(function () {
                if (Utilities.isUndefined(window.ace)) {
                    throw new Error('ui-ace need ace to work... (o rly?)');
                } else {
                    // init editor
                    init();
                }
            });

            function init() {

                /**
                 * Corresponds the umbAceEditorConfig ACE configuration.
                 * @type object
                 */
                var options = umbAceEditorConfig.ace || {};

                /**
                 * umbAceEditorConfig merged with user options via json in attribute or data binding
                 * @type object
                 */
                var opts = Utilities.extend({}, options, scope.umbAceEditor);

                //load ace libraries here... 

                /**
                 * ACE editor
                 * @type object
                 */
                var acee = window.ace.edit(el[0]);
                acee.$blockScrolling = Infinity;

                /**
                 * ACE editor session.
                 * @type object
                 * @see [EditSession]{@link https://ace.c9.io/#nav=api&api=edit_session}
                 */
                var session = acee.getSession();

                /**
                 * Reference to a change listener created by the listener factory.
                 * @function
                 * @see listenerFactory.onChange
                 */
                var onChangeListener;

                /**
                 * Reference to a blur listener created by the listener factory.
                 * @function
                 * @see listenerFactory.onBlur
                 */
                var onBlurListener;

                /**
                 * Calls a callback by checking its existing. The argument list
                 * is variable and thus this function is relying on the arguments
                 * object.
                 * @throws {Error} If the callback isn't a function
                 */
                var executeUserCallback = function() {

                    /**
                     * The callback function grabbed from the array-like arguments
                     * object. The first argument should always be the callback.
                     *
                     * @see [arguments]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments}
                     * @type {*}
                     */
                    var callback = arguments[0];

                    /**
                     * Arguments to be passed to the callback. These are taken
                     * from the array-like arguments object. The first argument
                     * is stripped because that should be the callback function.
                     *
                     * @see [arguments]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments}
                     * @type {Array}
                     */
                    var args = Array.prototype.slice.call(arguments, 1);

                    if (Utilities.isDefined(callback)) {
                        scope.$evalAsync(function() {
                            if (Utilities.isFunction(callback)) {
                                callback(args);
                            } else {
                                throw new Error('ui-ace use a function as callback.');
                            }
                        });
                    }
                };



                /**
                 * Listener factory. Until now only change listeners can be created.
                 * @type object
                 */
                var listenerFactory = {
                    /**
                     * Creates a change listener which propagates the change event
                     * and the editor session to the callback from the user option
                     * onChange. It might be exchanged during runtime, if this
                     * happens the old listener will be unbound.
                     *
                     * @param callback callback function defined in the user options
                     * @see onChangeListener
                     */
                    onChange: function(callback) {
                        return function(e) {
                            var newValue = session.getValue();
                            angularHelper.safeApply(scope, function () {
                                scope.model = newValue;
                            });
                            executeUserCallback(callback, e, acee);
                        };
                    },
                    /**
                     * Creates a blur listener which propagates the editor session
                     * to the callback from the user option onBlur. It might be
                     * exchanged during runtime, if this happens the old listener
                     * will be unbound.
                     *
                     * @param callback callback function defined in the user options
                     * @see onBlurListener
                     */
                    onBlur: function(callback) {
                        return function() {
                            executeUserCallback(callback, acee);
                        };
                    }
                };

                attr.$observe('readonly', function(value) {
                    acee.setReadOnly(!!value || value === '');
                });

                // Value Blind
                if(scope.model) {
                    session.setValue(scope.model);
                }

                // Listen for option updates
                var updateOptions = function(current, previous) {
                    if (current === previous) {
                        return;
                    }

                    opts = Utilities.extend({}, options, scope.umbAceEditor);

                    opts.callbacks = [opts.onLoad];
                    if (opts.onLoad !== options.onLoad) {
                        // also call the global onLoad handler
                        opts.callbacks.unshift(options.onLoad);
                    }

                    if (opts.autoFocus === true) {
                        acee.focus();
                    }

                    // EVENTS

                    // unbind old change listener
                    session.removeListener('change', onChangeListener);

                    // bind new change listener
                    onChangeListener = listenerFactory.onChange(opts.onChange);
                    session.on('change', onChangeListener);

                    // unbind old blur listener
                    //session.removeListener('blur', onBlurListener);
                    acee.removeListener('blur', onBlurListener);

                    // bind new blur listener
                    onBlurListener = listenerFactory.onBlur(opts.onBlur);
                    acee.on('blur', onBlurListener);

                    setOptions(acee, session, opts);
                };

                scope.$watch(scope.umbAceEditor, updateOptions, /* deep watch */ true);

                // set the options here, even if we try to watch later, if this
                // line is missing things go wrong (and the tests will also fail)
                updateOptions(options);

                el.on('$destroy', function() {
                    acee.session.$stopWorker();
                    acee.destroy();
                });

                scope.$watch(function() {
                    return [el[0].offsetWidth, el[0].offsetHeight];
                }, function() {
                    acee.resize();
                    acee.renderer.updateFull();
                }, true);

            }

        }

        var directive = {
            restrict: 'EA',
            scope: {
                "umbAceEditor": "=",
                "model": "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives')
        .constant('umbAceEditorConfig', {})
        .directive('umbAceEditor', AceEditorDirective);

})();

----
umbconfirmaction.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbConfirmAction
@restrict E
@scope

@description
<p>Use this directive to toggle a confirmation prompt for an action.
The prompt consists of a checkmark and a cross to confirm or cancel the action.
The prompt can be opened in four direction up, down, left or right.</p>

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <div class="my-action" style="position:relative;">
            <umb-icon icon="icon-trash" ng-click="vm.showPrompt()"></umb-icon>
            <umb-confirm-action
                ng-if="vm.promptIsVisible"
                direction="left"
                on-confirm="vm.confirmAction()"
                on-cancel="vm.hidePrompt()">
            </umb-confirm-action>
        </div>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {

        "use strict";

        function Controller() {

            var vm = this;
            vm.promptIsVisible = false;

            vm.confirmAction = confirmAction;
            vm.showPrompt = showPrompt;
            vm.hidePrompt = hidePrompt;

            function confirmAction() {
                // confirm logic here
            }

            function showPrompt() {
                vm.promptIsVisible = true;
            }

            function hidePrompt() {
                vm.promptIsVisible = false;
            }

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {string} direction The direction the prompt opens ("up", "down", "left", "right").
@param {callback} onConfirm Callback when the checkmark is clicked.
@param {callback} onCancel Callback when the cross is clicked.
**/

(function() {
  'use strict';

  function ConfirmAction() {

    function link(scope, el, attr, ctrl) {

      scope.clickConfirm = function() {
          if(scope.onConfirm) {
              scope.onConfirm();
          }
      };

      scope.clickCancel = function() {
          if(scope.onCancel) {
              scope.onCancel();
          }
      };

    }

    var directive = {
      restrict: 'E',
      replace: true,
      templateUrl: 'views/components/umb-confirm-action.html',
      scope: {
        direction: "@",
        onConfirm: "&",
        onCancel: "&"
      },
      link: link
    };

    return directive;
  }

  angular.module('umbraco.directives').directive('umbConfirmAction', ConfirmAction);

})();

----
umbavatar.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbAvatar
@restrict E
@scope

@description
Use this directive to render an avatar.

<h3>Markup example</h3>
<pre>
	<div ng-controller="My.Controller as vm">

        <umb-avatar
            size="xs"
            img-src="{{vm.avatar[0].value}}"
            img-srcset="{{vm.avatar[1].value}} 2x, {{vm.avatar[2].value}} 3x">
        </umb-avatar>

	</div>
</pre>

<h3>Controller example</h3>
<pre>
	(function () {
		"use strict";

		function Controller() {

            var vm = this;

            vm.avatar = [
                { value: "assets/logo.png" },
                { value: "assets/logo@2x.png" },
                { value: "assets/logo@3x.png" }
            ];

        }

		angular.module("umbraco").controller("My.Controller", Controller);

	})();
</pre>

@param {string} size (<code>attribute</code>): The size of the avatar (xs, s, m, l, xl).
@param {string} img-src (<code>attribute</code>): The image source to the avatar.
@param {string} img-srcset (<code>atribute</code>): Reponsive support for the image source.
@param {string=} name (<code>attribute</code>): Name initials will be used if no image source.
@param {string=} color (<code>attribute</code>): Color will be used if no image source (primary, secondary, success, warning, danger).
**/

(function() {
    'use strict';

    function AvatarDirective(localizationService) {

        function link(scope, element, attrs, ctrl) {
            
            var eventBindings = [];
            scope.initials = "";
            scope.avatarAlt = "";

            function onInit() {
                if (!scope.unknownChar) {
                    scope.unknownChar = "?";
                }
                scope.initials = getNameInitials(scope.name);
                setAvatarAlt(scope.name);
            }

            function getNameInitials(name) {
                if (name) {
                    const notAllowedRegex = /[^\p{Letter}\p{Number} ]+/gu;
                    var names = name.replace(notAllowedRegex, '').trim().split(' '),
                        initials = names[0].substring(0, 1);

                    if (names.length > 1) {
                        initials += names[names.length - 1].substring(0, 1);
                    }
                    return initials.toUpperCase();
                }
                return null;
            }

            function setAvatarAlt(name) {
                if (name) {
                    localizationService
                        .localize('general_avatar')
                        .then(function(data) {
                                scope.avatarAlt = data + ' ' + name;
                            }
                        );
                }
                scope.avatarAlt = null;
            }

            eventBindings.push(scope.$watch('name', function (newValue, oldValue) {
                if (newValue === oldValue) { return; }
                if (oldValue === undefined || newValue === undefined) { return; }
                scope.initials = getNameInitials(newValue);
                setAvatarAlt(newValue);
            }));

            onInit();

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-avatar.html',
            scope: {
                size: "@",
                name: "@",
                color: "@",
                imgSrc: "@",
                imgSrcset: "@",
                unknownChar: "@"
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbAvatar', AvatarDirective);

})();

----
umbbadge.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbBadge
@restrict E
@scope

@description
Use this directive to render a badge.

<h3>Markup example</h3>
<pre>
    <div>

        <umb-badge
            size="s"
            color="secondary">
        </umb-badge>

	</div>
</pre>

@param {string} size (<code>attribute</code>): The size (xxs, xs, s, m, l, xl).
@param {string} color (<code>attribute</code>): The color of the highlight (primary, secondary, success, warning, danger, gray).
**/

(function () {
    'use strict';

    function BadgeDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/umb-badge.html',
            scope: {
                size: "@?",
                color: "@?"
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbBadge', BadgeDirective);

})();

----
umbcontentgrid.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbContentGrid
@restrict E
@scope

@description
Use this directive to generate a list of content items presented as a flexbox grid.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-content-grid
            content="vm.contentItems"
            content-properties="vm.includeProperties"
            on-click="vm.selectItem"
            on-click-name="vm.clickItem">
        </umb-content-grid>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;
            vm.contentItems = [
                {
                    "name": "Cape",
                    "published": true,
                    "icon": "icon-document",
                    "updateDate": "15-02-2016",
                    "owner": "Mr. Batman",
                    "selected": false
                },
                {
                    "name": "Utility Belt",
                    "published": true,
                    "icon": "icon-document",
                    "updateDate": "15-02-2016",
                    "owner": "Mr. Batman",
                    "selected": false
                },
                {
                    "name": "Cave",
                    "published": true,
                    "icon": "icon-document",
                    "updateDate": "15-02-2016",
                    "owner": "Mr. Batman",
                    "selected": false
                }
            ];
            vm.includeProperties = [
                {
                  "alias": "updateDate",
                  "header": "Last edited"
                },
                {
                  "alias": "owner",
                  "header": "Created by"
                }
            ];

            vm.clickItem = clickItem;
            vm.selectItem = selectItem;


            function clickItem(item, $event, $index){
                // do magic here
            }

            function selectItem(item, $event, $index) {
                // set item.selected = true; to select the item
                // do magic here
            }

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {array} content (<code>binding</code>): Array of content items.
@param {array=} contentProperties (<code>binding</code>): Array of content item properties to include in the item. If left empty the item will only show the item icon and name.
@param {callback=} onClick (<code>binding</code>): Callback method to handle click events on the content item.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>item</code>: The clicked item</li>
        <li><code>$event</code>: The select event</li>
        <li><code>$index</code>: The item index</li>
    </ul>
@param {callback=} onClickName (<code>binding</code>): Callback method to handle click events on the checkmark icon.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>item</code>: The selected item</li>
        <li><code>$event</code>: The select event</li>
        <li><code>$index</code>: The item index</li>
    </ul>
**/

(function() {
   'use strict';

   function ContentGridDirective() {

      function link(scope, el, attr, ctrl) {

         scope.clickItem = function(item, $event, $index) {
            if(scope.allowClick !== false && scope.onClick) {
               scope.onClick(item, $event, $index);
            }
         };

         scope.clickItemName = function(item, $event, $index) {
            if(scope.onClickName && !($event.metaKey || $event.ctrlKey)) {
               scope.onClickName(item, $event, $index);
               $event.preventDefault();
            }
            $event.stopPropagation();
         };

      }

      var directive = {
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/umb-content-grid.html',
         scope: {
            content: '=',
            contentProperties: "=",
            allowClick: "<?",
            onClick: "=",
            onClickName: "="
         },
         link: link
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbContentGrid', ContentGridDirective);

})();

----
umbminisearch.component.js
(function () {
    'use strict';

    angular
        .module('umbraco')
        .component('umbMiniSearch', {
            templateUrl: 'views/components/umb-mini-search.html',
            controller: UmbMiniSearchController,
            controllerAs: 'vm',
            bindings: {
                model: "=",
                onStartTyping: "&?",
                onSearch: "&?",
                onBlur: "&?",
                labelKey: "@?",
                inputId: "@?"
            }
        });

    function UmbMiniSearchController($scope, localizationService) {

        var vm = this;

        vm.onKeyDown = onKeyDown;
        vm.onChange = onChange;
        vm.$onInit = onInit;

        var searchDelay = _.debounce(function () {
            $scope.$apply(function () {
                if (vm.onSearch) {
                    vm.onSearch();
                }
            });
        }, 500);

        function onKeyDown(evt) {
            //13: enter
            switch (evt.keyCode) {
                case 13:
                    if (vm.onSearch) {
                        vm.onSearch();
                    }
                    break;
            }
        }

        function onChange() {
            if (vm.onStartTyping) {
                vm.onStartTyping();
            }
            searchDelay();
        }

        function onInit() {
            vm.inputId = vm.inputId || "search_" + String.CreateGuid();
            setText();
        }

        function setText() {
            var keyToLocalize = vm.labelKey || 'general_search';

            localizationService.localize(keyToLocalize).then(function (data) {
                // If a labelKey is passed let's update the returned text if it's does not contain an opening square bracket [
                if(data.indexOf('[') === -1){
                    vm.text = data;
                }
            });
        }
    }

})();

----
umbcheckmark.directive.js
(function() {
    'use strict';

    function CheckmarkDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/umb-checkmark.html',
            scope: {
                size: "@?",
                checked: "=",
                readonly: "@?"
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbCheckmark', CheckmarkDirective);

})();

----
umbtextarea.directive.js
﻿(function () {
    'use strict';

    function umbTextarea($document) {

        function autogrow(scope, element, attributes) {
            if (!element.hasClass("autogrow")) {
                // no autogrow for you today
                return;
            }

            // get possible minimum height style
            var minHeight = parseInt(window.getComputedStyle(element[0]).getPropertyValue("min-height")) || 0;

            // prevent newlines in textbox
            element.on("keydown", function (evt) {
                if (evt.which === 13) {
                    //evt.preventDefault();
                }
            });

            element.on("input", function (evt) {
                element.css({
                    height: 'auto',
                    minHeight: 0
                });

                var contentHeight = this.scrollHeight;
                var borderHeight = 1;
                var paddingHeight = 4;

                element.css({
                    minHeight: null, // remove property
                    height: contentHeight + borderHeight + paddingHeight + "px" // because we're using border-box
                });
            });

            // watch model changes from the outside to adjust height
            scope.$watch(attributes.ngModel, trigger);

            // set initial size
            trigger();

            function trigger() {
                setTimeout(element.triggerHandler.bind(element, "input"), 1);
            }
        }

        var directive = {
            restrict: 'E',
            link: autogrow
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('textarea', umbTextarea);

})();

----
umbnestedcontent.directive.js
﻿angular.module("umbraco.directives").directive('umbNestedContentEditor', [

    function () {

        var link = function ($scope, el, attrs) {

            // Clone the model because some property editors
            // do weird things like updating and config values
            // so we want to ensure we start from a fresh every
            // time, we'll just sync the value back when we need to
            $scope.model = Utilities.copy($scope.ngModel);
            $scope.nodeContext = $scope.model;

            $scope.readonly = false;

            attrs.$observe('readonly', (value) => {
                $scope.readonly = value !== undefined;
            });

            // Find the selected tab
            var selectedTab = $scope.model.variants[0].tabs[0];

            if ($scope.tabAlias) {
                Utilities.forEach($scope.model.variants[0].tabs, tab => {
                    if (tab.alias.toLowerCase() === $scope.tabAlias.toLowerCase()) {
                        selectedTab = tab;
                        return;
                    }
                });
            }

            $scope.tab = selectedTab;

            // Listen for sync request
            var unsubscribe = $scope.$on("ncSyncVal", function (ev, args) {
                if (args.key === $scope.model.key) {

                    // Tell inner controls we are submitting
                    $scope.$broadcast("formSubmitting", { scope: $scope });

                    // Sync the values back
                    Utilities.forEach($scope.ngModel.variants[0].tabs, tab => {
                        if (tab.alias.toLowerCase() === selectedTab.alias.toLowerCase()) {

                            var localPropsMap = selectedTab.properties.reduce((map, obj) => {
                                map[obj.alias] = obj;
                                return map;
                            }, {});

                            Utilities.forEach(tab.properties, prop => {
                                if (localPropsMap.hasOwnProperty(prop.alias)) {
                                    prop.value = localPropsMap[prop.alias].value;
                                }
                            });
                        }
                    });
                    
                }
            });

            $scope.$on('$destroy', function () {
                unsubscribe();
            });
        };

        return {
            restrict: "E",
            replace: true,
            templateUrl: Umbraco.Sys.ServerVariables.umbracoSettings.umbracoPath + "/views/propertyeditors/nestedcontent/nestedcontent.editor.html",
            scope: {
                ngModel: '=',
                tabAlias: '='
            },
            link: link
        };

    }
]);

//angular.module("umbraco.directives").directive('nestedContentSubmitWatcher', function () {
//    var link = function (scope) {
//        // call the load callback on scope to obtain the ID of this submit watcher
//        var id = scope.loadCallback();
//        scope.$on("formSubmitting", function (ev, args) {
//            // on the "formSubmitting" event, call the submit callback on scope to notify the nestedContent controller to do it's magic
//            if (id === scope.activeSubmitWatcher) {
//                scope.submitCallback();
//            }
//        });
//    }

//    return {
//        restrict: "E",
//        replace: true,
//        template: "",
//        scope: {
//            loadCallback: '=',
//            submitCallback: '=',
//            activeSubmitWatcher: '='
//        },
//        link: link
//    }
//});

----
umbnodepreview.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbNodePreview
@restrict E
@scope

@description
<strong>Added in Umbraco v. 7.6:</strong> Use this directive to render a node preview.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.NodePreviewController as vm">
        
        <div ui-sortable ng-model="vm.nodes">
            <umb-node-preview
                ng-repeat="node in vm.nodes"
                icon="node.icon"
                name="node.name"
                alias="node.alias"
                published="node.published"
                description="node.description"
                sortable="vm.sortable"
                allow-remove="vm.allowRemove"
                allow-open="vm.allowOpen"
                on-remove="vm.remove($index, vm.nodes)"
                on-open="vm.open(node)">
            </umb-node-preview>
        </div>
    
    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";
    
        function Controller() {
    
            var vm = this;
    
            vm.allowRemove = true;
            vm.allowOpen = true;
            vm.sortable = true;
    
            vm.nodes = [
                {
                    "icon": "icon-document",
                    "name": "My node 1",
                    "published": true,
                    "description": "A short description of my node"
                },
                {
                    "icon": "icon-document",
                    "name": "My node 2",
                    "published": true,
                    "description": "A short description of my node"
                }
            ];
    
            vm.remove = remove;
            vm.open = open;
    
            function remove(index, nodes) {
                alert("remove node");
            }
    
            function open(node) {
                alert("open node");
            }
    
        }
    
        angular.module("umbraco").controller("My.NodePreviewController", Controller);
    
    })();
</pre>

@param {string} icon (<code>binding</code>): The node icon.
@param {string} name (<code>binding</code>): The node name.
@param {string} alias (<code>binding</code>): The node document type alias will be displayed on hover if in debug mode or logged in as admin
@param {boolean} published (<code>binding</code>): The node published state.
@param {string} description (<code>binding</code>): A short description.
@param {boolean} sortable (<code>binding</code>): Will add a move cursor on the node preview. Can used in combination with ui-sortable.
@param {boolean} allowRemove (<code>binding</code>): Show/Hide the remove button.
@param {boolean} allowOpen (<code>binding</code>): Show/Hide the open button.
@param {boolean} allowEdit (<code>binding</code>): Show/Hide the edit button (Added in version 7.7.0).
@param {function} onRemove (<code>expression</code>): Callback function when the remove button is clicked.
@param {function} onOpen (<code>expression</code>): Callback function when the open button is clicked.
@param {function} onEdit (<code>expression</code>): Callback function when the edit button is clicked (Added in version 7.7.0).
@param {string} openUrl (<code>binding</code>): Fallback URL for <code>onOpen</code> (Added in version 7.12.0).
@param {string} editUrl (<code>binding</code>): Fallback URL for <code>onEdit</code> (Added in version 7.12.0).
@param {string} removeUrl (<code>binding</code>): Fallback URL for <code>onRemove</code> (Added in version 7.12.0).
**/

(function () {
    'use strict';

    function NodePreviewDirective(userService) {

        function link(scope, el, attr, ctrl) {
            if (!scope.editLabelKey) {
                scope.editLabelKey = "general_edit";
            }

            scope.nodeNameTitle = null;
            if(Umbraco.Sys.ServerVariables.isDebuggingEnabled) {
                userService.getCurrentUser().then(function (u) {
                    if (u.allowedSections.indexOf("settings") !== -1 ? true : false) {
                        scope.nodeNameTitle = scope.alias;
                    }
                });
            }
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-node-preview.html',
            scope: {
                icon: "=?",
                name: "=",
                alias: "=?",
                description: "=?",
                permissions: "=?",
                published: "=?",
                sortable: "=?",
                allowOpen: "=?",
                allowRemove: "=?",
                allowEdit: "=?",
                allowChange: "=?",
                onOpen: "&?",
                onRemove: "&?",
                onEdit: "&?",
                onChange: "&?",
                openUrl: '=?',
                editUrl: '=?',
                removeUrl: '=?'
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbNodePreview', NodePreviewDirective);

})();

----
umbdatetimepicker.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbDateTimePicker
@restrict E
@scope

@description
<b>Added in Umbraco version 8.0</b>
This directive is a wrapper of the flatpickr library. Use it to render a date time picker.
For extra details about options and events take a look here: https://flatpickr.js.org

Use this directive to render a date time picker

<h3>Markup example</h3>
<pre>
	<div ng-controller="My.Controller as vm">

		<umb-date-time-picker
			ng-model="vm.date"
            options="vm.config"
            on-change="vm.datePickerChange(selectedDates, dateStr, instance)">
        </umb-date-time-picker>

	</div>
</pre>

<h3>Controller example</h3>
<pre>
	(function () {
		"use strict";

		function Controller() {

            var vm = this;

            vm.date = "2018-10-10 10:00";

            vm.config = {
				enableTime: true,
				dateFormat: "Y-m-d H:i",
				time_24hr: true
            };

            vm.datePickerChange = datePickerChange;

            function datePickerChange(selectedDates, dateStr, instance) {
            	// handle change
            }

        }

		angular.module("umbraco").controller("My.Controller", Controller);

	})();
</pre>

@param {object} ngModel (<code>binding</code>): Config object for the date picker.
@param {object} options (<code>binding</code>): Config object for the date picker.
@param {callback} onSetup (<code>callback</code>): onSetup gets triggered when the date picker is initialized
@param {callback} onChange (<code>callback</code>): onChange gets triggered when the user selects a date, or changes the time on a selected date.
@param {callback} onOpen (<code>callback</code>): onOpen gets triggered when the calendar is opened.
@param {callback} onClose (<code>callback</code>): onClose gets triggered when the calendar is closed.
@param {callback} onMonthChange (<code>callback</code>): onMonthChange gets triggered when the month is changed, either by the user or programmatically.
@param {callback} onYearChange (<code>callback</code>): onMonthChange gets triggered when the year is changed, either by the user or programmatically.
@param {callback} onReady (<code>callback</code>): onReady gets triggered once the calendar is in a ready state.
@param {callback} onValueUpdate (<code>callback</code>): onValueUpdate gets triggered when the input value is updated with a new date string.
@param {callback} onDayCreate (<code>callback</code>): Take full control of every date cell with theonDayCreate()hook.
**/

(function () {
    'use strict';

    var umbDateTimePicker = {
        template: '<ng-transclude>' +
            '<input type="text" ng-if="!$ctrl.options.inline" ng-model="$ctrl.ngModel" placeholder="Select Date.." ng-attr-aria-labelledby="{{$ctrl.label}}"></input>' +
            '<div ng-if="$ctrl.options.inline"></div>' +
            '</ng-transclude>',
        controller: umbDateTimePickerCtrl,
        transclude: true,
        bindings: {
            ngModel: '<',
            options: '<',
            onSetup: '&?',
            onChange: '&?',
            onOpen: '&?',
            onClose: '&?',
            onMonthChange: '&?',
            onYearChange: '&?',
            onReady: '&?',
            onValueUpdate: '&?',
            onDayCreate: '&?',
            label: '@'
        }
    };

    function umbDateTimePickerCtrl($element, $timeout, $scope, assetsService, userService) {

        var ctrl = this;
        var userLocale = null;

        ctrl.$onInit = function () {

            // load css file for the date picker
            assetsService.loadCss('lib/flatpickr/flatpickr.min.css', $scope).then(function () {
                userService.getCurrentUser().then(function (user) {

                    // init date picker
                    userLocale = user.locale;
                    if (userLocale.indexOf('-') > -1) {
                        userLocale = userLocale.split('-')[0];
                    }

                    grabElementAndRunFlatpickr();
                });
            });

        };

        function grabElementAndRunFlatpickr() {
            $timeout(function () {
                var transcludeEl = $element.find('ng-transclude')[0];
                var element = transcludeEl.children[0];

                setDatepicker(element);
            }, 0, true);
        }

        function setDatepicker(element) {
            var fpLib = flatpickr ? flatpickr : FlatpickrInstance;

            if (!fpLib) {
                return console.warn('Unable to find any flatpickr installation');
            }

            var fpInstance;

            setUpCallbacks();

            if (!ctrl.options.locale) {
                ctrl.options.locale = userLocale;
            }

            // handle special keydown events
            ctrl.options.onKeyDown = function (selectedDates, dateStr, instance, event) {
                var code = event.keyCode || event.which;
                if (code === 13) {
                    // close the datepicker on enter (this happens when entering time)
                    fpInstance.close()
                }
            };

            fpInstance = new fpLib(element, ctrl.options);

            if (ctrl.onSetup) {
                ctrl.onSetup({
                    fpItem: fpInstance
                });
            }

            // If has ngModel set the date
            if (ctrl.ngModel) {
                fpInstance.setDate(ctrl.ngModel);
            }

            // destroy the flatpickr instance when the dom element is removed
            $(element).on('$destroy', function () {
                fpInstance.destroy();
            });

            // Refresh the scope
            $scope.$applyAsync();
        }

        function setUpCallbacks() {
            // bind hook for onChange
            if (ctrl.options && ctrl.onChange) {
                ctrl.options.onChange = function (selectedDates, dateStr, instance) {
                    $timeout(function () {
                        ctrl.onChange({ selectedDates: selectedDates, dateStr: dateStr, instance: instance });
                    });
                };
            }

            // bind hook for onOpen
            if (ctrl.options && ctrl.onOpen) {
                ctrl.options.onOpen = function (selectedDates, dateStr, instance) {
                    $timeout(function () {
                        ctrl.onOpen({ selectedDates: selectedDates, dateStr: dateStr, instance: instance });
                    });
                };
            }

			// bind hook for onOpen
            if (ctrl.options && ctrl.onClose) {
                ctrl.options.onClose = function (selectedDates, dateStr, instance) {
                    $timeout(function () {
                        ctrl.onClose({ selectedDates: selectedDates, dateStr: dateStr, instance: instance });
                    });
                };
            }

            // bind hook for onMonthChange
            if (ctrl.options && ctrl.onMonthChange) {
                ctrl.options.onMonthChange = function (selectedDates, dateStr, instance) {
                    $timeout(function () {
                        ctrl.onMonthChange({ selectedDates: selectedDates, dateStr: dateStr, instance: instance });
                    });
                };
            }

            // bind hook for onYearChange
            if (ctrl.options && ctrl.onYearChange) {
                ctrl.options.onYearChange = function (selectedDates, dateStr, instance) {
                    $timeout(function () {
                        ctrl.onYearChange({ selectedDates: selectedDates, dateStr: dateStr, instance: instance });
                    });
                };
            }

            // bind hook for onReady
            if (ctrl.options && ctrl.onReady) {
                ctrl.options.onReady = function (selectedDates, dateStr, instance) {
                    $timeout(function () {
                        ctrl.onReady({ selectedDates: selectedDates, dateStr: dateStr, instance: instance });
                    });
                };
            }

            // bind hook for onValueUpdate
            if (ctrl.onValueUpdate) {
                ctrl.options.onValueUpdate = function (selectedDates, dateStr, instance) {
                    $timeout(function () {
                        ctrl.onValueUpdate({ selectedDates: selectedDates, dateStr: dateStr, instance: instance });
                    });
                };
            }

            // bind hook for onDayCreate
            if (ctrl.onDayCreate) {
                ctrl.options.onDayCreate = function (selectedDates, dateStr, instance) {
                    $timeout(function () {
                        ctrl.onDayCreate({ selectedDates: selectedDates, dateStr: dateStr, instance: instance });
                    });
                };
            }

        }
    }

    // umbFlatpickr (umb-flatpickr) is deprecated, but we keep it for backwards compatibility
    angular.module('umbraco.directives').component('umbFlatpickr', umbDateTimePicker);
    angular.module('umbraco.directives').component('umbDateTimePicker', umbDateTimePicker);
})();

----
umbcolorpicker.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbColorPicker
@restrict E
@scope

@description
<strong>Added in Umbraco v. 8.10:</strong> Use this directive to render a color picker.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.ColorController as vm">
        
        <umb-color-picker
            options="vm.options"
            on-show="vm.show(color)"
            on-hide="vm.hide(color)"
            on-change="vm.change(color)">
        </umb-color-picker>
    
    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";
    
        function Controller() {
    
            var vm = this;

            vm.options = {
                type: "color",
                color: defaultColor,
                showAlpha: false,
                showPalette: true,
                showPaletteOnly: false,
                preferredFormat: "hex",
            };
            
            vm.show = show;
            vm.hide = hide;
            vm.change = change;

            function show(color) {
                color.toHexString().trimStart("#");
            }

            function hide(color) {
                color.toHexString().trimStart("#");
            }

            function change(color) {
                color.toHexString().trimStart("#");
            }
        }
    
        angular.module("umbraco").controller("My.ColorController", Controller);
    
    })();
</pre>

@param {string} ngModel (<code>binding</code>): Value for the color picker.
@param {object} options (<code>binding</code>): Config object for the color picker.
@param {function} onBeforeShow (<code>expression</code>): You can prevent the color picker from showing up if you return false in the beforeShow event. This event is ignored on a flat color picker.
@param {function} onChange (<code>expression</code>): Called as the original input changes. Only happens when the input is closed or the 'Choose' button is clicked.
@param {function} onShow (<code>expression</code>): Called after the color picker is opened. This is ignored on a flat color picker. Note, when any color picker on the page is shown it will hide any that are already open.
@param {function} onHide (<code>expression</code>): Called after the color picker is hidden. This happens when clicking outside of the picker while it is open. Note, when any color picker on the page is shown it will hide any that are already open. This event is ignored on a flat color picker.
@param {function} onMove (<code>expression</code>): Called as the user moves around within the color picker.
@param {function} onDragStart (<code>expression</code>): Called at the beginning of a drag event on either hue slider, alpha slider, or main color picker areas.
@param {function} onDragStop (<code>expression</code>): Called at the end of a drag event on either hue slider, alpha slider, or main color picker areas.

**/

(function () {
    'use strict';

    function ColorPickerController($scope, $element, $timeout, assetsService, localizationService, $attrs) {

        const ctrl = this;

        let colorPickerInstance = null;
        let labels = {};
        let options = null;

        ctrl.readonly = false;
        ctrl.value = null;

        ctrl.$onInit = function () {

            // load the separate css for the editor to avoid it blocking our js loading
            assetsService.loadCss("lib/spectrum/spectrum.min.css", $scope);

            // load the js file for the color picker
            assetsService.load([
                //"lib/spectrum/tinycolor.js",
                "lib/spectrum/spectrum.js"
            ], $scope).then(function () {

                // init color picker
                grabElementAndRun();
            });
        }

        ctrl.$onChanges = function (changes) {
            if (colorPickerInstance && changes.ngModel) {
                colorPickerInstance.spectrum("set", changes.ngModel.currentValue);
            }
        }

        $attrs.$observe('readonly', (value) => {
            ctrl.readonly = value !== undefined;

            if (!colorPickerInstance) {
                return;
            }

            if (ctrl.readonly) {
                colorPickerInstance.spectrum('disable');
            } else {
                colorPickerInstance.spectrum('enable');
            }
        });

        function grabElementAndRun() {

            var labelKeys = [
                "general_cancel",
                "general_choose",
                "general_clear"
            ];

            localizationService.localizeMany(labelKeys).then(values => {
                labels.cancel = values[0];
                labels.choose = values[1];
                labels.clear = values[2];
            });

            $timeout(function () {
                const element = $element.find('.umb-color-picker > input')[0];
                setColorPicker(element, labels);
            }, 0, true);

        }

        function setColorPicker(element, labels) {

            // Spectrum options: https://seballot.github.io/spectrum/#options

            const defaultOptions = {
                type: "color",
                color: null,
                showAlpha: false,
                showInitial: false,
                showInput: true,
                cancelText: labels.cancel,
                clearText: labels.clear,
                chooseText: labels.choose,
                preferredFormat: "hex",
                clickoutFiresChange: true
            };

            // If has ngModel set the color
            if (ctrl.ngModel) {
                defaultOptions.color = ctrl.ngModel;
            }

            //const options = ctrl.options ? ctrl.options : defaultOptions;
            options = Utilities.extend(defaultOptions, ctrl.options);

            var elem = angular.element(element);

            // Create new color pickr instance
            const colorPicker = elem.spectrum(options);

            colorPickerInstance = colorPicker;

            if (colorPickerInstance) {
                
                if (ctrl.readonly) {
                    colorPickerInstance.spectrum('disable');
                }

                const tinyColor = colorPickerInstance.spectrum("get");
                ctrl.value = getColorString(tinyColor, options.preferredFormat);

                colorPickerInstance.on('change', (e, tinyColor) => {
                    ctrl.value = getColorString(tinyColor, options.preferredFormat);
                    $scope.$applyAsync();
                });

                // destroy the color picker instance when the dom element is removed
                elem.on('$destroy', function () {
                    colorPickerInstance.spectrum('destroy');
                });
            }

            setUpCallbacks();

            // Refresh the scope
            $scope.$applyAsync();
        }

        // Spectrum events: https://seballot.github.io/spectrum/#events

        function setUpCallbacks() {

            if (colorPickerInstance) {

                // bind hook for beforeShow
                if (ctrl.onBeforeShow) {
                    colorPickerInstance.on('beforeShow.spectrum', (e, tinycolor) => {
                        $timeout(function () {
                            ctrl.onBeforeShow({ color: tinycolor });
                        });
                    });
                }

                // bind hook for show
                if (ctrl.onShow) {
                    colorPickerInstance.on('show.spectrum', (e, tinycolor) => {
                        $timeout(function () {
                            ctrl.onShow({ color: tinycolor });
                        });
                    });
                }

                // bind hook for hide
                if (ctrl.onHide) {
                    colorPickerInstance.on('hide.spectrum', (e, tinycolor) => {
                        $timeout(function () {
                            ctrl.onHide({ color: tinycolor });
                        });
                    });
                }

                // bind hook for change
                if (ctrl.onChange) {
                    colorPickerInstance.on('change.spectrum', (e, tinycolor) => {
                        $timeout(function () {
                            ctrl.onChange({ color: tinycolor });
                        });
                    });
                }

                // bind hook for move
                if (ctrl.onMove) {
                    colorPickerInstance.on('move.spectrum', (e, tinycolor) => {
                        $timeout(function () {
                            ctrl.onMove({ color: tinycolor });
                        });
                    });
                }

                // bind hook for drag start
                if (ctrl.onDragStart) {
                    colorPickerInstance.on('dragstart.spectrum', (e, tinycolor) => {
                        $timeout(function () {
                            ctrl.onDragStart({ color: tinycolor });
                        });
                    });
                }

                // bind hook for drag stop
                if (ctrl.onDragStop) {
                    colorPickerInstance.on('dragstop.spectrum', (e, tinycolor) => {
                        $timeout(function () {
                            ctrl.onDragStop({ color: tinycolor });
                        });
                    });
                }

            }
        }

        function getColorString (tinyColor, format) {
            if (!tinyColor) {
                return;
            }

            switch(format) {
                case 'rgb':
                  return tinyColor.toRgbString();
                case 'hsv':
                  return tinyColor.toHsvString();
                case 'hsl':
                    return tinyColor.toHslString();
                case 'name':
                    return tinyColor.toName();
                default:
                    return tinyColor.toHexString();
              }
        }
    }

    angular
        .module('umbraco.directives')
        .component('umbColorPicker', {
            template: '<div class="flex items-center"><div class="umb-color-picker"><input type="hidden" /></div><small ng-if="$ctrl.readonly">{{ $ctrl.value }}</small></div>',
            controller: ColorPickerController,
            bindings: {
                ngModel: '<',
                options: '<',
                onBeforeShow: '&?',
                onShow: '&?',
                onHide: '&?',
                onChange: '&?',
                onMove: '&?',
                onDragStart: '&?',
                onDragStop: '&?'
            }
        });

})();

----
umbicon.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbIcon
@restrict E
@scope
@description
Use this directive to show an render an umbraco backoffice svg icon. All svg icons used by this directive should use the following naming convention to keep things consistent: icon-[name of icon]. For example <pre>icon-alert.svg</pre>

<h3>Markup example</h3>

Simple icon
<pre>
    <umb-icon icon="icon-alert"></umb-icon>
</pre>

Icon with additional attribute. It can be treated like any other dom element
<pre>
    <umb-icon icon="icon-alert" class="another-class"></umb-icon>
</pre>
@example
 **/

(function () {
    "use strict";

    function UmbIconDirective(iconHelper) {

        var directive = {
            replace: true,
            transclude: true,
            templateUrl: "views/components/umb-icon.html",
            scope: {
                icon: "@",
                svgString: "=?"
            },
            link: function (scope, element) {

                if (scope.svgString === undefined && scope.svgString !== null && scope.icon !== undefined && scope.icon !== null) {
                    const observer = new IntersectionObserver(_lazyRequestIcon, {rootMargin: "100px"});
                    const iconEl = element[0];

                    observer.observe(iconEl);

                    // make sure to disconnect the observer when the scope is destroyed
                    scope.$on('$destroy', function () {
                        observer.disconnect();
                    });
                }

                scope.$watch("icon", function (newValue, oldValue) {
                    if (newValue && oldValue) {

                        var newicon = newValue.split(" ")[0];
                        var oldicon = oldValue.split(" ")[0];

                        if (newicon !== oldicon) {
                            _requestIcon(newicon);
                        }
                    }
                });

                function _lazyRequestIcon(entries, observer) {
                    entries.forEach(entry => {
                        if (entry.isIntersecting === true) {
                            observer.disconnect();

                            var icon = scope.icon.split(" ")[0]; // Ensure that only the first part of the icon is used as sometimes the color is added too, e.g. see umbeditorheader.directive scope.openIconPicker

                            _requestIcon(icon);
                        }
                    });
                }

                function _requestIcon(icon) {
                    // Reset svg string before requesting new icon.
                    scope.svgString = null;

                    iconHelper.getIcon(icon)
                        .then(data => {
                            if (data && data.svgString) {
                                // Watch source SVG string
                                scope.svgString = data.svgString;
                            }
                        });
                }
            }

        };

        return directive;
    }

    angular.module("umbraco.directives").directive("umbIcon", UmbIconDirective);

})();

----
umbminilistview.directive.js
(function () {
    'use strict';

    function MiniListViewDirective(entityResource, iconHelper) {

        function link(scope, el, attr, ctrl) {

            scope.search = "";
            scope.miniListViews = [];
            scope.breadcrumb = [];
            scope.listViewAnimation = "";

            var miniListViewsHistory = [];

            function onInit() {
                open(scope.node);
            }

            function open(node) {

                // convert legacy icon for node
                if(node && node.icon) {
                    node.icon = iconHelper.convertFromLegacyIcon(node.icon);
                }

                var miniListView = {
                    node: node,
                    loading: true,
                    pagination: {
                        pageSize: 10,
                        pageNumber: 1,
                        filter: '',
                        orderDirection: "Ascending",
                        orderBy: "SortOrder",
                        orderBySystemField: true
                    }
                };

                // clear and push mini list view in dom so we only render 1 view
                scope.miniListViews = [];
                scope.listViewAnimation = "in";
                scope.miniListViews.push(miniListView);

                // store in history so we quickly can navigate back
                miniListViewsHistory.push(miniListView);

                // get children
                getChildrenForMiniListView(miniListView);

                makeBreadcrumb();

            }

            function getChildrenForMiniListView(miniListView) {

                // start loading animation list view
                miniListView.loading = true;
                
                entityResource.getPagedChildren(miniListView.node.id, scope.entityType, miniListView.pagination)
                    .then(function (data) {
                        if (!data.items) {
                            data.items = [];
                        }
                        if (scope.onItemsLoaded) {
                            scope.onItemsLoaded({items: data.items});
                        }
                        // update children
                        miniListView.children = data.items;
                        miniListView.children.forEach(c => {
                            // child allowed by default
                            c.allowed = true;
 
                            // convert legacy icon for node
                            if(c.icon) {
                                c.icon = iconHelper.convertFromLegacyIcon(c.icon);
                            }
                            // set published state for content
                            if (c.metaData) {
                                c.hasChildren = c.metaData.hasChildren;
                                if(scope.entityType === "Document") {
                                    c.published = c.metaData.IsPublished;
                                }
                            }
                             
                            // filter items if there is a filter and it's not advanced (advanced filtering is handled below)
                            if (scope.entityTypeFilter && scope.entityTypeFilter.filter && !scope.entityTypeFilter.filterAdvanced) {
                                var a = scope.entityTypeFilter.filter.toLowerCase().replace(/\s/g, '').split(',');
                                var found = a.indexOf(c.metaData.ContentTypeAlias.toLowerCase()) >= 0;
                                
                                if (!scope.entityTypeFilter.filterExclude && !found || scope.entityTypeFilter.filterExclude && found) {
                                    c.allowed = false;
                                }
                            }
                        });

                        // advanced item filtering is handled here
                        if (scope.entityTypeFilter && scope.entityTypeFilter.filter && scope.entityTypeFilter.filterAdvanced) {
                            var filtered = Utilities.isFunction(scope.entityTypeFilter.filter)
                                ? _.filter(miniListView.children, scope.entityTypeFilter.filter)
                                : _.where(miniListView.children, scope.entityTypeFilter.filter);
                            
                            filtered.forEach(node => node.allowed = false);
                        }

                        // update pagination
                        miniListView.pagination.totalItems = data.totalItems;
                        miniListView.pagination.totalPages = data.totalPages;
                        // stop load indicator
                        miniListView.loading = false;
                    });
            }

            scope.openNode = function(event, node) {
			    open(node);
                event.stopPropagation();
            };

            scope.selectNode = function(node) {
                if (scope.onSelect && node.allowed) {
                    scope.onSelect({'node': node});
                }
            };

            /* Pagination */
            scope.goToPage = function(pageNumber, miniListView) {
                // set new page number
                miniListView.pagination.pageNumber = pageNumber;
                // get children
                getChildrenForMiniListView(miniListView);
            };

            /* Breadcrumb */
            scope.clickBreadcrumb = function(ancestor) {

                var found = false;
                scope.listViewAnimation = "out";

                Utilities.forEach(miniListViewsHistory, (historyItem, index) => {
                    // We need to make sure we can compare the two id's. 
                    // Some id's are integers and others are strings.
                    // Members have string ids like "all-members".
                    if (historyItem.node.id.toString() === ancestor.id.toString()) {
                        // load the list view from history
                        scope.miniListViews = [];
                        scope.miniListViews.push(historyItem);
                        // clean up history - remove all children after
                        miniListViewsHistory.splice(index + 1, miniListViewsHistory.length);
                        found = true;
                    }
                });

                if (!found) {
                    // if we can't find the view in the history - close the list view
                    scope.exitMiniListView();
                }

                // update the breadcrumb
                makeBreadcrumb();

            };

            scope.showBackButton = function() {
                // don't show the back button if the start node is a list view
                if (scope.node.metaData && scope.node.metaData.IsContainer || scope.node.isContainer) {
                    return false;
                } else {
                    return true;
                }
            };

            scope.exitMiniListView = function() {
                miniListViewsHistory = [];
                scope.miniListViews = [];
                if(scope.onClose) {
                    scope.onClose();
                }
            };

            function makeBreadcrumb() {
                scope.breadcrumb = [];
                Utilities.forEach(miniListViewsHistory, historyItem => {
                    scope.breadcrumb.push(historyItem.node);
                });
            }

            /* Search */
            scope.searchMiniListView = function(search, miniListView) {
                // set search value
                miniListView.pagination.filter = search;
                // reset pagination
                miniListView.pagination.pageNumber = 1;
                // start loading animation list view
                miniListView.loading = true;
                searchMiniListView(miniListView);
            };

            var searchMiniListView = _.debounce(function (miniListView) {
                scope.$apply(function () {
                    getChildrenForMiniListView(miniListView);
                });
            }, 500);

            onInit();

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-mini-list-view.html',
            scope: {
                node: "=",
                entityType: "@",
                startNodeId: "=",
                onSelect: "&",
                onClose: "&",
                onItemsLoaded: "&",
                entityTypeFilter: "="
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbMiniListView', MiniListViewDirective);

})();

----
umbstickybar.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbStickyBar
@restrict A

@description
Use this directive make an element sticky and follow the page when scrolling. `umb-sticky-bar--active` class is applied when the element is stuck

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <div
           class="my-sticky-bar"
           umb-sticky-bar>
        </div>

    </div>
</pre>

**/

(function () {
    'use strict';

    function StickyBarDirective() {

        let headerObserver;

        /**
        Toggle `umb-sticky-bar--active` class on the sticky-bar element
        **/
        const setClass = (addClass, current) => current.classList.toggle('umb-sticky-bar--active', addClass);

        /**
        Inserts two elements in the umbStickyBar parent element
        These are used by the IntersectionObserve to calculate scroll position
        **/
        const addSentinel = current => {
          if (current.parentElement.querySelector(".umb-sticky-sentinel") === null) {
            const sentinel = document.createElement("div");
            sentinel.classList.add("umb-sticky-sentinel", "-top");
            current.parentElement.prepend(sentinel);
          }
        };

        /**
        Calls into setClass when the header sentinel enters/exits the top of the container
        Container is the parent element of the umbStickyBar element
        **/
        const observeHeader = (current, container) => {
            headerObserver = new IntersectionObserver((records, observer) => {
                let [target, rootBounds] = [records[0].boundingClientRect, records[0].rootBounds];

                if (rootBounds && target) {
                    if (target.bottom < rootBounds.top) {
                        setClass(true, current);
                    }

                    if (target.bottom >= rootBounds.top && target.bottom < rootBounds.bottom) {
                        setClass(false, current);
                    }
                }
            }, {
                threshold: [0],
                root: container
            });

            headerObserver.observe(current.parentElement.querySelector('.umb-sticky-sentinel.-top'));
        };

        function link(scope, el, attr, ctrl) {

            let current = el[0];
            let container = current.closest('.umb-editor-container') || current.closest('.umb-dashboard');

            if (container) {
                addSentinel(current);
                observeHeader(current, container);
            }

            scope.$on('$destroy', () => {
                headerObserver.disconnect();
            });
        }

        const directive = {
            restrict: 'A',
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbStickyBar', StickyBarDirective);

})();

----
umbcolorswatches.directive.js
﻿/**
@ngdoc directive
@name umbraco.directives.directive:umbColorSwatches
@restrict E
@scope
@description
Use this directive to generate color swatches to pick from.
<h3>Markup example</h3>
<pre>
    <umb-color-swatches
        colors="colors"
        selected-color="color"
        size="s">
    </umb-color-swatches>
</pre>
@param {array} colors (<code>attribute</code>): The array of colors.
@param {string} selectedColor (<code>attribute</code>): The selected color.
@param {string} size (<code>attribute</code>): The size (s, m).
@param {string} useLabel (<code>attribute</code>): Specify if labels should be used.
@param {string} useColorClass (<code>attribute</code>): Specify if color values are css classes.
@param {string} colorClassNamePrefix (<code>attribute</code>): Specify the prefix used for the class for each color (defaults to "btn").
@param {function} onSelect (<code>expression</code>): Callback function when the item is selected.
**/

(function () {
    'use strict';

    function ColorSwatchesDirective() {

        function link(scope, el, attrs, ctrl) {

            // Set default to true if not defined
            if (Utilities.isUndefined(scope.useColorClass)) {
                scope.useColorClass = false;
            }

            // Set default to "btn" if not defined
            if (Utilities.isUndefined(scope.colorClassNamePrefix)) {
                scope.colorClassNamePrefix = "btn";
            }

            scope.setColor = function (color, $index, $event) {
                if (scope.readonly) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    return;
                }

                if (scope.onSelect) {
                    // did the value change?
                    if (scope.selectedColor != null && scope.selectedColor.value === color.value) {
                        // User clicked the currently selected color
                        // to remove the selection, they don't want
                        // to select any color after all.
                        // Unselect the color
                        color = null;
                    }

                    scope.selectedColor = color;
                    scope.onSelect({color: color, $index: $index, $event: $event});
                    $event.stopPropagation();
                }
            };

            scope.isSelectedColor = function (color) {
                return scope.selectedColor && color.value === scope.selectedColor.value;
            }

            attrs.$observe('readonly', (value) => {
                scope.readonly = value !== undefined;
            });
        }

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/umb-color-swatches.html',
            scope: {
                colors: '=?',
                size: '@',
                selectedColor: '=',
                onSelect: '&',
                useLabel: '=',
                useColorClass: '=?',
                colorClassNamePrefix: '@?'
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbColorSwatches', ColorSwatchesDirective);

})();

----
umbgroupsbuilder.directive.js
(function () {
    'use strict';

  function GroupsBuilderDirective(contentTypeHelper, contentTypeResource, mediaTypeResource, memberTypeResource,
        $filter, iconHelper, $q, $timeout, notificationsService,
        localizationService, editorService, eventsService, overlayService) {

        function link(scope, element) {

            const TYPE_GROUP = contentTypeHelper.TYPE_GROUP;
            const TYPE_TAB = contentTypeHelper.TYPE_TAB;

            var eventBindings = [];
            var validationTranslated = "";
            var tabNoSortOrderTranslated = "";

            scope.dataTypeHasChanged = false;
            scope.sortingMode = false;
            scope.toolbar = [];
            scope.sortingButtonKey = "general_reorder";
            scope.compositionsButtonState = "init";
            scope.tabs = [];
            scope.genericGroups = [];
            scope.openTabAlias = null;
            scope.hasGenericTab = false;
            scope.genericTab = {
                key: String.CreateGuid(),
                type: TYPE_TAB,
                name: "Generic",
                alias: null,
                parentAlias: null,
                sortOrder: 0,
                properties: []
            };

            let tabsInitialized = false;

            eventBindings.push(scope.$watchCollection('model.groups', (newValue, oldValue) => {
                // we only want to run this logic when new groups are added or removed
                if (newValue.length === oldValue.length && tabsInitialized) {
                    tabsInitialized = true;
                    return;
                }

                contentTypeHelper.defineParentAliasOnGroups(newValue);
                contentTypeHelper.relocateDisorientedGroups(newValue);

                scope.tabs = $filter("filter")(newValue, group => {
                    return group.type === TYPE_TAB && group.parentAlias == null;
                });

                // order tabs
                scope.orderTabs();

                // set server validation index
                // the server filters out inherited groups if they don't have any local properties when returning the group index
                const noInherited = newValue.filter(group => !group.inherited || (group.inherited && group.properties.filter(property => !property.inherited).length > 0));

                noInherited.forEach((group, index) => {
                    group.serverValidationIndex = !group.inherited ? index : undefined;
                });

                checkGenericTabVisibility();

                if (!scope.openTabAlias && scope.hasGenericTab) {
                    scope.openTabAlias = null;
                } else if (!scope.openTabAlias && scope.tabs.length > 0) {
                    scope.openTabAlias = scope.tabs[0].alias;
                }

                tabsInitialized = true;
            }));

            function activate() {
                setSortingOptions();

                // localize texts
                localizationService.localizeMany([
                    "validation_validation",
                    "contentTypeEditor_tabHasNoSortOrder",
                    "general_generic",
                    "contentTypeEditor_tabDirectPropertiesDropZone"
                ]).then(data => {
                    validationTranslated = data[0];
                    tabNoSortOrderTranslated = data[1];
                    scope.genericTab.name = data[2];
                    scope.tabDirectPropertiesDropZoneLabel = data[3];
                });
            }

            function setSortingOptions() {

                const defaultOptions = {
                    axis: '',
                    tolerance: "pointer",
                    opacity: 0.7,
                    scroll: true,
                    cursor: "move",
                    zIndex: 6000,
                    forcePlaceholderSize: true,
                    dropOnEmpty: true,
                    helper: "clone",
                    appendTo: "body"
                };

                scope.sortableOptionsTab = {
                    ...defaultOptions,
                    connectWith: ".umb-group-builder__tabs",
                    placeholder: "umb-group-builder__tab-sortable-placeholder",
                    handle: ".umb-group-builder__tab-handle",
                    items: ".umb-group-builder__tab-sortable",
                    stop: (event, ui) => {
                        const tabKey = ui.item[0].dataset.tabKey ? ui.item[0].dataset.tabKey : false;
                        const dropIndex = scope.tabs.findIndex(tab => tab.key === tabKey);
                        updateSortOrder(scope.tabs, dropIndex);
                    }
                };

                scope.sortableOptionsGroup = {
                    ...defaultOptions,
                    connectWith: ".umb-group-builder__groups",
                    placeholder: "umb-group-builder__group-sortable-placeholder",
                    handle: ".umb-group-builder__group-handle",
                    items: ".umb-group-builder__group-sortable",
                    stop: (e, ui) => {
                        const groupKey = ui.item[0].dataset.groupKey ? ui.item[0].dataset.groupKey : false;
                        const group = groupKey ? scope.model.groups.find(group => group.key === groupKey) : {};

                        // the code also runs when you convert a group to a tab.
                        // We want to make sure it only run when groups are reordered
                        if (group && group.type === TYPE_GROUP) {

                            // Update aliases
                            const parentAlias = scope.openTabAlias;
                            const oldAlias = group.alias || null; // null when group comes from root aka. 'generic'
                            const newAlias = contentTypeHelper.updateParentAlias(oldAlias, parentAlias);

                            group.alias = newAlias;
                            group.parentAlias = parentAlias;
                            contentTypeHelper.updateDescendingAliases(scope.model.groups, oldAlias, newAlias);

                            const groupsInTab = scope.model.groups.filter(group => group.parentAlias === parentAlias);
                            const dropIndex = groupsInTab.findIndex(group => group.key === groupKey);

                            updateSortOrder(groupsInTab, dropIndex);

                            // when a group is dropped we need to reset the requested tab hover alias
                            scope.sortableRequestedTabAlias = undefined;
                        }
                    }
                };

                scope.sortableOptionsProperty = {
                    ...defaultOptions,
                    connectWith: ".umb-group-builder__properties",
                    placeholder: "umb-group-builder__property_sortable-placeholder",
                    handle: ".umb-group-builder__property-handle",
                    items: ".umb-group-builder__property-sortable",
                    stop: (e, ui) => {
                        updatePropertiesSortOrder();

                        // when a property is dropped we need to reset the requested tab hover alias
                        scope.sortableRequestedTabAlias = undefined;
                    }
                };

                scope.droppableOptionsConvert = {
                    accept: '.umb-group-builder__group-sortable',
                    tolerance : 'pointer',
                    drop: (evt, ui) => {
                        const groupKey = ui.draggable[0].dataset.groupKey ? ui.draggable[0].dataset.groupKey : false;
                        const group = groupKey ? scope.model.groups.find(group => group.key === groupKey) : {};

                        if (group) {
                            contentTypeHelper.convertGroupToTab(scope.model.groups, group);

                            scope.tabs.push(group);
                            scope.$broadcast('umbOverflowChecker.checkOverflow');
                            scope.$broadcast('umbOverflowChecker.scrollTo', { position: 'end' });
                        }
                    }
                };

                scope.sortableRequestedTabAlias = undefined;//set to undefined as null is the generic group.
                scope.sortableRequestedTabTimeout = null;
                scope.droppableOptionsTab = {
                    accept: '.umb-group-builder__property-sortable, .umb-group-builder__group-sortable',
                    tolerance : 'pointer',
                    over: (evt, ui) => {
                        const hoveredTabAlias = evt.target.dataset.tabAlias === "" ? null : evt.target.dataset.tabAlias;

                        // if dragging a group
                        if (ui.draggable[0].dataset.groupKey) {

                            const groupKey = ui.draggable[0].dataset.groupKey ? ui.draggable[0].dataset.groupKey : false;
                            const group = groupKey ? scope.model.groups.find(group => group.key === groupKey) : {};

                            const newAlias = contentTypeHelper.updateParentAlias(group.alias || null, hoveredTabAlias);
                            // Check alias is unique
                            if (group.alias !== newAlias && contentTypeHelper.isAliasUnique(scope.model.groups, newAlias) === false) {
                                localizationService.localize("contentTypeEditor_groupReorderSameAliasError",  [group.name, newAlias]).then((value) => {
                                    notificationsService.error(value);
                                });
                                return;
                            }
                        }

                        if(scope.sortableRequestedTabAlias !== hoveredTabAlias) {
                            if(scope.sortableRequestedTabTimeout !== null) {
                                $timeout.cancel(scope.sortableRequestedTabTimeout);
                                scope.sortableRequestedTabTimeout = null;
                                scope.sortableRequestedTabAlias = undefined;
                            }
                            scope.sortableRequestedTabAlias = hoveredTabAlias;
                            scope.sortableRequestedTabTimeout = $timeout(() => {
                                scope.openTabAlias = scope.sortableRequestedTabAlias;
                                scope.sortableRequestedTabTimeout = null;
                                /* hack to update sortable positions when switching from one tab to another.
                                without this sorting direct properties doesn't work correctly */
                                scope.$apply();
                                $('.umb-group-builder__ungrouped-properties .umb-group-builder__properties').sortable('refresh');
                                $('.umb-group-builder__groups').sortable('refresh');
                            }, 400);
                        }
                    },
                    out: (evt, ui) => {
                        const hoveredTabAlias = evt.target.dataset.tabAlias === "" ? null : evt.target.dataset.tabAlias;
                        if(scope.sortableRequestedTabTimeout !== null && (hoveredTabAlias === undefined || scope.sortableRequestedTabAlias === hoveredTabAlias)) {
                            $timeout.cancel(scope.sortableRequestedTabTimeout);
                            scope.sortableRequestedTabTimeout = null;
                            scope.sortableRequestedTabAlias = null;
                        }
                    }
                };
            }

            function updateSortOrder(items, movedIndex) {
                if (items && items.length <= 1) {
                    return;
                }

                // update the moved item sort order to fit into where it is dragged
                const movedItem = items[movedIndex];

                if (movedIndex === 0) {
                    const nextItem =  items[movedIndex + 1];
                    movedItem.sortOrder = nextItem.sortOrder - 1;
                } else {
                    const prevItem =  items[movedIndex - 1];
                    movedItem.sortOrder = prevItem.sortOrder + 1;
                }

                /* After the above two items next to each other might have the same sort order
                 to prevent this we run through the rest of the
                 items and update the sort order if they are next to each other.
                 This will make it possible to make gaps without the number being updated */
                for (let i = movedIndex; i < items.length; i++) {
                    const item = items[i];

                    if (!item.inherited && i !== 0) {
                        const prev = items[i - 1];

                        if (item.sortOrder === prev.sortOrder) {
                            item.sortOrder = item.sortOrder + 1;
                        }
                    }
                }
            }

            function filterAvailableCompositions(selectedContentType, selecting) {

                //selecting = true if the user has check the item, false if the user has unchecked the item

                var selectedContentTypeAliases = selecting ?
                    //the user has selected the item so add to the current list
                    _.union(scope.compositionsDialogModel.compositeContentTypes, [selectedContentType.alias]) :
                    //the user has unselected the item so remove from the current list
                    _.reject(scope.compositionsDialogModel.compositeContentTypes, i => {
                        return i === selectedContentType.alias;
                    });

                //get the currently assigned property type aliases - ensure we pass these to the server side filer
                var propAliasesExisting = _.filter(_.flatten(_.map(scope.model.groups, g => {
                    return _.map(g.properties, p => {
                        return p.alias;
                    });
                })), f => {
                    return f !== null && f !== undefined;
                });

                //use a different resource lookup depending on the content type type
                var resourceLookup = mediaTypeResource.getAvailableCompositeContentTypes;
                if (scope.contentType === "documentType") {
                    resourceLookup = contentTypeResource.getAvailableCompositeContentTypes;
                } else if (scope.contentType === "memberType") {
                    resourceLookup = memberTypeResource.getAvailableCompositeContentTypes;
                }

                return resourceLookup(scope.model.id, selectedContentTypeAliases, propAliasesExisting).then(filteredAvailableCompositeTypes => {
                    scope.compositionsDialogModel.availableCompositeContentTypes.forEach(current => {
                        //reset first
                        current.allowed = true;
                        //see if this list item is found in the response (allowed) list
                        var found = filteredAvailableCompositeTypes.find(f => current.contentType.alias === f.contentType.alias);

                        //allow if the item was  found in the response (allowed) list -
                        // and ensure its set to allowed if it is currently checked,
                        // DO not allow if it's a locked content type.
                        current.allowed = scope.model.lockedCompositeContentTypes.includes(current.contentType.alias) &&
                            (selectedContentTypeAliases.includes(current.contentType.alias)) || (found ? found.allowed : false);

                    });
                });
            }

            function updatePropertiesSortOrder() {
                scope.model.groups.forEach(group => group.properties = contentTypeHelper.updatePropertiesSortOrder(group.properties));
            }

            function setupAvailableContentTypesModel(result) {
                scope.compositionsDialogModel.availableCompositeContentTypes = result;
                //iterate each one and set it up
                scope.compositionsDialogModel.availableCompositeContentTypes.forEach(c => {
                    //enable it if it's part of the selected model
                    if (scope.compositionsDialogModel.compositeContentTypes.includes(c.contentType.alias)) {
                        c.allowed = true;
                    }

                    //set the inherited flags
                    c.inherited = false;
                    if (scope.model.lockedCompositeContentTypes.includes(c.contentType.alias)) {
                        c.inherited = true;
                    }
                    // convert icons for composite content types
                    iconHelper.formatContentTypeIcons([c.contentType]);
                });
            }

            /* ---------- DELETE PROMT ---------- */

            scope.togglePrompt = object => {
                object.deletePrompt = !object.deletePrompt;
            };

            scope.hidePrompt = object => {
                object.deletePrompt = false;
            };

            /* ---------- TOOLBAR ---------- */

            scope.toggleSortingMode = () => {

                if (scope.sortingMode === true) {

                    var sortOrderMissing = false;

                    for (var i = 0; i < scope.model.groups.length; i++) {
                        var group = scope.model.groups[i];
                        if (group.tabState !== "init" && group.sortOrder === undefined) {
                            sortOrderMissing = true;
                            group.showSortOrderMissing = true;
                            notificationsService.error(validationTranslated + ": " + group.name + " " + tabNoSortOrderTranslated);
                        }
                    }

                    if (!sortOrderMissing) {
                        scope.sortingMode = false;
                        scope.sortingButtonKey = "general_reorder";
                    }

                    // When exiting the reorder mode while the generic tab is empty, set the active tab to the first available one
                    if (scope.tabs.length > 0 && !scope.openTabAlias) {
                        scope.openTabAlias = scope.tabs[0].alias;
                    }

                } else {
                    scope.sortingMode = true;
                    scope.sortingButtonKey = "general_reorderDone";
                }

                checkGenericTabVisibility();
                scope.$broadcast('umbOverflowChecker.checkOverflow');
            };

            scope.openCompositionsDialog = () => {

                scope.compositionsDialogModel = {
                    contentType: scope.model,
                    compositeContentTypes: scope.model.compositeContentTypes,
                    view: "views/common/infiniteeditors/compositions/compositions.html",
                    size: "small",
                    submit: () => {
                        editorService.close();
                    },
                    close: oldModel => {
                        // reset composition changes
                        scope.model.groups = oldModel.contentType.groups;
                        scope.model.compositeContentTypes = oldModel.contentType.compositeContentTypes;

                        editorService.close();
                    },
                    selectCompositeContentType: selectedContentType => {

                        var deferred = $q.defer();

                        //first check if this is a new selection - we need to store this value here before any further digests/async
                        // because after that the scope.model.compositeContentTypes will be populated with the selected value.
                        var newSelection = scope.model.compositeContentTypes.indexOf(selectedContentType.alias) === -1;

                        if (newSelection) {
                            //merge composition with content type

                            //use a different resource lookup depending on the content type type
                            var resourceLookup = mediaTypeResource.getById;
                            if (scope.contentType === "documentType") {
                                resourceLookup = contentTypeResource.getById;
                            } else if (scope.contentType === "memberType") {
                                resourceLookup = memberTypeResource.getById;
                            }

                            resourceLookup(selectedContentType.id).then(composition => {
                                //based on the above filtering we shouldn't be able to select an invalid one, but let's be safe and
                                // double check here.
                                var overlappingAliases = contentTypeHelper.validateAddingComposition(scope.model, composition);
                                if (overlappingAliases.length > 0) {
                                    //this will create an invalid composition, need to uncheck it
                                    scope.compositionsDialogModel.compositeContentTypes.splice(
                                        scope.compositionsDialogModel.compositeContentTypes.indexOf(composition.alias), 1);
                                    //dissallow this until something else is unchecked
                                    selectedContentType.allowed = false;
                                }
                                else {
                                    contentTypeHelper.mergeCompositeContentType(scope.model, composition);
                                }

                                //based on the selection, we need to filter the available composite types list
                                filterAvailableCompositions(selectedContentType, newSelection).then(() => {
                                    deferred.resolve({ selectedContentType, newSelection });
                                            // TODO: Here we could probably re-enable selection if we previously showed a throbber or something
                                }, () => {
                                   deferred.reject();
                                });
                            });
                        }
                        else {
                            // split composition from content type
                            contentTypeHelper.splitCompositeContentType(scope.model, selectedContentType);

                            //based on the selection, we need to filter the available composite types list
                            filterAvailableCompositions(selectedContentType, newSelection).then(() => {
                                deferred.resolve({ selectedContentType, newSelection });
                                // TODO: Here we could probably re-enable selection if we previously showed a throbber or something
                            }, () => {
                                deferred.reject();
                            });
                        }

                        return deferred.promise;
                    }
                };

                var availableContentTypeResource = mediaTypeResource.getAvailableCompositeContentTypes;
                var whereUsedContentTypeResource = mediaTypeResource.getWhereCompositionIsUsedInContentTypes;
                var countContentTypeResource = mediaTypeResource.getCount;

                if (scope.contentType === "documentType") {
                    availableContentTypeResource = contentTypeResource.getAvailableCompositeContentTypes;
                    whereUsedContentTypeResource = contentTypeResource.getWhereCompositionIsUsedInContentTypes;
                    countContentTypeResource = contentTypeResource.getCount;
                } else if (scope.contentType === "memberType") {
                    availableContentTypeResource = memberTypeResource.getAvailableCompositeContentTypes;
                    whereUsedContentTypeResource = memberTypeResource.getWhereCompositionIsUsedInContentTypes;
                    countContentTypeResource = memberTypeResource.getCount;
                }

                //get the currently assigned property type aliases - ensure we pass these to the server side filer
                var propAliasesExisting = _.filter(_.flatten(_.map(scope.model.groups, g => {
                    return _.map(g.properties, p => {
                        return p.alias;
                    });
                })), f => {
                    return f !== null && f !== undefined;
                });
                scope.compositionsButtonState = "busy";
                $q.all([
                    //get available composite types
                    availableContentTypeResource(scope.model.id, [], propAliasesExisting, scope.model.isElement).then(result => {
                        setupAvailableContentTypesModel(result);
                    }),
                    //get where used document types
                    whereUsedContentTypeResource(scope.model.id).then(whereUsed => {
                        //pass to the dialog model the content type eg documentType or mediaType
                        scope.compositionsDialogModel.section = scope.contentType;
                        //pass the list of 'where used' document types
                        scope.compositionsDialogModel.whereCompositionUsed = whereUsed;
                    }),
                    //get content type count
                    countContentTypeResource().then(result => {
                        scope.compositionsDialogModel.totalContentTypes = parseInt(result, 10);
                    })
                ]).then(() => {
                    //resolves when both other promises are done, now show it
                    editorService.open(scope.compositionsDialogModel);
                    scope.compositionsButtonState = "init";
                });

            };

            scope.openContentType = (contentTypeId) => {
                const editor = {
                    id: contentTypeId,
                    submit: () => {
                        const args = { node: scope.model };
                        eventsService.emit("editors.documentType.reload", args);
                        editorService.close();
                    },
                    close: () => {
                        editorService.close();
                    }
                };
                editorService.documentTypeEditor(editor);

            };

            /* ---------- TABS ---------- */
            scope.changeTab = ({ alias }) => {
                scope.openTabAlias = alias;
            };

            scope.addTab = () => {
                const newTabIndex = scope.tabs.length;
                const lastTab = scope.tabs[newTabIndex - 1];
                const sortOrder = lastTab && lastTab.sortOrder !== undefined ? lastTab.sortOrder + 1 : 0;

                const key = String.CreateGuid();
                const tab = {
                    key: key,
                    type: TYPE_TAB,
                    name: '',
                    alias: key, // Temporarily set alias to key, because the name is empty
                    parentAlias: null,
                    sortOrder,
                    properties: []
                };

                if (newTabIndex === 0 && scope.hasGenericTab === false) {
                    scope.model.groups.forEach(group => {
                        if (!group.inherited && group.parentAlias == null) {
                            group.parentAlias = tab.alias;
                            group.alias = contentTypeHelper.updateParentAlias(group.alias, group.parentAlias);
                        }
                    });
                }

                scope.model.groups = [...scope.model.groups, tab];

                scope.openTabAlias = tab.alias;

                notifyChanged();

                scope.$broadcast('umbOverflowChecker.checkOverflow');
                scope.$broadcast('umbOverflowChecker.scrollTo', { position: 'end' });
            };

            scope.removeTab = (tab, indexInTabs) => {
                const tabName = tab.name || "";

                const localizeMany = localizationService.localizeMany(['general_delete', 'contentTypeEditor_confirmDeleteTabNotice']);
                const localize =  localizationService.localize('contentTypeEditor_confirmDeleteTabMessage',  [tabName]);

                $q.all([localizeMany, localize]).then(values => {
                    const translations = values[0];
                    const message = values[1];

                    overlayService.confirmDelete({
                        title: `${translations[0]} ${tabName}`,
                        content: message,
                        confirmMessage: translations[1],
                        submitButtonLabelKey: 'actions_delete',
                        submit: () => {
                            const indexInGroups = scope.model.groups.findIndex(group => group.alias === tab.alias);
                            scope.model.groups.splice(indexInGroups, 1);

                            // remove all child groups
                            scope.model.groups = scope.model.groups.filter(group => group.parentAlias !== tab.alias);

                            // we need a timeout because the filter hasn't updated the tabs collection
                            $timeout(() => {
                                if (scope.tabs.length > 0) {
                                    scope.openTabAlias = indexInTabs > 0 ? scope.tabs[indexInTabs - 1].alias : scope.tabs[0].alias;
                                } else {
                                    scope.openTabAlias = null;
                                }
                            });

                            scope.$broadcast('umbOverflowChecker.checkOverflow');

                            notifyChanged();

                            overlayService.close();
                        }
                    });
                });
            };

            scope.canRemoveTab = (tab) => {
                return scope.canRemoveGroup(tab) && _.every(scope.model.groups.filter(group => group.parentAlias === tab.alias), group => scope.canRemoveGroup(group));
            };

            scope.setTabOverflowState = (overflowLeft, overflowRight) => {
                scope.overflow = { left: overflowLeft, right: overflowRight };
            };

            scope.moveTabsOverflowLeft = () => {
                //TODO: optimize this...
                const el = element[0].querySelector(".umb-group-builder__tabs-list");
                el.scrollLeft -= el.clientWidth * 0.5;
            }
            scope.moveTabsOverflowRight = () => {
                //TODO: optimize this...
                const el = element[0].querySelector(".umb-group-builder__tabs-list");
                el.scrollLeft += el.clientWidth * 0.5;
            }

            scope.orderTabs = () => {
                scope.tabs = $filter('orderBy')(scope.tabs, 'sortOrder');
            };

            scope.onChangeTabName = tab => {
                if (updateGroupAlias(tab)) {
                    scope.openTabAlias = tab.alias;
                    scope.$broadcast('umbOverflowChecker.checkOverflow');
                }
            };

            /** Universal method for updating group alias (for tabs, field-sets etc.) */
            function updateGroupAlias(group) {
                const localAlias = contentTypeHelper.generateLocalAlias(group.name),
                    oldAlias = group.alias;
                let newAlias = contentTypeHelper.updateLocalAlias(oldAlias, localAlias);

                // Ensure unique alias, otherwise we would be transforming groups of other parents, we do not want this.
                if(contentTypeHelper.isAliasUnique(scope.model.groups, newAlias) === false) {
                    newAlias = contentTypeHelper.createUniqueAlias(scope.model.groups, newAlias);
                }

                group.alias = newAlias;
                group.parentAlias = contentTypeHelper.getParentAlias(newAlias);
                contentTypeHelper.updateDescendingAliases(scope.model.groups, oldAlias, newAlias);
                return true;
            }

            scope.isUngroupedPropertiesVisible = ({alias, properties}) => {
                const isOpenTab = alias === scope.openTabAlias;

                if (isOpenTab && properties.length > 0) {
                    return true;
                }

                if (isOpenTab && scope.sortingMode) {
                    return true;
                }

                const tabHasGroups = scope.model.groups.filter(group => group.parentAlias === alias).length > 0;

                if (isOpenTab && !tabHasGroups) {
                    return true;
                }
            };

            function checkGenericTabVisibility () {
                const hasRootGroups = scope.model.groups.filter(group => group.type === TYPE_GROUP && group.parentAlias === null).length > 0;
                scope.hasGenericTab = (hasRootGroups && scope.tabs.length > 0) || scope.sortingMode;
            }

            /* Properties */

            scope.addNewProperty = group => {
                let newProperty = {
                    label: null,
                    alias: null,
                    propertyState: "init",
                    validation: {
                        mandatory: false,
                        mandatoryMessage: null,
                        pattern: null,
                        patternMessage: null
                    },
                    labelOnTop: false
                };

                const propertySettings = {
                    title: "Property settings",
                    property: newProperty,
                    contentType: scope.contentType,
                    contentTypeName: scope.model.name,
                    contentTypeAllowCultureVariant: scope.model.allowCultureVariant,
                    contentTypeAllowSegmentVariant: scope.model.allowSegmentVariant,
                    view: "views/common/infiniteeditors/propertysettings/propertysettings.html",
                    size: "small",
                    submit: model => {
                        newProperty = {...model.property};
                        newProperty.propertyState = "active";

                        group.properties.push(newProperty);

                        editorService.close();
                    },
                    close: () => {
                        editorService.close();
                    }
                };

                editorService.open(propertySettings);
            };

            /* ---------- GROUPS ---------- */

            scope.addGroup = tabAlias => {
                scope.model.groups = scope.model.groups || [];

                const groupsInTab = scope.model.groups.filter(group => group.parentAlias === tabAlias);
                const lastGroupSortOrder = groupsInTab.length > 0 ? groupsInTab[groupsInTab.length - 1].sortOrder + 1 : 0;

                const key = String.CreateGuid();
                const group = {
                    key: key,
                    type: TYPE_GROUP,
                    name: '',
                    alias: contentTypeHelper.updateParentAlias(key, tabAlias), // Temporarily set alias to key, because the name is empty
                    parentAlias: tabAlias || null,
                    sortOrder: lastGroupSortOrder,
                    properties: [],
                    parentTabContentTypes: [],
                    parentTabContentTypeNames: []
                };

                scope.model.groups = [...scope.model.groups, group];

                scope.activateGroup(group);

                notifyChanged();
            };

            scope.activateGroup = selectedGroup => {
                if (!selectedGroup) {
                    return;
                }

                // set all other groups that are inactive to active
                scope.model.groups.forEach(group => {
                    // skip init tab
                    if (group.tabState !== "init") {
                        group.tabState = "inActive";
                    }
                });

                selectedGroup.tabState = "active";
            };

            scope.onChangeGroupName = group => {
                updateGroupAlias(group);
            }

            scope.canRemoveGroup = group => {
                return group.inherited !== true && _.find(group.properties, property => property.locked === true) == null;
            };

            scope.removeGroup = (selectedGroup) => {
                const groupName = selectedGroup.name || "";

                const localizeMany = localizationService.localizeMany(['general_delete', 'contentTypeEditor_confirmDeleteGroupNotice']);
                const localize =  localizationService.localize('contentTypeEditor_confirmDeleteGroupMessage',  [groupName]);

                $q.all([localizeMany, localize]).then(values => {
                    const translations = values[0];
                    const message = values[1];

                    overlayService.confirmDelete({
                        title: `${translations[0]} ${groupName}`,
                        content: message,
                        confirmMessage: translations[1],
                        submitButtonLabelKey: 'actions_delete',
                        submit: () => {
                            const index = scope.model.groups.findIndex(group => group.alias === selectedGroup.alias);
                            scope.model.groups.splice(index, 1);

                            overlayService.close();
                            notifyChanged();
                        }
                    });
                });
            };

            scope.addGroupToActiveTab = () => {
                scope.addGroup(scope.openTabAlias);
            };

            scope.changeSortOrderValue = group => {

                if (group.sortOrder !== undefined) {
                    group.showSortOrderMissing = false;
                }

                scope.model.groups = $filter('orderBy')(scope.model.groups, 'sortOrder');
            };

            scope.onChangeGroupSortOrderValue = sortedGroup => {
                const groupsInTab = scope.model.groups.filter(group => group.parentAlias === sortedGroup.parentAlias);
                const otherGroups = scope.model.groups.filter(group => group.parentAlias !== sortedGroup.parentAlias);
                const sortedGroups = $filter('orderBy')(groupsInTab, 'sortOrder');
                scope.model.groups = [...otherGroups, ...sortedGroups];
            };

            /* ---------- PROPERTIES ---------- */
            scope.addPropertyToActiveGroup = () => {
                let activeGroup = scope.model.groups.find(group => group.tabState === "active");

                if (!activeGroup && scope.model.groups.length) {
                    activeGroup = scope.model.groups[0];
                }

                scope.addNewProperty(activeGroup);
            };

            scope.addProperty = (property, group) => {

                // set property sort order
                var index = group.properties.indexOf(property);
                var prevProperty = group.properties[index - 1];

                if (index > 0) {
                    // set index to 1 higher than the previous property sort order
                    property.sortOrder = prevProperty.sortOrder + 1;

                } else {
                    // first property - sort order will be 0
                    property.sortOrder = 0;
                }

                // open property settings dialog
                scope.editPropertyTypeSettings(property, group);

            };

            scope.editPropertyTypeSettings = (property, group) => {

                if (!property.inherited) {

                    var oldPropertyModel = Utilities.copy(property);
                    if (oldPropertyModel.allowCultureVariant === undefined) {
                        // this is necessary for comparison when detecting changes to the property
                        oldPropertyModel.allowCultureVariant = scope.model.allowCultureVariant;
                        oldPropertyModel.alias = "";
                    }
                    var propertyModel = Utilities.copy(property);

                    var propertySettings = {
                        title: "Property settings",
                        property: propertyModel,
                        contentType: scope.contentType,
                        contentTypeName: scope.model.name,
                        contentTypeAllowCultureVariant: scope.model.allowCultureVariant,
                        contentTypeAllowSegmentVariant: scope.model.allowSegmentVariant,
                        view: "views/common/infiniteeditors/propertysettings/propertysettings.html",
                        size: "small",
                        submit: model => {

                            property.inherited = false;
                            property.dialogIsOpen = false;
                            property.propertyState = "active";

                            // apply all property changes
                            property.label = propertyModel.label;
                            property.alias = propertyModel.alias;
                            property.description = propertyModel.description;
                            property.config = propertyModel.config;
                            property.editor = propertyModel.editor;
                            property.view = propertyModel.view;
                            property.dataTypeId = propertyModel.dataTypeId;
                            property.dataTypeIcon = propertyModel.dataTypeIcon;
                            property.dataTypeName = propertyModel.dataTypeName;
                            property.validation.mandatory = propertyModel.validation.mandatory;
                            property.validation.mandatoryMessage = propertyModel.validation.mandatoryMessage;
                            property.validation.pattern = propertyModel.validation.pattern;
                            property.validation.patternMessage = propertyModel.validation.patternMessage;
                            property.showOnMemberProfile = propertyModel.showOnMemberProfile;
                            property.memberCanEdit = propertyModel.memberCanEdit;
                            property.isSensitiveData = propertyModel.isSensitiveData;
                            property.isSensitiveValue = propertyModel.isSensitiveValue;
                            property.allowCultureVariant = propertyModel.allowCultureVariant;
                            property.allowSegmentVariant = propertyModel.allowSegmentVariant;
                            property.labelOnTop = propertyModel.labelOnTop;

                            // update existing data types
                            if (model.updateSameDataTypes) {
                                updateSameDataTypes(property);
                            }

                            // close the editor
                            editorService.close();

                            if (group) {
                                // push new init property to group
                                addInitProperty(group);

                                // set focus on init property
                                var numberOfProperties = group.properties.length;
                                group.properties[numberOfProperties - 1].focus = true;
                            }

                            notifyChanged();
                        },
                        close: () => {
                            if (_.isEqual(oldPropertyModel, propertyModel) === false) {
                                localizationService.localizeMany([
                                    "general_confirm",
                                    "contentTypeEditor_propertyHasChanges",
                                    "general_cancel",
                                    "general_ok"
                                ]).then(data => {
                                    const overlay = {
                                        title: data[0],
                                        content: data[1],
                                        closeButtonLabel: data[2],
                                        submitButtonLabel: data[3],
                                        submitButtonStyle: "danger",
                                        close: () => {
                                            overlayService.close();
                                        },
                                        submit: () => {
                                            // close the confirmation
                                            overlayService.close();
                                            // close the editor
                                            editorService.close();
                                        }
                                    };

                                    overlayService.open(overlay);
                                });
                            }
                            else {
                                // remove the editor
                                editorService.close();
                            }
                        }
                    };

                    // open property settings editor
                    editorService.open(propertySettings);

                    // set property states
                    property.dialogIsOpen = true;

                }
            };

            scope.deleteProperty = (properties, property) => {
                const propertyName = property.label || "";

                const localizeMany = localizationService.localizeMany(['general_delete']);
                const localize = localizationService.localize('contentTypeEditor_confirmDeletePropertyMessage', [propertyName]);

                $q.all([localizeMany, localize]).then(values => {
                    const translations = values[0];
                    const message = values[1];

                    overlayService.confirmDelete({
                        title: `${translations[0]} ${propertyName}`,
                        content: message,
                        submitButtonLabelKey: 'actions_delete',
                        submit: () => {
                            const index = properties.findIndex(p => property.id ? p.id === property.id : p === property);
                            properties.splice(index, 1);
                            notifyChanged();

                            overlayService.close();
                        }
                    });
                });
            };

            scope.onChangePropertySortOrderValue = group => {
                group.properties = $filter('orderBy')(group.properties, 'sortOrder');
            };

            function notifyChanged() {
                eventsService.emit("editors.groupsBuilder.changed");
            }

            function addInitProperty(group) {

                var addInitPropertyBool = true;
                var initProperty = {
                    label: null,
                    alias: null,
                    propertyState: "init",
                    validation: {
                        mandatory: false,
                        mandatoryMessage: null,
                        pattern: null,
                        patternMessage: null
                    },
                    labelOnTop: false
                };

                // check if there already is an init property
                Utilities.forEach(group.properties, property => {
                    if (property.propertyState === "init") {
                        addInitPropertyBool = false;
                    }
                });

                if (addInitPropertyBool) {
                    group.properties.push(initProperty);
                }

                return group;
            }

            function updateSameDataTypes(newProperty) {

                // find each property
                Utilities.forEach(scope.model.groups, group => {
                    Utilities.forEach(group.properties, property => {

                        if (property.dataTypeId === newProperty.dataTypeId) {

                            // update property data
                            property.config = newProperty.config;
                            property.editor = newProperty.editor;
                            property.view = newProperty.view;
                            property.dataTypeId = newProperty.dataTypeId;
                            property.dataTypeIcon = newProperty.dataTypeIcon;
                            property.dataTypeName = newProperty.dataTypeName;

                        }

                    });
                });
            }

            function hasPropertyOfDataTypeId(dataTypeId) {

                // look at each property
                var result = _.filter(scope.model.groups, group => {
                    return _.filter(group.properties, property => {
                        return (property.dataTypeId === dataTypeId);
                    });
                });

                return (result.length > 0);
            }

            eventBindings.push(scope.$watch('model', (newValue, oldValue) => {
                if (newValue !== undefined && newValue.groups !== undefined) {
                    activate();
                }
            }));

            // clean up
            eventBindings.push(eventsService.on("editors.dataTypeSettings.saved", (name, args) => {
                if (hasPropertyOfDataTypeId(args.dataType.id)) {
                    scope.dataTypeHasChanged = true;
                }
            }));

            // clean up
            eventBindings.push(scope.$on('$destroy', () => {
                for (var e in eventBindings) {
                    eventBindings[e]();
                }
                // if a dataType has changed, we want to notify which properties that are affected by this dataTypeSettings change
                if (scope.dataTypeHasChanged === true) {
                    var args = { documentType: scope.model };
                    eventsService.emit("editors.documentType.saved", args);
                }
            }));

        }

        var directive = {
            restrict: "E",
            replace: true,
            templateUrl: "views/components/umb-groups-builder.html",
            scope: {
                model: "=",
                compositions: "=",
                sorting: "=",
                contentType: "@"
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbGroupsBuilder', GroupsBuilderDirective);

})();

----
umbdisableformvalidation.directive.js
(function() {
  'use strict';

  function UmbDisableFormValidation() {

      var directive = {
          restrict: 'A',
          require: '?form',
          link: function (scope, elm, attrs, ctrl) {
              //override the $setValidity function of the form to disable validation
              ctrl.$setValidity = function () { };
          }
      };

    return directive;
  }

  angular.module('umbraco.directives').directive('umbDisableFormValidation', UmbDisableFormValidation);

})();

----
umbclipboard.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbClipboard
@restrict E
@scope

@description
<strong>Added in Umbraco v. 7.7:</strong> Use this directive to copy content to the clipboard

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.ClipBoardController as vm">
        
        <!-- Copy text from an element -->
        <div id="copy-text">Copy me!</div>
        
        <umb-button
            umb-clipboard
            umb-clipboard-success="vm.copySuccess()"
            umb-clipboard-error="vm.copyError()"
            umb-clipboard-target="#copy-text"
            state="vm.clipboardButtonState"
            type="button"
            label="Copy">
        </umb-button>

        <!-- Cut text from a textarea -->
        <textarea id="cut-text" ng-model="vm.cutText"></textarea>

        <umb-button
            umb-clipboard
            umb-clipboard-success="vm.copySuccess()"
            umb-clipboard-error="vm.copyError()"
            umb-clipboard-target="#cut-text"
            umb-clipboard-action="cut"
            state="vm.clipboardButtonState"
            type="button"
            label="Copy">
        </umb-button>

        <!-- Copy text without an element -->
        <umb-button
            ng-if="vm.copyText"
            umb-clipboard
            umb-clipboard-success="vm.copySuccess()"
            umb-clipboard-error="vm.copyError()"
            umb-clipboard-text="vm.copyText"
            state="vm.clipboardButtonState"
            type="button"
            label="Copy">
        </umb-button>
    
    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;

            vm.copyText = "Copy text without element";
            vm.cutText = "Text to cut";

            vm.copySuccess = copySuccess;
            vm.copyError = copyError;

            function copySuccess() {
                vm.clipboardButtonState = "success";
            }
            
            function copyError() {
                vm.clipboardButtonState = "error";
            }

        }

        angular.module("umbraco").controller("My.ClipBoardController", Controller);

    })();
</pre>

@param {callback} umbClipboardSuccess (<code>expression</code>): Callback function when the content is copied.
@param {callback} umbClipboardError (<code>expression</code>): Callback function if the copy fails.
@param {string} umbClipboardTarget (<code>attribute</code>): The target element to copy.
@param {string} umbClipboardAction (<code>attribute</code>): Specify if you want to copy or cut content ("copy", "cut"). Cut only works on <code>input</code> and <code>textarea</code> elements.
@param {string} umbClipboardText (<code>attribute</code>): Use this attribute if you don't have an element to copy from.

**/

(function () {
    'use strict';

    function umbClipboardDirective($timeout, assetsService, $parse) {

        function link(scope, element, attrs, ctrl) {

            var clipboard;
            var target = element[0];

            assetsService.loadJs("lib/clipboard/clipboard.min.js", scope)
                .then(function () {


                    if (attrs.umbClipboardTarget) {
                        target.setAttribute("data-clipboard-target", attrs.umbClipboardTarget);
                    }

                    if (attrs.umbClipboardAction) {
                        target.setAttribute("data-clipboard-action", attrs.umbClipboardAction);
                    }

                    if (attrs.umbClipboardText) {
                        target.setAttribute("data-clipboard-text", attrs.umbClipboardText);
                    }

                    clipboard = new ClipboardJS(target);

                    var expressionHandlerSuccess = $parse(attrs.umbClipboardSuccess);
                    clipboard.on('success', function (e) {
                        e.clearSelection();
                        if (attrs.umbClipboardSuccess) {

                            expressionHandlerSuccess(scope, { msg: "success" });
                        }

                    });

                    var expressionHandlerError = $parse(attrs.umbClipboardError);
                    clipboard.on('error', function (e) {
                        if (attrs.umbClipboardError) {

                            expressionHandlerError(scope, { msg: "error" });
                        }
                    });

                });

            // clean up
            scope.$on('$destroy', function () {
                clipboard.destroy();
            });

        }

        ////////////

        var directive = {
            restrict: 'A',
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbClipboard', umbClipboardDirective);

})();

----
umblockedfield.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbLockedField
@restrict E
@scope

@description
Use this directive to render a value with a lock next to it. When the lock is clicked the value gets unlocked and can be edited.

<h3>Markup example</h3>
<pre>
	<div ng-controller="My.Controller as vm">

		<umb-locked-field
			ng-model="vm.value"
			placeholder-text="'Click to unlock...'">
		</umb-locked-field>

	</div>
</pre>

<h3>Controller example</h3>
<pre>
	(function () {
		"use strict";

		function Controller() {

			var vm = this;
			vm.value = "My locked text";

        }

		angular.module("umbraco").controller("My.Controller", Controller);

	})();
</pre>

@param {string} ngModel (<code>binding</code>): The locked text.
@param {boolean=} locked (<code>binding</code>): <Code>true</code> by default. Set to <code>false</code> to unlock the text.
@param {string=} placeholderText (<code>binding</code>): If ngModel is empty this text will be shown.
@param {string=} regexValidation (<code>binding</code>): Set a regex expression for validation of the field.
@param {string} validationPosition (<code>binding</code>): The position of the validation. Set to <code>'left'</code> or <code>'right'</code>.
@param {string=} serverValidationField (<code>attribute</code>): Set a server validation field.
**/

(function() {
	'use strict';

	function LockedFieldDirective($timeout, localizationService) {

	    function link(scope, el, attr, ngModelCtrl) {

			function activate() {

				// if locked state is not defined as an attr set default state
				if (scope.locked === undefined || scope.locked === null) {
					scope.locked = true;
				}

			    // if regex validation is not defined as an attr set default state
                // if this is set to an empty string then regex validation can be ignored.
				if (scope.regexValidation === undefined || scope.regexValidation === null) {
				    scope.regexValidation = "^[a-zA-Z]\\w.*$";
				}

				if (scope.serverValidationField === undefined || scope.serverValidationField === null) {
				    scope.serverValidationField = "";
				}

				// if locked state is not defined as an attr set default state
				if (scope.placeholderText === undefined || scope.placeholderText === null) {
					scope.placeholderText = "Enter value...";
                }

                if (scope.validationPosition === undefined || scope.validationPosition === null) {
                    scope.validationPosition = "left";
                }

			}

			scope.lock = function() {
				scope.locked = true;
			};

			scope.unlock = function() {
				scope.locked = false;
			};

			activate();

		}

		var directive = {
			require: "ngModel",
			restrict: 'E',
			replace: true,
			templateUrl: 'views/components/umb-locked-field.html',
			scope: {
			    ngModel: "=",
                locked: "=?",
				placeholderText: "=?",
                regexValidation: "=?",
                validationPosition: "=?",
				serverValidationField: "@"
			},
			link: link
		};

		return directive;

	}

	angular.module('umbraco.directives').directive('umbLockedField', LockedFieldDirective);

})();

----
umbprogresscircle.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbProgressCircle
@restrict E
@scope

@description
Use this directive to render a circular progressbar.

<h3>Markup example</h3>
<pre>
    <div>
    
        <umb-progress-circle
            percentage="80"
            size="60"
            color="secondary">
        </umb-progress-circle>

	</div>
</pre>

@param {string} percentage (<code>attribute</code>): Takes a number between 0 and 100 and applies it to the circle's highlight length.
@param {string} size (<code>attribute</code>): This parameter defines the width and the height of the circle in pixels.
@param {string} color (<code>attribute</code>): The color of the highlight (primary, secondary, success, warning, danger). Success by default. 
**/

(function (){
    'use strict';

    function ProgressCircleDirective($http, $timeout) {

        function link(scope, element, $filter) {
            
            function onInit() {
                            
                // making sure we get the right numbers
                var percent = scope.percentage;

                if (percent > 100) {
                    percent = 100;
                }
                else if (percent < 0) {
                    percent = 0;
                }

                // calculating the circle's highlight
                var circle = element.find(".umb-progress-circle__highlight");
                var r = circle.attr('r');
                var strokeDashArray = (r*Math.PI)*2;

                // Full circle length
                scope.strokeDashArray = strokeDashArray;

                var strokeDashOffsetDifference = (percent/100)*strokeDashArray;
                var strokeDashOffset = strokeDashArray - strokeDashOffsetDifference;

                // Distance for the highlight dash's offset
                scope.strokeDashOffset = strokeDashOffset;

                // set font size
                scope.percentageSize = (scope.size * 0.3) + "px";

            }

            onInit();
        }


        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-progress-circle.html',
            scope: {
                percentage: "@",
                size: "@?",
                color: "@?"
            },
            link: link

        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbProgressCircle', ProgressCircleDirective);

})();

----
umbmediagrid.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbMediaGrid
@restrict E
@scope

@description
Use this directive to generate a thumbnail grid of media items.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-media-grid
           items="vm.mediaItems"
           on-click="vm.clickItem"
           on-click-name="vm.clickItemName">
        </umb-media-grid>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;
            vm.mediaItems = [];

            vm.clickItem = clickItem;
            vm.clickItemName = clickItemName;

            myService.getMediaItems().then(function (mediaItems) {
                vm.mediaItems = mediaItems;
            });

            function clickItem(item, $event, $index){
                // do magic here
            }

            function clickItemName(item, $event, $index) {
                // set item.selected = true; to select the item
                // do magic here
            }

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {array} items (<code>binding</code>): Array of media items.
@param {callback=} onDetailsHover (<code>binding</code>): Callback method when the details icon is hovered.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>item</code>: The hovered item</li>
        <li><code>$event</code>: The hover event</li>
        <li><code>hover</code>: Boolean to tell if the item is hovered or not</li>
    </ul>
@param {callback=} onClick (<code>binding</code>): Callback method to handle click events on the media item.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>item</code>: The clicked item</li>
        <li><code>$event</code>: The click event</li>
        <li><code>$index</code>: The item index</li>
    </ul>
@param {callback=} onClickName (<code>binding</code>): Callback method to handle click events on the media item name.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>item</code>: The clicked item</li>
        <li><code>$event</code>: The click event</li>
        <li><code>$index</code>: The item index</li>
    </ul>
@param {string=} filterBy (<code>binding</code>): String to filter media items by
@param {string=} itemMaxWidth (<code>attribute</code>): Sets a max width on the media item thumbnails.
@param {string=} itemMaxHeight (<code>attribute</code>): Sets a max height on the media item thumbnails.
@param {string=} itemMinWidth (<code>attribute</code>): Sets a min width on the media item thumbnails.
@param {string=} itemMinHeight (<code>attribute</code>): Sets a min height on the media item thumbnails.

**/

(function() {
    'use strict';

    function MediaGridDirective($filter, mediaHelper) {

        function link(scope, el, attr, ctrl) {

            var itemDefaultHeight = 200;
            var itemDefaultWidth = 200;
            var itemMaxWidth = 200;
            var itemMaxHeight = 200;
            var itemMinWidth = 125;
            var itemMinHeight = 125;

            function activate() {

                if (scope.itemMaxWidth) {
                    itemMaxWidth = scope.itemMaxWidth;
                }

                if (scope.itemMaxHeight) {
                    itemMaxHeight = scope.itemMaxHeight;
                }

                if (scope.itemMinWidth) {
                    itemMinWidth = scope.itemMinWidth;
                }

                if (scope.itemMinHeight) {
                    itemMinHeight = scope.itemMinHeight;
                }

                for (var i = 0; scope.items.length > i; i++) {
                    var item = scope.items[i];
                    setItemData(item);
                    setOriginalSize(item, itemMaxHeight);

                    item.selectable = getSelectableState(item);

                    // remove non images when onlyImages is set to true
                    if (scope.onlyImages === "true" && !item.isFolder && !item.thumbnail){
                        scope.items.splice(i, 1);
                        i--;
                    }

                    // If subfolder search is not enabled remove the media items that's not needed
                    // Make sure that includeSubFolder is not undefined since the directive is used
                    // in contexts where it should not be used. Currently only used when we trigger
                    // a media picker
                    if (scope.includeSubFolders !== undefined) {
                        if (scope.includeSubFolders !== 'true') {
                            if (item.parentId !== parseInt(scope.currentFolderId)) {
                                scope.items.splice(i, 1);
                                i--;
                            }
                        }
                    }

                }

                if (scope.items.length > 0) {
                    setFlexValues(scope.items);
                }
            }

            function setItemData(item) {

                // check if item is a folder
                if (item.image) {
                    // if is has an image path, it is not a folder
                    item.isFolder = false;
                } else {
                    item.isFolder = !mediaHelper.hasFilePropertyType(item);
                }

                // if it's not a folder, get the thumbnail, extension etc. if we haven't already
                if (!item.isFolder && !item.thumbnail) {

                    // handle entity
                    if (item.image) {
                        item.thumbnail = mediaHelper.resolveFileFromEntity(item, true);
                        item.extension = mediaHelper.getFileExtension(item.image);
                    // handle full media object
                    } else {
                        item.thumbnail = mediaHelper.resolveFile(item, true);
                        item.image = mediaHelper.resolveFile(item, false);

                        var fileProp = _.find(item.properties, function (v) {
                            return (v.alias === "umbracoFile");
                        });

                        if (fileProp && fileProp.value) {
                            item.file = fileProp.value;
                        }

                        var extensionProp = _.find(item.properties, function (v) {
                            return (v.alias === "umbracoExtension");
                        });

                        if (extensionProp && extensionProp.value) {
                            item.extension = extensionProp.value;
                        }

                    }
                }
            }

            /**
            * Returns wether a item should be selectable or not.
            */
            function getSelectableState(item) {
                if (item.filtered) {
                    return false;
                }

                // check if item is a folder or image
                if (item.isFolder === true) {
                    return scope.disableFolderSelect !== "true" && scope.onlyImages !== "true";
                } else {
                    return scope.onlyFolders !== "true";
                }
            }

            function setOriginalSize(item) {

                //set to a square by default
                item.width = itemDefaultWidth;
                item.height = itemDefaultHeight;
                item.aspectRatio = 1;

                var widthProp = _.find(item.properties, function(v) {
                    return (v.alias === "umbracoWidth");
                });

                if (widthProp && widthProp.value) {
                    item.width = parseInt(widthProp.value, 10);
                    if (isNaN(item.width)) {
                        item.width = itemDefaultWidth;
                    }
                }

                var heightProp = _.find(item.properties, function(v) {
                    return (v.alias === "umbracoHeight");
                });

                if (heightProp && heightProp.value) {
                    item.height = parseInt(heightProp.value, 10);
                    if (isNaN(item.height)) {
                        item.height = itemDefaultWidth;
                    }
                }

                item.aspectRatio = item.width / item.height;

                // set max width and height
                // landscape
                if (item.aspectRatio >= 1) {
                    if (item.width > itemMaxWidth) {
                        item.width = itemMaxWidth;
                        item.height = itemMaxWidth / item.aspectRatio;
                    }
                    // portrait
                } else {
                    if (item.height > itemMaxHeight) {
                        item.height = itemMaxHeight;
                        item.width = itemMaxHeight * item.aspectRatio;
                    }
                }

            }

            function setFlexValues(mediaItems) {

                var flexSortArray = mediaItems;
                var smallestImageWidth = null;
                var widestImageAspectRatio = null;

                // sort array after image width with the widest image first
                flexSortArray = $filter('orderBy')(flexSortArray, 'width', true);

                // find widest image aspect ratio
                widestImageAspectRatio = flexSortArray[0].aspectRatio;

                // find smallest image width
                smallestImageWidth = flexSortArray[flexSortArray.length - 1].width;

                for (var i = 0; flexSortArray.length > i; i++) {

                    var mediaItem = flexSortArray[i];
                    var flex = 1 / (widestImageAspectRatio / mediaItem.aspectRatio);

                    if (flex === 0) {
                        flex = 1;
                    }

                    var imageMinFlexWidth = smallestImageWidth * flex;

                    var flexStyle = {
                        "flex": flex + " 1 " + imageMinFlexWidth + "px",
                        "max-width": mediaItem.width + "px",
                        "min-width": itemMinWidth + "px",
                        "min-height": itemMinHeight + "px"
                    };

                    mediaItem.flexStyle = flexStyle;
                }
            }

            scope.clickItem = function(item, $event, $index) {
                if (item.isFolder === true && item.filtered) {
                    scope.clickItemName(item, $event, $index);
                }
                if (scope.onClick) {
                    scope.onClick(item, $event, $index);
                    $event.stopPropagation();
                }
            };

            scope.clickItemName = function(item, $event, $index) {
                if (scope.onClickName) {
                    scope.onClickName(item, $event, $index);
                    $event.stopPropagation();
                }
            };

            scope.hoverItemDetails = function(item, $event, hover) {
                if (scope.onDetailsHover) {
                    scope.onDetailsHover(item, $event, hover);
                }
            };

            var unbindItemsWatcher = scope.$watch('items', function(newValue, oldValue) {
                if (Utilities.isArray(newValue)) {
                    activate();
                }
            });

            scope.$on('$destroy', function() {
                unbindItemsWatcher();
            });
            //determine if sort is current
            scope.sortColumn = "name";
            scope.sortReverse = false;
            scope.sortDirection = "asc";
            //check sort status
            scope.isSortDirection = function (col, direction) {
                return col === scope.sortColumn && direction === scope.sortDirection;
            };
            //change sort
            scope.setSort = function (col) {
                if (scope.sortColumn === col) {
                    scope.sortReverse = !scope.sortReverse;
                }
                else {
                    scope.sortColumn = col;
                    if (col === "updateDate") {
                        scope.sortReverse = true;
                    }
                    else {
                        scope.sortReverse = false;
                    }
                }
                scope.sortDirection = scope.sortReverse ? "desc" : "asc";

            }
            // sort function
            scope.sortBy = function (item) {
                if (scope.sortColumn === "updateDate") {
                    return [-item['isFolder'],item['updateDate']];
                }
                else {
                    return [-item['isFolder'],item['name']];
                }
            };


        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-media-grid.html',
            scope: {
                items: '=',
                onDetailsHover: "=",
                onClick: '=',
                onClickName: "=",
                allowOpenFolder: "=",
                allowOpenFile: "=",
                filterBy: "=",
                itemMaxWidth: "@",
                itemMaxHeight: "@",
                itemMinWidth: "@",
                itemMinHeight: "@",
                disableFolderSelect: "@",
                onlyImages: "@",
                onlyFolders: "@",
                includeSubFolders: "@",
                currentFolderId: "@",
                showMediaList: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbMediaGrid', MediaGridDirective);

})();

----
umbpagination.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbPagination
@restrict E
@scope

@description
Use this directive to generate a pagination.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-pagination
            page-number="vm.pagination.pageNumber"
            total-pages="vm.pagination.totalPages"
            on-next="vm.nextPage"
            on-prev="vm.prevPage"
            on-change="vm.changePage"
            on-go-to-page="vm.goToPage">
        </umb-pagination>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;

            vm.pagination = {
                pageNumber: 1,
                totalPages: 10
            };

            vm.nextPage = nextPage;
            vm.prevPage = prevPage;
            vm.changePage = changePage;
            vm.goToPage = goToPage;

            function nextPage(pageNumber) {
                // do magic here
                console.log(pageNumber);
                alert("nextpage");
            }

            function prevPage(pageNumber) {
                // do magic here
                console.log(pageNumber);
                alert("prevpage");
            }
            
            function changePage(pageNumber) {
                // do magic here
                console.log(pageNumber);
                alert("changepage");
            }

            function goToPage(pageNumber) {
                // do magic here
                console.log(pageNumber);
                alert("go to");
            }

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {number} pageNumber (<code>binding</code>): Current page number.
@param {number} totalPages (<code>binding</code>): The total number of pages.
@param {callback} onNext (<code>binding</code>): Callback method to go to the next page.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>pageNumber</code>: The page number</li>
    </ul>
@param {callback=} onPrev (<code>binding</code>): Callback method to go to the previous page.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>pageNumber</code>: The page number</li>
    </ul>
@param {callback=} onGoToPage (<code>binding</code>): Callback method to go to a specific page.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>pageNumber</code>: The page number</li>
    </ul>
@param {callback=} onChange (<code>binding</code>): Callback method when changing page.
    <h3>The callback returns:</h3>
    <ul>
        <li><code>pageNumber</code>: The page number</li>
    </ul>
**/

(function() {
   'use strict';

   function PaginationDirective(localizationService) {

      function link(scope, el, attr, ctrl) {

         function activate() {
            // page number is sometimes a string - let's make sure it's an int before we do anything with it
            if (scope.pageNumber) {
                scope.pageNumber = parseInt(scope.pageNumber);
            }

            let tempPagination = [];
             
            var i = 0;

            if (scope.totalPages <= 10) {
                for (i = 0; i < scope.totalPages; i++) {
                    tempPagination.push({
                        val: (i + 1),
                        isActive: scope.pageNumber === (i + 1)
                    });
                }
            }
            else {
                //if there is more than 10 pages, we need to do some fancy bits

                //get the max index to start
                var maxIndex = scope.totalPages - 10;
                //set the start, but it can't be below zero
                var start = Math.max(scope.pageNumber - 5, 0);
                //ensure that it's not too far either
                start = Math.min(maxIndex, start);

                for (i = start; i < (10 + start) ; i++) {
                    tempPagination.push({
                        val: (i + 1),
                        isActive: scope.pageNumber === (i + 1)
                    });
                }

                //now, if the start is greater than 0 then '1' will not be displayed, so do the elipses thing
                if (start > 0) {
                    localizationService.localize("general_first").then(function(value){
                        var firstLabel = value;
                        tempPagination.unshift({ name: firstLabel, val: 1, isActive: false }, {val: "...",isActive: false});
                    });
                }

                //same for the end
                if (start < maxIndex) {
                    localizationService.localize("general_last").then(function(value){
                        var lastLabel = value;
                        tempPagination.push({ val: "...", isActive: false }, { name: lastLabel, val: scope.totalPages, isActive: false });
                    });
                }
            }

            scope.pagination = tempPagination;
         }

         scope.next = function () {
             if (scope.pageNumber < scope.totalPages) {
                 scope.pageNumber++;
                 if (scope.onNext) {
                     scope.onNext(scope.pageNumber);
                 }
                 if (scope.onChange) {
                     scope.onChange({ "pageNumber": scope.pageNumber });
                 }
             }
         };

         scope.prev = function (pageNumber) {
             if (scope.pageNumber > 1) {
                 scope.pageNumber--;
                 if (scope.onPrev) {
                     scope.onPrev(scope.pageNumber);
                 }
                 if (scope.onChange) {
                     scope.onChange({ "pageNumber": scope.pageNumber });
                 }
             }
         };

         scope.goToPage = function (pageNumber) {
             scope.pageNumber = pageNumber + 1;
             if (scope.onGoToPage) {
                 scope.onGoToPage(scope.pageNumber);
             }
             if (scope.onChange) {
                 scope.onChange({ "pageNumber": scope.pageNumber });
             }
         };

         var unbindPageNumberWatcher =  scope.$watchCollection('[pageNumber, totalPages]', function (newValues, oldValues) {
            activate();
         });

         scope.$on('$destroy', function(){
           unbindPageNumberWatcher();
         });

         activate();

      }

      var directive = {
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/umb-pagination.html',
         scope: {
            pageNumber: "=",
            totalPages: "=",
            onNext: "=",
            onPrev: "=",
            onGoToPage: "=",
            onChange: "&"
         },
         link: link
      };

      return directive;

   }

   angular.module('umbraco.directives').directive('umbPagination', PaginationDirective);

})();

----
umbrangeslider.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbRangeSlider
@restrict E
@scope

@description
<b>Added in Umbraco version 8.0</b>
This directive is a wrapper of the noUiSlider library. Use it to render a slider.
For extra details about options and events take a look here: https://refreshless.com/nouislider/

<h3>Markup example</h3>
<pre>
	<div ng-controller="My.Controller as vm">

        <umb-range-slider
            ng-model="vm.value"
            on-end="vm.slideEnd(values)">
        </umb-range-slider>

	</div>
</pre>

<h3>Controller example</h3>
<pre>
	(function () {
		"use strict";

		function Controller() {

            var vm = this;

            vm.value = [10];

            vm.slideEnd = slideEnd;

            function slideEnd(values) {
            	// handle change
            }

        }

		angular.module("umbraco").controller("My.Controller", Controller);

	})();
</pre>

@param {object} ngModel (<code>binding</code>): Value for the slider.
@param {object} options (<code>binding</code>): Config object for the slider.
@param {callback} onSetup (<code>callback</code>): onSetup gets triggered when the slider is initialized
@param {callback} onUpdate (<code>callback</code>): onUpdate fires every time the slider values are changed.
@param {callback} onSlide (<code>callback</code>): onSlide gets triggered when the handle is being dragged.
@param {callback} onSet (<code>callback</code>): onSet will trigger every time a slider stops changing.
@param {callback} onChange (<code>callback</code>): onChange fires when a user stops sliding, or when a slider value is changed by 'tap'.
@param {callback} onDrag (<code>callback</code>): onDrag fires when a connect element between handles is being dragged, while ignoring other updates to the slider values.
@param {callback} onStart (<code>callback</code>): onStart fires when a handle is clicked (mousedown, or the equivalent touch events).
@param {callback} onEnd (<code>callback</code>): onEnd fires when a handle is released (mouseup etc), or when a slide is canceled due to other reasons.
**/


(function () {
    'use strict';

    var umbRangeSlider = {
        template: '<div class="umb-range-slider"></div>',
        controller: UmbRangeSliderController,
        bindings: {
            ngModel: '<',
            options: '<',
            onSetup: '&?',
            onUpdate: '&?',
            onSlide: '&?',
            onSet: '&?',
            onChange: '&?',
            onDrag: '&?',
            onStart: '&?',
            onEnd: '&?'
        }
    };

    function UmbRangeSliderController($element, $timeout, $scope, assetsService, $attrs) {

        const ctrl = this;
        let sliderInstance = null;

        ctrl.$onInit = function () {

            // load css file for the date picker
            assetsService.loadCss('lib/nouislider/nouislider.min.css', $scope);

            // load the js file for the date picker
            assetsService.loadJs('lib/nouislider/nouislider.min.js', $scope).then(function () {
                // init date picker
                grabElementAndRun();
            });

        };

        $attrs.$observe('readonly', (value) => {
            ctrl.readonly = value !== undefined;

            if (!sliderInstance) {
                return;
            }

            if (ctrl.readonly) {
                sliderInstance.setAttribute('disabled', true);
            } else {
                sliderInstance.removeAttribute('disabled');
            }
        });

        function grabElementAndRun() {
            $timeout(function () {
                const element = $element.find('.umb-range-slider')[0];
                setSlider(element);
            }, 0, true);
        }

        function setSlider(element) {

            sliderInstance = element;

            const defaultOptions = {
                "start": [0],
                "step": 1,
                "range": {
                    "min": [0],
                    "max": [100]
                }
            };
            const options = ctrl.options ? ctrl.options : defaultOptions;

            // create new slider
            noUiSlider.create(sliderInstance, options);

            mergeTooltips(sliderInstance, 15, ' - ');

            if (ctrl.onSetup) {
                ctrl.onSetup({
                    slider: sliderInstance
                });
            }

            // If has ngModel set the date
            if (ctrl.ngModel) {
                sliderInstance.noUiSlider.set(ctrl.ngModel);
            }

            if (ctrl.readonly) {
                sliderInstance.setAttribute('disabled', true);
            } else {
                sliderInstance.removeAttribute('disabled');
            }

            // destroy the slider instance when the dom element is removed
            $(element).on('$destroy', function () {
                sliderInstance.noUiSlider.off();
            });

            setUpCallbacks();
            setUpActivePipsHandling();
            addPipClickHandler();

            // Refresh the scope
            $scope.$applyAsync();
        }

        function setUpCallbacks() {
            if (sliderInstance) {

                // bind hook for update
                if (ctrl.onUpdate) {
                    sliderInstance.noUiSlider.on('update', function (values, handle, unencoded, tap, positions) {
                        $timeout(function () {
                            ctrl.onUpdate({ values: values, handle: handle, unencoded: unencoded, tap: tap, positions: positions });
                        });
                    });
                }

                // bind hook for slide
                if (ctrl.onSlide) {
                    sliderInstance.noUiSlider.on('slide', function (values, handle, unencoded, tap, positions) {
                        $timeout(function () {
                            ctrl.onSlide({ values: values, handle: handle, unencoded: unencoded, tap: tap, positions: positions });
                        });
                    });
                }

                // bind hook for set
                if (ctrl.onSet) {
                    sliderInstance.noUiSlider.on('set', function (values, handle, unencoded, tap, positions) {
                        $timeout(function () {
                            ctrl.onSet({ values: values, handle: handle, unencoded: unencoded, tap: tap, positions: positions });
                        });
                    });
                }

                // bind hook for change
                if (ctrl.onChange) {
                    sliderInstance.noUiSlider.on('change', function (values, handle, unencoded, tap, positions) {
                        $timeout(function () {
                            ctrl.onChange({ values: values, handle: handle, unencoded: unencoded, tap: tap, positions: positions });
                        });
                    });
                }

                // bind hook for drag
                if (ctrl.onDrag) {
                    sliderInstance.noUiSlider.on('drag', function (values, handle, unencoded, tap, positions) {
                        $timeout(function () {
                            ctrl.onDrag({ values: values, handle: handle, unencoded: unencoded, tap: tap, positions: positions });
                        });
                    });
                }

                // bind hook for start
                if (ctrl.onStart) {
                    sliderInstance.noUiSlider.on('start', function (values, handle, unencoded, tap, positions) {
                        $timeout(function () {
                            ctrl.onStart({ values: values, handle: handle, unencoded: unencoded, tap: tap, positions: positions });
                        });
                    });
                }

                // bind hook for end
                if (ctrl.onEnd) {
                    sliderInstance.noUiSlider.on('end', function (values, handle, unencoded, tap, positions) {
                        $timeout(function () {
                            ctrl.onEnd({ values: values, handle: handle, unencoded: unencoded, tap: tap, positions: positions });
                        });
                    });
                }

            }
        }

        // Merging overlapping tooltips: https://refreshless.com/nouislider/examples/#section-merging-tooltips

        /**
         * @param slider HtmlElement with an initialized slider
         * @param threshold Minimum proximity (in percentages) to merge tooltips
         * @param separator String joining tooltips
         */
        function mergeTooltips(slider, threshold, separator) {

            var textIsRtl = getComputedStyle(slider).direction === 'rtl';
            var isRtl = slider.noUiSlider.options.direction === 'rtl';
            var isVertical = slider.noUiSlider.options.orientation === 'vertical';
            var tooltips = slider.noUiSlider.getTooltips();
            var origins = slider.noUiSlider.getOrigins();
            
            // Move tooltips into the origin element. The default stylesheet handles this.
            if(tooltips && tooltips.length !== 0){
              tooltips.forEach(function (tooltip, index) {
                if (tooltip) {
                  origins[index].appendChild(tooltip);
                }
              });
            }

            slider.noUiSlider.on('update', function (values, handle, unencoded, tap, positions) {

                var pools = [[]];
                var poolPositions = [[]];
                var poolValues = [[]];
                var atPool = 0;

                // Assign the first tooltip to the first pool, if the tooltip is configured
                if (tooltips[0]) {
                    pools[0][0] = 0;
                    poolPositions[0][0] = positions[0];
                    poolValues[0][0] = values[0];
                }

                for (var i = 1; i < positions.length; i++) {
                    if (!tooltips[i] || (positions[i] - positions[i - 1]) > threshold) {
                        atPool++;
                        pools[atPool] = [];
                        poolValues[atPool] = [];
                        poolPositions[atPool] = [];
                    }

                    if (tooltips[i]) {
                        pools[atPool].push(i);
                        poolValues[atPool].push(values[i]);
                        poolPositions[atPool].push(positions[i]);
                    }
                }

                pools.forEach(function (pool, poolIndex) {
                    var handlesInPool = pool.length;

                    for (var j = 0; j < handlesInPool; j++) {
                        var handleNumber = pool[j];
                        
                        if (j === handlesInPool - 1) {
                            var offset = 0;
                            
                            poolPositions[poolIndex].forEach(function (value) {
                                offset += 1000 - value;
                            });
                            
                            var direction = isVertical ? 'bottom' : 'right';
                            var last = isRtl ? 0 : handlesInPool - 1;
                            var lastOffset = 1000 - poolPositions[poolIndex][last];
                            offset = (textIsRtl && !isVertical ? 100 : 0) + (offset / handlesInPool) - lastOffset;

                            // Filter to unique values
                            var tooltipValues = poolValues[poolIndex].filter((v, i, a) => a.indexOf(v) === i);

                            // Center this tooltip over the affected handles
                            tooltips[handleNumber].innerHTML = tooltipValues.join(separator);
                            tooltips[handleNumber].style.display = 'block';
                            tooltips[handleNumber].style[direction] = offset + '%';
                        } else {
                            // Hide this tooltip
                            tooltips[handleNumber].style.display = 'none';
                        }
                    }
                });
            });
        }
      function setUpActivePipsHandling() {
        sliderInstance.noUiSlider.on('update', function (values,handle) {
          sliderInstance.querySelectorAll('.noUi-value').forEach(pip => {
            pip.classList.remove("noUi-value-active");
            if (Number(values[handle]) === Number(pip.getAttribute('data-value'))) {
              pip.classList.add("noUi-value-active");
            }
          });
        });
      }
      function addPipClickHandler(){
          sliderInstance.querySelectorAll('.noUi-value').forEach(function(pip){
            pip.addEventListener('click', function () {
              const value = pip.getAttribute('data-value');
              sliderInstance.noUiSlider.set(value);
            });
          });
      }
    }

    angular.module('umbraco.directives').component('umbRangeSlider', umbRangeSlider);

})();

----
umbdropdownitem.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbDropdownItem
@restrict E

@description
<b>Added in versions 7.7.0</b>: Use this directive to construct a dropdown item. See documentation for {@link umbraco.directives.directive:umbDropdown umbDropdown}.

**/

(function() {
    'use strict';

    function umbDropdownItem() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/umb-dropdown-item.html'
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbDropdownItem', umbDropdownItem);

})();

----
umbgridselector.directive.js
(function () {
    'use strict';

    function GridSelector(overlayService, editorService) {

        function link(scope) {

            var eventBindings = [];
            scope.dialogModel = {};
            scope.showDialog = false;
            scope.itemLabel = "";

            // set default item name
            if (!scope.itemName) {
                scope.itemLabel = "item";
            } else {
                scope.itemLabel = scope.itemName;
            }

            scope.removeItem = function (selectedItem) {
                var selectedItemIndex = scope.selectedItems.indexOf(selectedItem);
                scope.selectedItems.splice(selectedItemIndex, 1);
            };

            scope.removeDefaultItem = function () {

                // it will be the last item so we can clear the array
                scope.selectedItems = [];

                // remove as default item
                scope.defaultItem = null;

            };

            scope.openItemPicker = function ($event) {
                if (scope.itemPicker) {
                    scope.itemPicker();
                } else {
                    var dialogModel = {
                        view: "itempicker",
                        title: "Choose " + scope.itemLabel,
                        availableItems: scope.availableItems,
                        selectedItems: scope.selectedItems,
                        position: "target",
                        event: $event,
                        submit: function (model) {
                            scope.selectedItems.push(model.selectedItem);
                            // if no default item - set item as default
                            if (scope.defaultItem === null) {
                                scope.setAsDefaultItem(model.selectedItem);
                            }
                            overlayService.close();
                        },
                        close: function () {
                            overlayService.close();
                        }
                    };
                    overlayService.open(dialogModel);
                }
            };

            scope.openTemplate = function (selectedItem) {
                const editor = {
                    id: selectedItem.id,
                    submit: function () {
                        editorService.close();
                    },
                    close: function () {
                        editorService.close();
                    }
                };
                editorService.templateEditor(editor);
            }

            scope.setAsDefaultItem = function (selectedItem) {

                // clear default item
                scope.defaultItem = {};

                // set as default item
                scope.defaultItem = selectedItem;
            };

            function updatePlaceholders() {

                // update default item
                if (scope.defaultItem !== null && scope.defaultItem.placeholder) {

                    scope.defaultItem.name = scope.name;

                    if (scope.alias !== null && scope.alias !== undefined) {
                        scope.defaultItem.alias = scope.alias;
                    }

                }

                // update selected items
                Utilities.forEach(scope.selectedItems, selectedItem => {
                    if (selectedItem.placeholder) {

                        selectedItem.name = scope.name;

                        if (scope.alias !== null && scope.alias !== undefined) {
                            selectedItem.alias = scope.alias;
                        }
                    }
                });

                // update availableItems
                Utilities.forEach(scope.availableItems, availableItem => {
                    if (availableItem.placeholder) {

                        availableItem.name = scope.name;

                        if (scope.alias !== null && scope.alias !== undefined) {
                            availableItem.alias = scope.alias;
                        }
                    }
                });

            }

            function activate() {

                // add watchers for updating placeholde name and alias
                if (scope.updatePlaceholder) {
                    eventBindings.push(scope.$watch('name', function (newValue, oldValue) {
                        updatePlaceholders();
                    }));

                    eventBindings.push(scope.$watch('alias', function (newValue, oldValue) {
                        updatePlaceholders();
                    }));
                }

            }

            activate();

            // clean up
            scope.$on('$destroy', function () {

                // clear watchers
                for (var e in eventBindings) {
                    eventBindings[e]();
                }

            });

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-grid-selector.html',
            scope: {
                name: "=",
                alias: "=",
                selectedItems: '=',
                availableItems: "=",
                defaultItem: "=",
                itemName: "@",
                updatePlaceholder: "=",
                itemPicker: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbGridSelector', GridSelector);

})();

----
umbemptystate.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEmptyState
@restrict E
@scope

@description
Use this directive to show an empty state message.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-empty-state
            ng-if="!vm.items"
            position="center">
            // Empty state content
        </umb-empty-state>

    </div>
</pre>

@param {string=} size Set the size of the text ("small", "large").
@param {string=} position Set the position of the text ("center").
**/

(function() {
   'use strict';

   function EmptyStateDirective() {

      var directive = {
         restrict: 'E',
         replace: true,
         transclude: true,
         templateUrl: 'views/components/umb-empty-state.html',
         scope: {
            size: '@',
            position: '@'
         }
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEmptyState', EmptyStateDirective);

})();

----
umblayoutselector.directive.js
(function () {
    'use strict';
    
    angular
        .module('umbraco.directives')
        .component('umbLayoutSelector', {
            templateUrl: 'views/components/umb-layout-selector.html',
            controller: LayoutSelectorController,
            controllerAs: 'vm',
            bindings: {
                layouts: '<',
                activeLayout: '<',
                onLayoutSelect: '&'
            }
        });

    function LayoutSelectorController($scope, $element) {

        var vm = this;

        vm.$onInit = onInit;

        vm.layoutDropDownIsOpen = false;
        vm.showLayoutSelector = true;
        vm.pickLayout = pickLayout;
        vm.toggleLayoutDropdown = toggleLayoutDropdown;
        vm.leaveLayoutDropdown = leaveLayoutDropdown;
        vm.closeLayoutDropdown = closeLayoutDropdown;

        function onInit() {
            activate();
        }

        function closeLayoutDropdown() {
            vm.layoutDropDownIsOpen = false;
        }

        function toggleLayoutDropdown() {
            vm.layoutDropDownIsOpen = !vm.layoutDropDownIsOpen;
        }

        function leaveLayoutDropdown() {
            vm.layoutDropDownIsOpen = false;
        }

        function pickLayout(selectedLayout) {
            if (vm.onLayoutSelect) {
                vm.onLayoutSelect({ layout: selectedLayout });
                vm.layoutDropDownIsOpen = false;
            }
        }

        function activate() {
            setVisibility();
            setActiveLayout(vm.layouts);
        }

        function setVisibility() {

            var numberOfAllowedLayouts = getNumberOfAllowedLayouts(vm.layouts);

            if (numberOfAllowedLayouts === 1) {
                vm.showLayoutSelector = false;
            }

        }

        function getNumberOfAllowedLayouts(layouts) {

            var allowedLayouts = 0;

            for (var i = 0; layouts.length > i; i++) {

                var layout = layouts[i];

                if (layout.selected === true) {
                    allowedLayouts++;
                }

            }

            return allowedLayouts;
        }

        function setActiveLayout(layouts) {

            for (var i = 0; layouts.length > i; i++) {
                var layout = layouts[i];
                if (layout.path === vm.activeLayout.path) {
                    layout.active = true;
                }
            }

        }
    }

})();

----
umblistviewlayout.directive.js
(function () {
    'use strict';

    function ListViewLayoutDirective() {

        function link(scope, el, attr, ctrl) {

            scope.getContent = function (contentId) {
                if (scope.onGetContent) {
                    scope.onGetContent({ contentId: contentId});
                }
            };

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-list-view-layout.html',
            scope: {
                contentId: '<',
                folders: '<',
                items: '<',
                selection: '<',
                options: '<',
                entityType: '@',
                onGetContent: '&'
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbListViewLayout', ListViewLayoutDirective);

})();

----
umbcodesnippet.directive.js
﻿/**
@ngdoc directive
@name umbraco.directives.directive:umbCodeSnippet
@restrict E
@scope

@description

<h3>Markup example</h3>
<pre>
	<div ng-controller="My.Controller as vm">

        <umb-code-snippet 
            language="'csharp'">
            {{code}}
        </umb-code-snippet>

	</div>
</pre>

<h3>Controller example</h3>
<pre>
	(function () {
		"use strict";

		function Controller() {

            var vm = this;

        }

		angular.module("umbraco").controller("My.Controller", Controller);

	})();
</pre>

@param {string=} language Language of the code snippet, e.g csharp, html, css.
**/


(function () {
    'use strict';

    var umbCodeSnippet = {
        templateUrl: 'views/components/umb-code-snippet.html',
        controller: UmbCodeSnippetController,
        controllerAs: 'vm',
        transclude: true,
        bindings: {
            language: '<'
        }
    };

    function UmbCodeSnippetController($timeout) {

        const vm = this;

        vm.page = {};

        vm.$onInit = onInit;
        vm.copySuccess = copySuccess;
        vm.copyError = copyError;

        function onInit() {
            vm.guid = String.CreateGuid();

            if (vm.language)
            {
                switch (vm.language.toLowerCase()) {
                    case "csharp":
                    case "c#":
                        vm.language = "C#";
                        break;
                    case "html":
                        vm.language = "HTML";
                        break;
                    case "css":
                        vm.language = "CSS";
                        break;
                    case "javascript":
                        vm.language = "JavaScript";
                        break;
                }
            }
            
        }

        // copy to clip board success
        function copySuccess() {
            if (vm.page.copyCodeButtonState !== "success") {
                $timeout(function () {
                    vm.page.copyCodeButtonState = "success";
                });
                $timeout(function () {
                    resetClipboardButtonState();
                }, 1000);
            }
        }

        // copy to clip board error
        function copyError() {
            if (vm.page.copyCodeButtonState !== "error") {
                $timeout(function () {
                    vm.page.copyCodeButtonState = "error";
                });
                $timeout(function () {
                    resetClipboardButtonState();
                }, 1000);
            }
        }

        function resetClipboardButtonState() {
            vm.page.copyCodeButtonState = "init";
        }
    }

    angular.module('umbraco.directives').component('umbCodeSnippet', umbCodeSnippet);

})();

----
umbtooltip.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTooltip
@restrict E
@scope

@description
Use this directive to render a tooltip.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <div
            ng-mouseover="vm.mouseOver($event)"
            ng-mouseleave="vm.mouseLeave()">
            Hover me
        </div>

        <umb-tooltip
           ng-if="vm.tooltip.show"
           event="vm.tooltip.event">
           // tooltip content here
        </umb-tooltip>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;
            vm.tooltip = {
                show: false,
                event: null
            };

            vm.mouseOver = mouseOver;
            vm.mouseLeave = mouseLeave;

            function mouseOver($event) {
                vm.tooltip = {
                    show: true,
                    event: $event
                };
            }

            function mouseLeave() {
                vm.tooltip = {
                    show: false,
                    event: null
                };
            }

        }

        angular.module("umbraco").controller("My.Controller", Controller);

    })();
</pre>

@param {string} event Set the $event from the target element to position the tooltip relative to the mouse cursor.
**/

(function() {
   'use strict';

   function TooltipDirective() {

      function link(scope, el, attr, ctrl) {

         scope.tooltipStyles = {};
         scope.tooltipStyles.left = 0;
         scope.tooltipStyles.top = 0;

          function setTooltipPosition(event) {

            var overlay = $(event.target).closest('.umb-overlay');
            var container = overlay.length > 0 ? overlay : $("#contentwrapper");

            let rect = container[0].getBoundingClientRect();

            var containerLeft = rect.left;
            var containerRight = containerLeft + rect.width;
            var containerTop = rect.top;
            var containerBottom = containerTop + rect.height;

            var elementHeight = null;
            var elementWidth = null;

            var position = {
               right: "inherit",
               left: "inherit",
               top: "inherit",
               bottom: "inherit"
            };

            // element size
            elementHeight = el[0].clientHeight;
            elementWidth = el[0].clientWidth;

            position.left = event.pageX - (elementWidth / 2);
            position.top = event.pageY;

            if (overlay.length > 0) {
                position.left = event.pageX - rect.left - (elementWidth / 2);
                position.top = event.pageY - rect.top;
            }
            else {
                // check to see if element is outside screen
                // outside right
                if (position.left + elementWidth > containerRight) {
                    position.right = 10;
                    position.left = "inherit";
                }

                // outside bottom
                if (position.top + elementHeight > containerBottom) {
                    position.bottom = 10;
                    position.top = "inherit";
                }

                // outside left
                if (position.left < containerLeft) {
                    position.left = containerLeft + 10;
                    position.right = "inherit";
                }

                // outside top
                if (position.top < containerTop) {
                    position.top = 10;
                    position.bottom = "inherit";
                }
            }

            scope.tooltipStyles = position;

            el.css(position);
         }

         setTooltipPosition(scope.event);
      }

      var directive = {
         restrict: 'E',
         transclude: true,
         replace: true,
         templateUrl: 'views/components/umb-tooltip.html',
         scope: {
            event: "="
         },
         link: link
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbTooltip', TooltipDirective);

})();

----
umbGenerateAlias.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbGenerateAlias
@restrict E
@scope

@description
Use this directive to generate a camelCased umbraco alias.
When the aliasFrom value is changed the directive will get a formatted alias from the server and update the alias model. If "enableLock" is set to <code>true</code>
the directive will use {@link umbraco.directives.directive:umbLockedField umbLockedField} to lock and unlock the alias.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <input type="text" ng-model="vm.name" />

        <umb-generate-alias
            enable-lock="true"
            alias-from="vm.name"
            alias="vm.alias">
        </umb-generate-alias>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;

            vm.name = "";
            vm.alias = "";

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {string} alias (<code>binding</code>): The model where the alias is bound.
@param {string} aliasFrom (<code>binding</code>): The model to generate the alias from.
@param {string} validationPosition (<code>binding</code>): The position of the validation. Set to <code>'left'</code> or <code>'right'</code>.
@param {boolean=} enableLock (<code>binding</code>): Set to <code>true</code> to add a lock next to the alias from where it can be unlocked and changed.
**/

angular.module("umbraco.directives")
    .directive('umbGenerateAlias', function ($timeout, entityResource, localizationService) {
        return {
            restrict: 'E',
            templateUrl: 'views/components/umb-generate-alias.html',
            replace: true,
            scope: {
                alias: '=',
                aliasFrom: '=',
                enableLock: '=?',
                validationPosition: '=?',
                serverValidationField: '@'
            },
            link: function (scope, element, attrs, ctrl) {

                var eventBindings = [];
                var bindWatcher = true;
                var generateAliasTimeout = "";
                var updateAlias = false;

                scope.locked = true;

                scope.labels = {
                    idle: "Enter alias...",
                    busy: "Generating alias..."
                };
                
                scope.placeholderText = scope.labels.idle;
                
                localizationService.localize('placeholders_enterAlias').then(function (value) {
                    scope.labels.idle = scope.placeholderText = value;
                });

                localizationService.localize('placeholders_generatingAlias').then(function (value) {
                    scope.labels.busy = value;
                });

                function generateAlias(value) {

                  if (generateAliasTimeout) {
                     $timeout.cancel(generateAliasTimeout);
                  }

                  if (value !== undefined && value !== "" && value !== null) {

                    scope.alias = "";
                    scope.placeholderText = scope.labels.busy;

                    generateAliasTimeout = $timeout(function () {
                       updateAlias = true;
                        entityResource.getSafeAlias(value, true).then(function (safeAlias) {
                            if (updateAlias) {
                                scope.alias = safeAlias.alias;
                            }
                            scope.placeholderText = scope.labels.idle;
                      });
                    }, 500);

                  } else {
                    updateAlias = true;
                    scope.alias = "";
                    scope.placeholderText = scope.labels.idle;
                  }
                }

                // if alias gets unlocked - stop watching alias
                eventBindings.push(scope.$watch('locked', function(newValue, oldValue){
                    if(newValue === false) {
                       bindWatcher = false;
                    }
                }));

                // validate custom entered alias
                eventBindings.push(scope.$watch('alias', function (newValue, oldValue) {
                    if (scope.alias === "" || scope.alias === null || scope.alias === undefined) {
                        if (bindWatcher === true) {
                            // add watcher
                            eventBindings.push(scope.$watch('aliasFrom', function (newValue, oldValue) {
                                if (bindWatcher) {
                                    generateAlias(newValue);
                                }
                            }));
                        }
                    }
               }));

               // clean up
               scope.$on('$destroy', function(){
                 // unbind watchers
                 for(var e in eventBindings) {
                   eventBindings[e]();
                  }
               });

            }
        };
    });

----
umblistviewsettings.directive.js
(function () {
    'use strict';

    function ListViewSettingsDirective(dataTypeResource, dataTypeHelper, editorService, listViewPrevalueHelper) {

        function link(scope) {

            scope.dataType = {};
            scope.customListViewCreated = false;

            const listViewPrefix = "List View - ";
            
            const checkForCustomListView = () => invariantEquals(scope.dataType.name, listViewPrefix + scope.modelAlias);

            // We also use "localeCompare" a few other places. Should probably be moved to a utility/helper function in future.
            function invariantEquals(a, b) {
                return typeof a === "string" && typeof b === "string"
                    ? a.localeCompare(b, undefined, { sensitivity: "base" }) === 0
                    : a === b;
            }

            /* ---------- INIT ---------- */ 

            const setDataType = (dataType) => {
                scope.dataType = dataType;
                listViewPrevalueHelper.setPrevalues(dataType.preValues);
            }

            const activate = () => {

                if (scope.enableListView) {

                    dataTypeResource.getByName(scope.listViewName)
                        .then(dataType => {
                            setDataType(dataType);
                            scope.customListViewCreated = checkForCustomListView();
                        });

                } else {
                    scope.dataType = {};
                } 
            } 

            /* ----------- LIST VIEW SETTINGS --------- */
            const showSettingsOverlay = () => {
                const overlay = {
                    view: 'views/components/umb-list-view-settings-overlay.html',
                    hideDescription: true,
                    hideIcon: true,
                    size: 'medium',
                    dataType: scope.dataType,
                    title: 'List view settings',
                    submit: model => {
                        const preValues = dataTypeHelper.createPreValueProps(model.dataType.preValues);

                        // store data type   
                        dataTypeResource.save(model.dataType, preValues, false)
                            .then(dataType => scope.dataType = dataType);                      
                        
                        editorService.close();
                    },
                    close: () => editorService.close()
                };

                editorService.open(overlay);
            };


            /* ---------- CUSTOM LIST VIEW ---------- */

            scope.createCustomListViewDataType = () => {

                scope.loading = true;
                
                dataTypeResource.createCustomListView(scope.modelAlias).then(dataType => {

                    // store data type
                    setDataType(dataType);

                    // set list view name on scope
                    scope.listViewName = dataType.name;

                    // change state to custom list view
                    scope.customListViewCreated = true;

                    // show settings overlay
                    showSettingsOverlay();
                    
                    scope.loading = false;

                }); 
            }; 

            scope.removeCustomListDataType = () => {
                
                scope.loading = true;

                // delete custom list view data type
                dataTypeResource.deleteById(scope.dataType.id).then(dataType => {

                    // set list view name on scope
                    scope.listViewName = `List View - ${scope.contentType === 'documentType' ? 'Content' : 'Media'}`;

                    // get default data type 
                    dataTypeResource.getByName(scope.listViewName)
                        .then(defaultDataType => {

                            // store data type
                            setDataType(defaultDataType);

                            // change state to default list view
                            scope.customListViewCreated = false;
                            
                            scope.loading = false;
                        });
                });
            };

            scope.toggle = () => scope.enableListView = !scope.enableListView;           
            scope.showSettingsOverlay = () => showSettingsOverlay();
            
            
            /* ----------- SCOPE WATCHERS ----------- */
            const unbindEnableListViewWatcher = scope.$watch('enableListView', newValue => {

                if (newValue !== undefined) {
                    activate();
                }

            });

            // clean up
            scope.$on('$destroy', () => unbindEnableListViewWatcher());
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-list-view-settings.html',
            scope: {
                enableListView: "=",
                listViewName: "=",
                modelAlias: "=",
                contentType: "@"
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbListViewSettings', ListViewSettingsDirective);

})();

----
umbloadindicator.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbLoadIndicator
@restrict E

@description
Use this directive to generate a loading indicator.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-load-indicator
            ng-if="vm.loading">
        </umb-load-indicator>

        <div class="content" ng-if="!vm.loading">
            <p>{{content}}</p>
        </div>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller(myService) {

            var vm = this;

            vm.content = "";
            vm.loading = true;

            myService.getContent().then(function(content){
                vm.content = content;
                vm.loading = false;
            });

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>
**/

(function() {
  'use strict';

  function UmbLoadIndicatorDirective() {

    var directive = {
      restrict: 'E',
      replace: true,
      templateUrl: 'views/components/umb-load-indicator.html'
    };

    return directive;
  }

  angular.module('umbraco.directives').directive('umbLoadIndicator', UmbLoadIndicatorDirective);

})();

----
umbloader.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbLoader
@restrict E

@description
Use this directive to generate a loading indicator.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-loader
            ng-if="vm.loading">
        </umb-loader>

        <div class="content" ng-if="!vm.loading">
            <p>{{content}}</p>
        </div>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller(myService) {

            var vm = this;

            vm.content = "";
            vm.loading = true;

            myService.getContent().then(function(content){
                vm.content = content;
                vm.loading = false;
            });

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {string=} position The loader position ("top", "bottom").

**/

(function() {
  'use strict';

  function UmbLoaderDirective() {

    function link(scope, el, attr, ctrl) {
        
    }

    var directive = {
        restrict: 'E',
        replace: true,
        templateUrl: 'views/components/umb-loader.html',
        scope: {
            position: "@?"
        },
        link: link
    };

    return directive;
  }
  
  angular.module('umbraco.directives').directive('umbLoader', UmbLoaderDirective);

})();

----
umblightbox.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbLightbox
@restrict E
@scope

@description
<p>Use this directive to open a gallery in a lightbox overlay.</p>

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <div class="my-gallery">
            <button type="button" ng-repeat="image in images" ng-click="vm.openLightbox($index, images)">
                <img ng-src="image.source" />
            </button>
        </div>

        <umb-lightbox
            ng-if="vm.lightbox.show"
            items="vm.lightbox.items"
            active-item-index="vm.lightbox.activeIndex"
            on-close="vm.closeLightbox">
        </umb-lightbox>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {

        "use strict";

        function Controller() {

            var vm = this;

            vm.images = [
                {
                    "source": "linkToImage"
                },
                {
                    "source": "linkToImage"
                }
            ]

            vm.openLightbox = openLightbox;
            vm.closeLightbox = closeLightbox;

            function openLightbox(itemIndex, items) {
                vm.lightbox = {
                    show: true,
                    items: items,
                    activeIndex: itemIndex
                };
            }

            function closeLightbox() {
                vm.lightbox.show = false;
                vm.lightbox = null;
            }

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {array} items Array of gallery items.
@param {callback} onClose Callback when the lightbox is closed.
@param {number} activeItemIndex Index of active item.
**/


(function() {
    'use strict';

    function LightboxDirective(focusLockService) {

        function link(scope, el, attr, ctrl) {


            function activate() {

                var eventBindings = [];

                el.appendTo("body");

                
                focusLockService.addInertAttribute();

                // clean up
                scope.$on('$destroy', function() {
                    // unbind watchers
                    for (var e in eventBindings) {
                        eventBindings[e]();
                    }
                    
                    focusLockService.removeInertAttribute();

                    document.getElementsByClassName("umb-lightbox__close")[0].blur();
                    el.remove();
                });
            }

            scope.next = function() {

                var nextItemIndex = scope.activeItemIndex + 1;

                if( nextItemIndex < scope.items.length) {
                    scope.items[scope.activeItemIndex].active = false;
                    scope.items[nextItemIndex].active = true;
                    scope.activeItemIndex = nextItemIndex;
                }
            };

            scope.prev = function() {

                var prevItemIndex = scope.activeItemIndex - 1;

                if( prevItemIndex >= 0) {
                    scope.items[scope.activeItemIndex].active = false;
                    scope.items[prevItemIndex].active = true;
                    scope.activeItemIndex = prevItemIndex;
                }

            };

            scope.close = function() {
                if(scope.onClose) {
                    scope.onClose();
                    focusLockService.removeInertAttribute();
                }
            };

            activate();

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/umb-lightbox.html',
            scope: {
                items: '=',
                onClose: "=",
                activeItemIndex: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbLightbox', LightboxDirective);

})();

----
tabs/umbtabcontent.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTabContent
@restrict E
@scope

@description
Use this directive to render tab content. For an example see: {@link umbraco.directives.directive:umbTabContent umbTabContent}

@param {string=} tab The tab.

**/
(function () {
    'use strict';

    angular
        .module('umbraco.directives')
        .component('umbTabContent', {
            transclude: true,
            templateUrl: 'views/components/tabs/umb-tab-content.html',
            controllerAs: 'vm',
            bindings: {
                tab: '<'
            }
        });

})();

----
tabs/umbtabsnav.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTabsNav
@restrict E
@scope

@description
Use this directive to render a tabs navigation.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <!-- The tabs navigation depends on a form and the validation manager. If the tabs are used inside a property editor or dashboard this is already added -->
        <ng-form name="tabsForm" val-form-manager>

            <umb-tabs-nav
                tabs="vm.tabs"
                on-tab-change="vm.changeTab(tab)">
            </umb-tabs-nav>

            <umb-tab-content
                ng-repeat="tab in vm.tabs"
                ng-show="tab.active"
                tab="tab">
                <div ng-if="tab.alias === 'tabOne'">
                    <div>Content of tab 1</div>
                </div>
                <div ng-if="tab.alias === 'tabTwo'">
                    <div>Content of tab 2</div>
                </div>
            </umb-tab-content>

        </ng-form>
    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller(eventsService) {

            var vm = this;

            vm.changeTab = changeTab;

            vm.tabs = [
                {
                    "alias": "tabOne",
                    "label": "Tab 1",
                    "active": true
                },
                {
                    "alias": "tabTwo",
                    "label": "Tab 2"
                }
            ];

            function changeTab(selectedTab) {
                vm.tabs.forEach(function(tab) {
                    tab.active = false;
                });
                selectedTab.active = true;
            };

            eventsService.on("app.tabChange", function(name, args){
                console.log("args", args);
            });

        }

        angular.module("umbraco").controller("My.Controller", Controller);

    })();
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbTabContent umbTabContent}</li>
</ul>

@param {string=} tabs A collection of tabs.
@param {callback=} onTabChange Callback when a tab is called. It Returns the selected tab.


**/

(function() {
    'use strict';

    function TabsNavDirective($timeout, $window, eventsService) {

        function link(scope, element, attrs, ctrl) {

            var tabNavItemsWidths = [];
            // the parent is the component itself so we need to go one level higher
            var container = element.parent().parent();

            const ro = new ResizeObserver(function () {
                calculateWidth();
            });

            ro.observe(container[0]);

            $timeout(function(){
                element.find("li:not(umb-tab--expand)").each(function() {
                    tabNavItemsWidths.push($(this).outerWidth());
                });
            });

            function calculateWidth(){
                $timeout(function(){
                    // 70 is the width of the expand menu (three dots) + 20 for the margin on umb-tabs-nav
                    var containerWidth = container.width() - 90;
                    var tabsWidth = 0;
                    ctrl.overflowingSections = 0;
                    ctrl.needTray = false;
                    ctrl.maxTabs = tabNavItemsWidths.length;

                    // detect how many tabs we can show on the screen
                    for (var i = 0; i <= tabNavItemsWidths.length; i++) {
                        
                        var tabWidth = tabNavItemsWidths[i];
                        tabsWidth += tabWidth;

                        if(tabsWidth >= containerWidth) {
                            ctrl.needTray = true;
                            ctrl.maxTabs = i;
                            ctrl.overflowingTabs = ctrl.maxTabs - ctrl.tabs.length;
                            break;
                        }
                    }
                    
                });
            }

            scope.$on('$destroy', function() {
                ro.unobserve(container[0]);
            });
        }

        function UmbTabsNavController(eventsService) {

            var vm = this;

            vm.needTray = false;
            vm.showTray = false;
            vm.overflowingSections = 0;

            vm.clickTab = clickTab;
            vm.toggleTray = toggleTray;
            vm.hideTray = hideTray;
    
            function clickTab($event, tab) {
                if (vm.onTabChange) {
                    hideTray();
                    var args = { "tab": tab, "tabs": vm.tabs };
                    eventsService.emit("app.tabChange", args);
                    vm.onTabChange({ "event": $event, "tab": tab });
                }
            }

            function toggleTray() {
                vm.showTray = !vm.showTray;
            }

            function hideTray() {
                vm.showTray = false;
            }

        }

        var directive = {
            restrict: 'E',
            transclude: true,
            templateUrl: "views/components/tabs/umb-tabs-nav.html",
            link: link,
            bindToController: true,
            controller: UmbTabsNavController,
            controllerAs: 'vm',
            scope: {
                tabs: "<",
                onTabChange: "&"
            }
        };
        return directive;
    }

    angular.module('umbraco.directives').directive('umbTabsNav', TabsNavDirective);

})();

----
tree/umbtreeitem.directive.js
/**
 * @ngdoc directive
 * @name umbraco.directives.directive:umbTreeItem
 * @element li
 * @function
 *
 * @description
 * Renders a list item, representing a single node in the tree.
 * Includes element to toggle children, and a menu toggling button
 *
 * **note:** This directive is only used internally in the umbTree directive
 *
 * @example
   <example module="umbraco">
    <file name="index.html">
         <umb-tree-item ng-repeat="child in tree.children" node="child" callback="callback" section="content"></umb-tree-item>
    </file>
   </example>
 */
angular.module("umbraco.directives")
    .directive('umbTreeItem', function(treeService, $timeout, localizationService, eventsService, appState, navigationService) {
    return {
        restrict: 'E',
        replace: true,
        require: '^umbTree',
        templateUrl: 'views/components/tree/umb-tree-item.html',
        scope: {
            section: '@',
            currentNode: '=',
            enablelistviewexpand: '@',
            node: '=',
            tree: '=',
            isDialog: '='
        },
        
        link: function (scope, element, attrs, umbTreeCtrl) {
            localizationService.localizeMany(["general_search", "visuallyHiddenTexts_openContextMenu"]).then(function (value) {
                scope.searchAltText = value[0];
                scope.optionsText = value[1];
            });
            
            // updates the node's DOM/styles
            function setupNodeDom(node, tree) {
                
                //get the first div element
                element.children(":first")
                    //set the padding
                    .css("padding-left", (node.level * 20) + "px");

                // add a unique data element to each tree item so it is easy to navigate with code
                if(!node.metaData.treeAlias) {
                    node.dataElement = node.name;
                } else {
                    node.dataElement = node.metaData.treeAlias;
                }

            }

            /** Returns the css classses assigned to the node (div element) */
            scope.getNodeCssClass = function (node) {
                if (!node) {
                    return '';
                }
                
                // TODO: This is called constantly because as a method in a template it's re-evaluated pretty much all the time
                // it would be better if we could cache the processing. The problem is that some of these things are dynamic.

                //is this the current action node (this is not the same as the current selected node!)
                var actionNode = appState.getMenuState("currentNode");
                
                var css = [];                
                if (node.cssClasses) {
                    node.cssClasses.forEach(c => css.push(c));
                }
                if (node.selected) {
                    css.push("umb-tree-node-checked");
                }
                if (node == scope.currentNode) {
                    css.push("current");
                    if (actionNode && actionNode.id !== node.id) {
                        css.push("current-not-active");// when its the current node, but its not the active(current node for the given action)
                    }
                }
                if (node.hasChildren) {
                    css.push("has-children");
                }
                if (node.deleteAnimations) {
                    css.push("umb-tree-item--deleted");
                }

                // checking the nodeType to ensure that this node and actionNode is from the same treeAlias
                if (actionNode && actionNode.nodeType === node.nodeType) {

                    if (actionNode.id === node.id && String(node.id) !== "-1") {
                        css.push("active");
                    }
                    
                    // special handling of root nodes with id -1 
                    // as there can be many nodes with id -1 in a tree we need to check the treeAlias instead
                    if (String(node.id) === "-1" && actionNode.metaData.treeAlias === node.metaData.treeAlias) {
                        css.push("active");
                    }
                }

                return css.join(" ");
            };

            //add a method to the node which we can use to call to update the node data if we need to ,
            // this is done by sync tree, we don't want to add a $watch for each node as that would be crazy insane slow
            // so we have to do this
            scope.node.updateNodeData = function (newNode) {
                _.extend(scope.node, newNode);
                //now update the styles
                setupNodeDom(scope.node, scope.tree);
            };

            /**
              Method called when the options button next to a node is called
              In the main tree this opens the menu, but internally the tree doesnt
              know about this, so it simply raises an event to tell the parent controller
              about it.
            */
            scope.options = function (n, ev) {
                umbTreeCtrl.emitEvent("treeOptionsClick", { element: element, tree: scope.tree, node: n, event: ev });
            };

            /**
              Method called when an item is clicked in the tree, this passes the 
              DOM element, the tree node object and the original click
              and emits it as a treeNodeSelect element if there is a callback object
              defined on the tree
            */
            scope.select = function (n, ev) {
                if (ev.ctrlKey ||
                    ev.shiftKey ||
                    ev.metaKey || // apple
                    (ev.button && ev.button === 1) // middle click, >IE9 + everyone else
                ) {
                    return;
                }

                if (n.metaData && n.metaData.noAccess === true) {
                    ev.preventDefault();
                    return;
                }

                umbTreeCtrl.emitEvent("treeNodeSelect", { element: element, tree: scope.tree, node: n, event: ev });
                ev.preventDefault();
            };

            /**
              Method called when an item is right-clicked in the tree, this passes the 
              DOM element, the tree node object and the original click
              and emits it as a treeNodeSelect element if there is a callback object
              defined on the tree
            */
            scope.altSelect = function(n, ev) {
                if(ev.altKey) return false;
                umbTreeCtrl.emitEvent("treeNodeAltSelect", { element: element, tree: scope.tree, node: n, event: ev });
            };
            
            /**
              Method called when a node in the tree is expanded, when clicking the arrow
              takes the arrow DOM element and node data as parameters
              emits treeNodeCollapsing event if already expanded and treeNodeExpanding if collapsed
            */
            scope.load = function (node) {
                if (node.expanded && !node.metaData.isContainer) {
                    umbTreeCtrl.emitEvent("treeNodeCollapsing", { tree: scope.tree, node: node, element: element });
                    node.expanded = false;
                }
                else {
                    scope.loadChildren(node, false);
                }
            };

            /* helper to force reloading children of a tree node */
            scope.loadChildren = function(node, forceReload) {
                return umbTreeCtrl.loadChildren(node, forceReload);
            };

            //if the current path contains the node id, we will auto-expand the tree item children
            setupNodeDom(scope.node, scope.tree);

            // load the children if the current user don't have access to the node
            // it is used to auto expand the tree to the start nodes the user has access to
            if(scope.node.hasChildren && scope.node.metaData.noAccess) {
                scope.loadChildren(scope.node);
            }

            var evts = [];

            // Listen for section changes
            evts.push(eventsService.on("appState.sectionState.changed", function(e, args) {
                if (args.key === "currentSection") {
                    //when the section changes disable all delete animations
                    scope.node.deleteAnimations = false;
                }
            }));

            // Update tree icon if changed
            evts.push(eventsService.on("editors.tree.icon.changed", function (e, args) {          
                if (args.icon !== scope.node.icon && args.id === scope.node.id) {
                    scope.node.icon = args.icon;
                }
            }));

            /** Depending on if any menu is shown and if the menu is shown for the current node, toggle delete animations */
            function toggleDeleteAnimations() {
                //if both are false then remove animations
                var hide = !appState.getMenuState("showMenuDialog") && !appState.getMenuState("showMenu");
                if (hide) {
                    scope.node.deleteAnimations = false;
                }
                else {
                    //enable animations for this node if it is the node currently showing a context menu
                    var currentNode = appState.getMenuState("currentNode");
                    if (currentNode && currentNode.id == scope.node.id) {
                        scope.node.deleteAnimations = true;
                    }
                    else {
                        scope.node.deleteAnimations = false;
                    }
                }
            }

            //listen for context menu and current node changes
            evts.push(eventsService.on("appState.menuState.changed", function(e, args) {
                if (args.key === "showMenuDialog" || args.key == "showMenu" || args.key == "currentNode") {
                    toggleDeleteAnimations();
                }
            }));

            //cleanup events
            scope.$on('$destroy', function() {
                for (var e in evts) {
                    eventsService.unsubscribe(evts[e]);
                }
            });
        }
    };
});

----
tree/umbtreesearchresults.directive.js
﻿/**
* @ngdoc directive
* @name umbraco.directives.directive:umbTreeSearchResults
* @function
* @element ANY
* @restrict E
**/
function treeSearchResults() {
    return {
        scope: {
            results: "=",
            selectResultCallback: "=",
            emptySearchResultPosition: '@'
        },
        restrict: "E",    // restrict to an element
        replace: true,   // replace the html element with the template
        templateUrl: 'views/components/tree/umb-tree-search-results.html',
        link: function (scope, element, attrs, ctrl) {
            scope.emptySearchResultPosition = scope.emptySearchResultPosition || "center";
        }
    };
}
angular.module('umbraco.directives').directive("umbTreeSearchResults", treeSearchResults);

----
tree/umbtreesearchbox.directive.js
﻿/**
* @ngdoc directive
* @name umbraco.directives.directive:umbTreeSearchBox
* @function
* @element ANY
* @restrict E
**/
function treeSearchBox($q, searchService) {
    return {
        scope: {
            searchFromId: "@",
            searchFromName: "@",
            showSearch: "@",
            section: "@",
            datatypeKey: "@",
            hideSearchCallback: "=",
            searchCallback: "=",
            inputId: "@",
            autoFocus: "="
        },
        restrict: "E",    // restrict to an element
        replace: true,   // replace the html element with the template
        templateUrl: 'views/components/tree/umb-tree-search-box.html',
        link: function (scope, element, attrs, ctrl) {

            scope.term = "";

            scope.hideSearch = function() {
                scope.term = "";
                scope.hideSearchCallback();
            };

            if (!scope.showSearch) {
                scope.showSearch = "false";
            }

            //used to cancel any request in progress if another one needs to take it's place
            var canceler = null;

            function performSearch() {
                if (scope.term) {
                    scope.results = [];

                    //a canceler exists, so perform the cancelation operation and reset
                    if (canceler) {
                        canceler.resolve();
                        canceler = $q.defer();
                    }
                    else {
                        canceler = $q.defer();
                    }

                    var searchArgs = {
                        term: scope.term,
                        canceler: canceler
                    };

                    //append a start node context if there is one
                    if (scope.searchFromId) {
                        searchArgs["searchFrom"] = scope.searchFromId;
                    }

                    //append dataTypeId value if there is one
                    if (scope.datatypeKey) {
                        searchArgs["dataTypeKey"] = scope.datatypeKey;
                    }

                    searcher(searchArgs).then(function (data) {
                        scope.searchCallback(data);
                        //set back to null so it can be re-created
                        canceler = null;
                    });
                }
                else {
                    scope.hideSearch();
                }
            }

            scope.$watch("term", _.debounce(function(newVal, oldVal) {
                scope.$apply(function() {
                    if (newVal !== null && newVal !== undefined && newVal !== oldVal) {
                        performSearch();
                    }
                });
            }, 200));

            var searcher = searchService.searchContent;
            //search
            if (scope.section === "member") {
                searcher = searchService.searchMembers;
            }
            else if (scope.section === "media") {
                searcher = searchService.searchMedia;
            }
        }
    };
}
angular.module('umbraco.directives').directive("umbTreeSearchBox", treeSearchBox);

----
tree/umbtree.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbTree
* @restrict E
**/
function umbTreeDirective($q, treeService, notificationsService) {

    return {
        restrict: 'E',
        replace: true,
        terminal: false,
        templateUrl: 'views/components/tree/umb-tree.html',
        scope: {
            section: '@',
            treealias: '@',
            hideoptions: '@',
            hideheader: '@',
            cachekey: '@',
            isdialog: '@',
            onlyInitialized: '@',
            //Custom query string arguments to pass in to the tree as a string, example: "startnodeid=123&something=value"
            customtreeparams: '@',
            enablecheckboxes: '@',
            enablelistviewsearch: '@',
            enablelistviewexpand: '@',
            api: '=?',
            onInit: '&?'
        },
        controller: function ($scope, $element) {

            var vm = this;

            var registeredCallbacks = {
                treeNodeExpanded: [],
                treeNodeSelect: [],
                treeLoaded: [],
                treeSynced: [],
                treeOptionsClick: [],
                treeNodeAltSelect: []
            };

            //this is the API exposed by this directive, for either hosting controllers or for other directives
            vm.callbacks = {
                treeNodeExpanded: function (f) {
                    registeredCallbacks.treeNodeExpanded.push(f);
                },
                treeNodeSelect: function (f) {
                    registeredCallbacks.treeNodeSelect.push(f);
                },
                treeLoaded: function (f) {
                    registeredCallbacks.treeLoaded.push(f);
                },
                treeSynced: function (f) {
                    registeredCallbacks.treeSynced.push(f);
                },
                treeOptionsClick: function (f) {
                    registeredCallbacks.treeOptionsClick.push(f);
                },
                treeNodeAltSelect: function (f) {
                    registeredCallbacks.treeNodeAltSelect.push(f);
                }
            };
            vm.emitEvent = emitEvent;
            vm.load = load;
            vm.reloadNode = reloadNode;
            vm.syncTree = syncTree;
            vm.loadChildren = loadChildren;
            vm.hasTree = hasTree;

            //wire up the exposed api object for hosting controllers
            if ($scope.api) {
                $scope.api.callbacks = vm.callbacks;
                $scope.api.load = vm.load;
                $scope.api.reloadNode = vm.reloadNode;
                $scope.api.syncTree = vm.syncTree;
                $scope.api.hasTree = vm.hasTree;
            }

            //flag to track the last loaded section when the tree 'un-loads'. We use this to determine if we should
            // re-load the tree again. For example, if we hover over 'content' the content tree is shown. Then we hover
            // outside of the tree and the tree 'un-loads'. When we re-hover over 'content', we don't want to re-load the
            // entire tree again since we already still have it in memory. Of course if the section is different we will
            // reload it. This saves a lot on processing if someone is navigating in and out of the same section many times
            // since it saves on data retreival and DOM processing.
            // TODO: This isn't used!?
            var lastSection = "";

            /** Helper function to emit tree events */
            function emitEvent(eventName, args) {
                if (registeredCallbacks[eventName] && Utilities.isArray(registeredCallbacks[eventName])) {
                    // call it
                    registeredCallbacks[eventName].forEach(c => c(args));
                }
            }


            /**
             * Re-loads the tree with the updated parameters
             * @param {any} args either a string representing the 'section' or an object containing: 'section', 'treeAlias', 'customTreeParams', 'cacheKey'
             */
            function load(args) {
                if (Utilities.isString(args)) {
                    $scope.section = args;
                }
                else if (args) {
                    if (args.section) {
                        $scope.section = args.section;
                    }
                    if (args.customTreeParams) {
                        $scope.customtreeparams = args.customTreeParams;
                    }
                    if (args.treeAlias) {
                        $scope.treealias = args.treeAlias;
                    }
                    if (args.cacheKey) {
                        $scope.cachekey = args.cacheKey;
                    }
                }

                return loadTree();
            }

            function reloadNode(node) {

                if (!node) {
                    node = $scope.currentNode;
                }

                if (node) {
                    return $scope.loadChildren(node, true);
                }

                return $q.reject();
            }

            /**
             * Used to do the tree syncing
             * @param {any} args
             * @returns a promise with an object containing 'node' and 'activate'
             */
            function syncTree(args) {
                if (!args) {
                    throw "args cannot be null";
                }
                if (!args.path) {
                    throw "args.path cannot be null";
                }

                if (Utilities.isString(args.path)) {
                    args.path = args.path.replace('"', '').split(',');
                }

                //Filter the path for root node ids (we don't want to pass in -1 or 'init')

                args.path = _.filter(args.path, function (item) { return (item !== "init" && item !== "-1"); });

                var treeNode = loadActiveTree(args.tree);

                return treeService.syncTree({
                    node: treeNode,
                    path: args.path,
                    forceReload: args.forceReload
                }).then(function (data) {

                    if (args.activate === undefined || args.activate === true) {
                        $scope.currentNode = data;
                    }

                    emitEvent("treeSynced", { node: data, activate: args.activate });

                    return $q.when({ node: data, activate: args.activate });
                }, function (data) {
                    return $q.reject(data);
                }, function (data) {
                    //on notification
                    if (data.type === "treeNodeExpanded") {
                        //raise the event
                        emitEvent("treeNodeExpanded", { tree: $scope.tree, node: data.node, children: data.children });
                    }
                });

            }

            /** This will check the section tree loaded and return all actual root nodes based on a tree type (non group nodes, non section groups) */
            function getTreeRootNodes() {
                var roots;
                if ($scope.tree.root.containsGroups) {
                    //all children in this case are group nodes, so we want the children of these children
                    roots = _.reduce(
                        //get the array of array of children
                        _.map($scope.tree.root.children, function (n) {
                            return n.children
                        }), function (m, p) {
                            //combine the arrays to one array
                            return m.concat(p)
                        });
                }
                else {
                    roots = [$scope.tree.root].concat($scope.tree.root.children);
                }

                return _.filter(roots, function (node) {
                    return node && node.metaData && node.metaData.treeAlias;
                });
            }

            //given a tree alias, this will search the current section tree for the specified tree alias and set the current active tree to it's root node
            function hasTree(treeAlias) {

                if (!$scope.tree) {
                    throw "Err in umbtree.directive.loadActiveTree, $scope.tree is null";
                }

                if (!treeAlias) {
                    return false;
                }

                var treeRoots = getTreeRootNodes();
                var foundTree = _.find(treeRoots, function (node) {
                    return node.metaData.treeAlias.toUpperCase() === treeAlias.toUpperCase();
                });

                return foundTree !== undefined;
            }

            //given a tree alias, this will search the current section tree for the specified tree alias and set the current active tree to it's root node
            function loadActiveTree(treeAlias) {

                if (!$scope.tree) {
                    throw "Err in umbtree.directive.loadActiveTree, $scope.tree is null";
                }

                //if its not specified, it should have been specified before
                if (!treeAlias) {
                    if (!$scope.activeTree) {
                        throw "Err in umbtree.directive.loadActiveTree, $scope.activeTree is null";
                    }
                    return $scope.activeTree;
                }

                var treeRoots = getTreeRootNodes();
                $scope.activeTree = _.find(treeRoots, function (node) {
                    return node.metaData.treeAlias.toUpperCase() === treeAlias.toUpperCase();
                });

                if (!$scope.activeTree) {
                    throw "Could not find the tree " + treeAlias;
                }

                emitEvent("activeTreeLoaded", { tree: $scope.activeTree });

                return $scope.activeTree;
            }

            /** Method to load in the tree data */
            function loadTree() {
                if ($scope.section) {

                    //default args
                    var args = { section: $scope.section, tree: $scope.treealias, cacheKey: $scope.cachekey, isDialog: $scope.isdialog ? $scope.isdialog : false };

                    //add the extra query string params if specified
                    if ($scope.customtreeparams) {
                        args["queryString"] = $scope.customtreeparams;
                    }

                    return treeService.getTree(args)
                        .then(function (data) {
                            //Only use the tree data, if we are still on the correct section
                            if(data.alias !== $scope.section){
                                return $q.reject();
                            }
                            
                            //set the data once we have it
                            $scope.tree = data;

                            //set the root as the current active tree
                            $scope.activeTree = $scope.tree.root;

                            emitEvent("treeLoaded", { tree: $scope.tree });
                            emitEvent("treeNodeExpanded", { tree: $scope.tree, node: $scope.tree.root, children: $scope.tree.root.children });
                         
                            return $q.when(data);
                        }, function (reason) {
                            notificationsService.error("Tree Error", reason);
                            return $q.reject(reason);
                        });
                }
                else {
                    return $q.reject();
                }
            }

            function loadChildren(node, forceReload) {
                //emit treeNodeExpanding event, if a callback object is set on the tree
                emitEvent("treeNodeExpanding", { tree: $scope.tree, node: node });

                //standardising
                if (!node.children) {
                    node.children = [];
                }

                if (forceReload || (node.hasChildren && node.children.length === 0)) {
                    //get the children from the tree service
                    return treeService.loadNodeChildren({ node: node, section: $scope.section, isDialog: $scope.isdialog })
                        .then(function (data) {
                            //emit expanded event
                            emitEvent("treeNodeExpanded", { tree: $scope.tree, node: node, children: data });

                            return $q.when(data);
                        });
                }
                else {
                    emitEvent("treeNodeExpanded", { tree: $scope.tree, node: node, children: node.children });
                    node.expanded = true;

                    return $q.when(node.children);
                }
            }

            /** Returns the css classses assigned to the node (div element) */
            $scope.getNodeCssClass = function (node) {
                if (!node) {
                    return '';
                }

                // TODO: This is called constantly because as a method in a template it's re-evaluated pretty much all the time
                // it would be better if we could cache the processing. The problem is that some of these things are dynamic.

                var css = [];
                if (node.cssClasses) {
                    node.cssClasses.forEach(c => css.push(c));
                }

                return css.join(" ");
            };

            $scope.selectEnabledNodeClass = node =>
                node && node.selected ? 'icon sprTree icon-check green temporary' : '-hidden';

            /* helper to force reloading children of a tree node */
            $scope.loadChildren = (node, forceReload) => loadChildren(node, forceReload);

            /**
              Method called when the options button next to the root node is called.
              The tree doesnt know about this, so it raises an event to tell the parent controller
              about it.
            */
            $scope.options = function (n, ev) {
                emitEvent("treeOptionsClick", { element: $element, node: n, event: ev });
            };

            /**
              Method called when an item is clicked in the tree, this passes the
              DOM element, the tree node object and the original click
              and emits it as a treeNodeSelect element if there is a callback object
              defined on the tree
            */
            $scope.select = function (n, ev) {
                
                if (n.metaData && n.metaData.noAccess === true) {
                    ev.preventDefault();
                    return;
                }

                //on tree select we need to remove the current node -
                // whoever handles this will need to make sure the correct node is selected
                //reset current node selection
                $scope.currentNode = null;

                emitEvent("treeNodeSelect", { element: $element, node: n, event: ev });
            };

            $scope.altSelect = function (n, ev) {
                emitEvent("treeNodeAltSelect", { element: $element, tree: $scope.tree, node: n, event: ev });
            };

            //call the onInit method, if the result is a promise then load the tree after that resolves (if it's not a promise this will just resolve automatically).
            //NOTE: The promise cannot be rejected, else the tree won't be loaded and we'll get exceptions if some API calls syncTree or similar.
            $q.when($scope.onInit(), function (args) {

                //the promise resolution can pass in parameters
                if (args) {
                    if (args.section) {
                        $scope.section = args.section;
                    }
                    if (args.cacheKey) {
                        $scope.cachekey = args.cacheKey;
                    }
                    if (args.customTreeParams) {
                        $scope.customtreeparams = args.customTreeParams;
                    }
                }

                //load the tree
                loadTree().then(function () {
                    //because angular doesn't return a promise for the resolve method, we need to resort to some hackery, else
                    //like normal JS promises we could do resolve(...).then()
                    if (args && args.onLoaded && Utilities.isFunction(args.onLoaded)) {
                        args.onLoaded();
                    }
                });
            });
        }
    };
}

angular.module("umbraco.directives").directive('umbTree', umbTreeDirective);

----
tree/umbcontextdialog/umbcontextdialog.directive.js
(function() {
    'use strict';

    function UmbContextDialog(navigationService, keyboardService, localizationService, overlayService, backdropService) {

        function link($scope) {

            $scope.dialog = {
                confirmDiscardChanges: false
            };

            $scope.outSideClick = function() {
                hide();
            };

            keyboardService.bind("esc", function () {
                hide();
            });

            //ensure to unregister from all events!
            $scope.$on('$destroy', function () {
                keyboardService.unbind("esc");
            });

            function hide() {

                if ($scope.dialog.confirmDiscardChanges) {
                    localizationService.localizeMany(["prompt_unsavedChanges", "prompt_unsavedChangesWarning", "prompt_discardChanges", "prompt_stay"]).then(
                        function (values) {
                            var overlay = {
                                "view": "default",
                                "title": values[0],
                                "content": values[1],
                                "disableBackdropClick": true,
                                "disableEscKey": true,
                                "submitButtonLabel": values[2],
                                "closeButtonLabel": values[3],
                                submit: function () {
                                    overlayService.close();
                                    navigationService.hideDialog();
                                },
                                close: function () {
                                    overlayService.close();
                                }
                            };

                            overlayService.open(overlay);
                        }
                    );
                }
                else {
                    navigationService.hideDialog();
                }
            }
        }

        var directive = {
            restrict: 'E',
            transclude: true,
            templateUrl: "views/components/tree/umbcontextdialog/umb-context-dialog.html",
            scope: {
                dialogTitle: "<",
                currentNode: "<",
                view: "<"
            },
            link: link
        };
        return directive;
    }

    angular.module('umbraco.directives').directive('umbContextDialog', UmbContextDialog);

})();

----
forms/selectonfocus.directive.js
angular.module("umbraco.directives")
  .directive('selectOnFocus', function () {
    return function (scope, el, attrs) {
        $(el).on("click", function () {
            var editmode = $(el).data("editmode");
            //If editmode is true a click is handled like a normal click
            if (!editmode) {
                //Initial click, select entire text
                this.select();
                //Set the edit mode so subsequent clicks work normally
                $(el).data("editmode", true);
            }
        }).
        on("blur", function () {
            //Reset on focus lost
            $(el).data("editmode", false);
        });
    };
  });

----
forms/checklistmodel.directive.js
/*
  
  https://vitalets.github.io/checklist-model/
  <label ng-repeat="role in roles">
    <input type="checkbox" checklist-model="user.roles" checklist-value="role.id"> {{role.text}}
  </label>
*/
angular.module('umbraco.directives')
.directive('checklistModel', ['$parse', '$compile', function($parse, $compile) {
  // contains
  function contains(arr, item) {
    if (Utilities.isArray(arr)) {
      for (var i = 0; i < arr.length; i++) {
        if (Utilities.equals(arr[i], item)) {
          return true;
        }
      }
    }
    return false;
  }

  // add
  function add(arr, item) {
    arr = Utilities.isArray(arr) ? arr : [];
    for (var i = 0; i < arr.length; i++) {
      if (Utilities.equals(arr[i], item)) {
        return arr;
      }
    }
    arr.push(item);
    return arr;
  }

  // remove
  function remove(arr, item) {
    if (Utilities.isArray(arr)) {
      for (var i = 0; i < arr.length; i++) {
        if (Utilities.equals(arr[i], item)) {
          arr.splice(i, 1);
          break;
        }
      }
    }
    return arr;
  }

  // https://stackoverflow.com/a/19228302/1458162
  function postLinkFn(scope, elem, attrs) {
    // compile with `ng-model` pointing to `checked`
    $compile(elem)(scope);

    // getter / setter for original model
    var getter = $parse(attrs.checklistModel);
    var setter = getter.assign;

    // value added to list
    var value = $parse(attrs.checklistValue)(scope.$parent);

    // watch UI checked change
    scope.$watch('checked', function(newValue, oldValue) {
      if (newValue === oldValue) { 
        return;
      } 
      var current = getter(scope.$parent);
      if (newValue === true) {
        setter(scope.$parent, add(current, value));
      } else {
        setter(scope.$parent, remove(current, value));
      }
    });

    // watch original model change
    scope.$parent.$watch(attrs.checklistModel, function(newArr, oldArr) {
      scope.checked = contains(newArr, value);
    }, true);
  }

  return {
    restrict: 'A',
    priority: 1000,
    terminal: true,
    scope: true,
    compile: function(tElement, tAttrs) {
      if (tElement[0].tagName !== 'INPUT' || !tElement.attr('type', 'checkbox')) {
        throw 'checklist-model should be applied to `input[type="checkbox"]`.';
      }

      if (!tAttrs.checklistValue) {
        throw 'You should provide `checklist-value`.';
      }

      // exclude recursion
      tElement.removeAttr('checklist-model');
      
      // local scope var storing individual checkbox model
      tElement.attr('ng-model', 'checked');

      return postLinkFn;
    }
  };
}]);

----
forms/umbautofocus.directive.js
angular.module("umbraco.directives")
    .directive('umbAutoFocus', function($timeout) {

        return function (scope, element, attrs) {
            
            var update = function() {
                //if it uses its default naming
                if (element.val() === "" || attrs.focusOnFilled) {
                    element.trigger("focus");
                }
            };

            attrs.$observe("umbAutoFocus", function (newVal) {
                var enabled = (newVal === "false" || newVal === 0 || newVal === false) ? false : true;
                if (enabled) {
                    $timeout(function() {
                        update();
                    });
                }
            });

        };
});

----
forms/umbradiobutton.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbRadiobutton
@restrict E
@scope

@description
<b>Added in Umbraco version 7.14.0</b> Use this directive to render an umbraco radio button.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-radiobutton
            name="radiobuttonlist"
            value="{{key}}"
            model="true"
            text="{{text}}">
        </umb-radiobutton>

    </div>
</pre>

@param {boolean} model Set to <code>true</code> or <code>false</code> to set the radiobutton to checked or unchecked.
@param {string} inputId Set the <code>id</code> of the radiobutton.
@param {string} value Set the value of the radiobutton.
@param {string} name Set the name of the radiobutton.
@param {string} text Set the text for the radiobutton label.
@param {string} labelKey Set a dictinary/localization string for the checkbox label.
@param {string} serverValidationField Set the <code>val-server-field</code> of the radiobutton.
@param {boolean} disabled Set the radiobutton to be disabled.
@param {boolean} required Set the radiobutton to be required.
@param {callback} onChange Callback when the value of the radiobutton change by interaction.
@param {string} cssClass Set a css class modifier.
@param {string} iconClass Set an icon next to radiobutton.
@param {boolean} disableDirtyCheck Disable checking if the model is dirty.

**/

(function () {
    'use strict';

    function UmbRadiobuttonController($timeout, $attrs, localizationService) {

        var vm = this;

        vm.readonly = false;

        vm.$onInit = onInit;
        vm.change = change;
        vm.click = click;

        function onInit() {
            vm.inputId = vm.inputId || "umb-radio_" + String.CreateGuid();
            vm.disableDirtyCheck =
                $attrs.hasOwnProperty("disableDirtyCheck") &&
                vm.disableDirtyCheck !== '0' &&
                vm.disableDirtyCheck !== 0 &&
                vm.disableDirtyCheck !== 'false' &&
                vm.disableDirtyCheck !== false;
            vm.icon = vm.icon || vm.iconClass || null;

            // If a labelKey is passed let's update the returned text if it's does not contain an opening square bracket [
            if (vm.labelKey) {
                 localizationService.localize(vm.labelKey).then(function (data) {
                      if(data.indexOf('[') === -1){
                        vm.text = data;
                      }
                 });
            }
        }

        function change() {
            if (vm.onChange) {
                $timeout(function () {
                    vm.onChange({ model: vm.model, value: vm.value });
                }, 0);
            }
        }

        function click($event) {
            if (vm.readonly) {
                $event.preventDefault();
                $event.stopPropagation();
            }
        }

        $attrs.$observe('readonly', (value) => {
            vm.readonly = value !== undefined;
        });
    }

    var component = {
        templateUrl: 'views/components/forms/umb-radiobutton.html',
        controller: UmbRadiobuttonController,
        controllerAs: 'vm',
        transclude: true,
        bindings: {
            model: "=",
            inputId: "@",
            value: "@",
            name: "@",
            text: "@",
            labelKey: "@?",
            serverValidationField: "@",
            disabled: "<",
            required: "<",
            onChange: "&?",
            cssClass: "@?",
            iconClass: "@?", // deprecated
            icon: "@?",
            disableDirtyCheck: "=?"
        }
    };

    angular.module('umbraco.directives').component('umbRadiobutton', component);

})();

----
forms/focuswhen.directive.js
angular.module("umbraco.directives").directive('focusWhen', function ($timeout) {
    return {
        restrict: 'A',
        link: function (scope, elm, attrs, ctrl) {

            var delayTimer;

            attrs.$observe("focusWhen", function (newValue) {
                if (newValue === "true" && document.activeelement !== elm[0]) {
                    delayTimer = $timeout(function () {
                        elm[0].focus();
                    });
                }
            });

            scope.$on('$destroy', function() {
                $timeout.cancel(delayTimer);
            });
        }
    };
});

----
forms/hotkey.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:hotkey
**/

angular.module("umbraco.directives")
    .directive('hotkey', function($window, keyboardService, $log, focusService) {

        return function(scope, el, attrs) {

            var options = {};
            var keyCombo = attrs.hotkey;

            if (!keyCombo) {
                //support data binding
                keyCombo = scope.$eval(attrs["hotkey"]);
            }

            function activate() {

                if (keyCombo) {

                    // disable shortcuts in input fields if keycombo is 1 character
                    if (keyCombo.length === 1) {
                        options = {
                            inputDisabled: true
                        };
                    }

                    keyboardService.bind(keyCombo, function() {
                        
                        focusService.rememberFocus();
                        
                        var element = $(el);
                        var activeElementType = document.activeElement.tagName;
                        var clickableElements = ["A", "BUTTON"];

                        if (element.is("a,div,button,input[type='button'],input[type='submit'],input[type='checkbox']") && !element.is(':disabled')) {

                            if (element.is(':visible') || attrs.hotkeyWhenHidden) {

                                if (attrs.hotkeyWhen && attrs.hotkeyWhen === "false") {
                                    return;
                                }

                                // when keycombo is enter and a link or button has focus - click the link or button instead of using the hotkey
                                if (keyCombo === "enter" && clickableElements.indexOf(activeElementType) === 0) {
                                    document.activeElement.trigger( "click" );
                                } else {
                                    element.trigger("click");
                                }

                            }

                        } else {
                            element.trigger("focus");
                        }

                    }, options);

                    el.on('$destroy', function() {
                        keyboardService.unbind(keyCombo);
                    });

                }

            }

            activate();

        };
    });

----
forms/umbsearchfilter.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbSearchFilter
@restrict E
@scope

@description
<b>Added in Umbraco version 8.7.0</b> Use this directive to render an umbraco search filter.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-search-filter
            name="checkboxlist"
            value="{{key}}"
            model="true"
            text="{{text}}">
        </umb-search-filter>

    </div>
</pre>

@param {boolean} model Set to <code>true</code> or <code>false</code> to set the checkbox to checked or unchecked.
@param {string} inputId Set the <code>id</code> of the checkbox.
@param {string} text Set the text for the checkbox label.
@param {string} labelKey Set a dictionary/localization string for the checkbox label
@param {callback} onChange Callback when the value of the searchbox change.
@param {callback} onBack Callback when clicking back button.
@param {boolean} autoFocus Add autofocus to the input field
@param {boolean} preventSubmitOnEnter Set the enter prevent directive or not
@param {boolean} showBackButton Show back button on search

**/

(function () {
    'use strict';

    function UmbSearchFilterController($timeout, localizationService) {

        var vm = this;

        vm.$onInit = onInit;
        vm.change = change;
        vm.keyDown = keyDown;
        vm.blur = blur;
        vm.goBack = goBack;

        function onInit() {
            vm.inputId = vm.inputId || "umb-search-filter_" + String.CreateGuid();
            vm.autoFocus = Object.toBoolean(vm.autoFocus) === true;
            vm.preventSubmitOnEnter = Object.toBoolean(vm.preventSubmitOnEnter) === true;
            vm.showBackButton = Object.toBoolean(vm.showBackButton) === true;

            // If a labelKey is passed let's update the returned text if it's does not contain an opening square bracket [
            if (vm.labelKey) {
                 localizationService.localize(vm.labelKey).then(data => {
                      if (data.indexOf('[') === -1){
                         vm.text = data;
                      }
                 });
            }
        }

        function goBack() {
            if (vm.onBack) {
                vm.onBack();
            }
        }

        function change() {
            if (vm.onChange) {
                $timeout(function () {
                    vm.onChange({ model: vm.model, value: vm.value });
                }, 0);
            }
        }

        function blur() {
            if (vm.onBlur) {
                vm.onBlur();
            }
        }

        function keyDown(evt) {
            //13: enter
            switch (evt.keyCode) {
                case 13:
                    if (vm.onSearch) {
                        vm.onSearch();
                    }
                    break;
            }
        }
    }

    var component = {
        templateUrl: 'views/components/forms/umb-search-filter.html',
        controller: UmbSearchFilterController,
        controllerAs: 'vm',
        transclude: true,
        bindings: {
            model: "=",
            inputId: "@",
            text: "@",
            labelKey: "@?",
            onChange: "&?",
            onSearch: "&?",
            onBlur: "&?",
            onBack: "&?",
            autoFocus: "<?",
            preventSubmitOnEnter: "<?",
            showBackButton: "<?",
            cssClass: "@?"
        }
    };

    angular.module('umbraco.directives').component('umbSearchFilter', component);

})();

----
forms/validwhen.directive.js
angular.module("umbraco.directives").directive('validWhen', function () {
    return {
        require: 'ngModel',
        restrict: 'A',
        link: function (scope, element, attr, ngModel) {

            attr.$observe("validWhen", function (newValue) {
                ngModel.$setValidity("validWhen", newValue === "true");
            });
        }
    };
});

----
forms/contenteditable.directive.js
angular.module("umbraco.directives")
.directive("contenteditable", function() {
  
  return {
    require: "ngModel",
    link: function(scope, element, attrs, ngModel) {

      function read() {
        ngModel.$setViewValue(element.html());
      }

      ngModel.$render = function() {
        element.html(ngModel.$viewValue || "");
      };

      
      element.on("focus", function(){
          
          var range = document.createRange();
          range.selectNodeContents(element[0]);

          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);

      });

      element.on("blur keyup change", function() {
        scope.$apply(read);
      });
    }

  }; 

});
----
forms/prevententersubmit.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:preventEnterSubmit
* @description prevents a form from submitting when the enter key is pressed on an input field
**/
angular.module("umbraco.directives")
    .directive('preventEnterSubmit', function() {
        return function(scope, element, attrs) {

            var enabled = true;
            //check if there's a value for the attribute, if there is and it's false then we conditionally don't 
            //prevent default.
            if (attrs.preventEnterSubmit) {
                attrs.$observe("preventEnterSubmit", function (newVal) {
                    enabled = (newVal === "false" || newVal === 0 || newVal === false) ? false : true;
                });
            }

            $(element).on("keypress", function (event) {
                if (event.which === 13 && enabled === true) {
                    event.preventDefault();
                }
            });
        };
    });
----
forms/umbrawmodel.directive.js
/*
example usage: <textarea json-edit="myObject" rows="8" class="form-control"></textarea>

jsonEditing is a string which we edit in a textarea. we try parsing to JSON with each change. when it is valid, propagate model changes via ngModelCtrl

use isolate scope to prevent model propagation when invalid - will update manually. cannot replace with template, or will override ngModelCtrl, and not hide behind facade

will override element type to textarea and add own attribute ngModel tied to jsonEditing
 */

angular.module("umbraco.directives")
    .directive('umbRawModel', function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            template: '<textarea ng-model="jsonEditing"></textarea>',
            replace: true,
            scope: {
                model: '=umbRawModel',
                validateOn: '='
            },
            link: function (scope, element, attrs, ngModelCtrl) {

                function setEditing(value) {
                    scope.jsonEditing = Utilities.copy(jsonToString(value));
                }

                function updateModel(value) {
                    scope.model = stringToJson(value);
                }

                function setValid() {
                    ngModelCtrl.$setValidity('json', true);
                }

                function setInvalid() {
                    ngModelCtrl.$setValidity('json', false);
                }

                function stringToJson(text) {
                    try {
                        return Utilities.fromJson(text);
                    } catch (err) {
                        setInvalid();
                        return text;
                    }
                }

                function jsonToString(object) {
                    // better than JSON.stringify(), because it formats + filters $$hashKey etc.
                    // NOTE that this will remove all $-prefixed values
                    return Utilities.toJson(object, true);
                }

                function isValidJson(model) {
                    var flag = true;
                    try {
                        Utilities.fromJson(model)
                    } catch (err) {
                        flag = false;
                    }
                    return flag;
                }

                //init
                setEditing(scope.model);

                var onInputChange = function (newval, oldval) {
                    if (newval !== oldval) {
                        if (isValidJson(newval)) {
                            setValid();
                            updateModel(newval);
                        } else {
                            setInvalid();
                        }
                    }
                };

                if (scope.validateOn) {
                    element.on(scope.validateOn, function () {
                        scope.$apply(function () {
                            onInputChange(scope.jsonEditing);
                        });
                    });
                } else {
                    //check for changes going out
                    scope.$watch('jsonEditing', onInputChange, true);
                }

                //check for changes coming in
                scope.$watch('model', function (newval, oldval) {
                    if (newval !== oldval) {
                        setEditing(newval);
                    }
                }, true);

            }
        };
    });

----
forms/_readme.md
#Forms

Directives used to enhance form elements.

----
forms/umbfocuslock.directive.js
(function() {
    'use strict';

    function FocusLock($timeout, $rootScope, angularHelper) {

        // If the umb-auto-focus directive is in use we respect that by leaving the default focus on it instead of choosing the first focusable element using this function
        function getAutoFocusElement (elements) {
            var elmentWithAutoFocus = null;

            elements.forEach((element) => {
                if(element.getAttribute('umb-auto-focus') === 'true') {
                    elmentWithAutoFocus = element;
                }
            });

            return elmentWithAutoFocus;
        }

        function link(scope, element) {
            var target = element[0];
            var focusableElements;
            var firstFocusableElement;
            var lastFocusableElement;
            var infiniteEditorsWrapper;
            var infiniteEditors;
            var disconnectObserver = false;
            var closingEditor = false;

            if(!$rootScope.lastKnownFocusableElements){
                $rootScope.lastKnownFocusableElements = [];
            }

            $rootScope.lastKnownFocusableElements.push(document.activeElement);

            // List of elements that can be focusable within the focus lock
            var focusableElementsSelector = '[role="button"], a[href]:not([disabled]):not(.ng-hide), button:not([disabled]):not(.ng-hide), textarea:not([disabled]):not(.ng-hide), input:not([disabled]):not(.ng-hide):not([type="hidden"]), select:not([disabled]):not(.ng-hide)';

            function getDomNodes(){
                infiniteEditorsWrapper = document.querySelector('.umb-editors');
                if(infiniteEditorsWrapper) {
                    infiniteEditors = Array.from(infiniteEditorsWrapper.querySelectorAll('.umb-editor') || []);
                }
            }

            function getFocusableElements(targetElm) {
                var elm = targetElm ? targetElm : target;

                // Filter out elements that are children of parents with the .ng-hide class
                focusableElements = [...elm.querySelectorAll(focusableElementsSelector)].filter(elm => !elm.closest('.ng-hide'));

                // Set first and last focusable elements
                firstFocusableElement = focusableElements[0];
                lastFocusableElement = focusableElements[focusableElements.length - 1];
            }

            function handleKeydown(event) {
                var isTabPressed = (event.key === 'Tab' || event.keyCode === 9);

                if (!isTabPressed){
                    return;
                }

                // If shift + tab key
                if(event.shiftKey){
                    // Set focus on the last focusable element if shift+tab are pressed meaning we go backwards
                    if(document.activeElement === firstFocusableElement){
                        lastFocusableElement.focus();
                        event.preventDefault();
                    }
                }
                // Else only the tab key is pressed
                else{
                    // Using only the tab key we set focus on the first focusable element mening we go forward
                    if (document.activeElement === lastFocusableElement) {
                        firstFocusableElement.focus();
                        event.preventDefault();
                    }
                }
            }

            function clearLastKnownFocusedElements() {
                $rootScope.lastKnownFocusableElements = [];
            }

            function setElementFocus() {
                var defaultFocusedElement = getAutoFocusElement(focusableElements);
                var lastKnownElement;

                // If an infinite editor is being closed then we reset the focus to the element that triggered the the overlay
                if(closingEditor){

                    // If there is only one editor open, search for the "editor-info" inside it and set focus on it
                    // This is relevant when a property editor has been selected and the editor where we selected it from
                    // is closed taking us back to the first layer
                    // Otherwise set it to the last element in the lastKnownFocusedElements array
                    if(infiniteEditors && infiniteEditors.length === 1){
                        var editorInfo = infiniteEditors[0].querySelector('.editor-info');
                        if(infiniteEditors && infiniteEditors.length === 1 && editorInfo !== null) {
                            lastKnownElement = editorInfo;

                            // Clear the array
                            clearLastKnownFocusedElements();
                        }
                    }
                    else {
                        var lastItemIndex = $rootScope.lastKnownFocusableElements.length - 1;
                        lastKnownElement = $rootScope.lastKnownFocusableElements[lastItemIndex];

                        // Remove the last item from the array so we always set the correct lastKnowFocus for each layer
                        $rootScope.lastKnownFocusableElements.splice(lastItemIndex, 1);
                    }

                    // Update the lastknowelement variable here
                    closingEditor = false;
                }

                // 1st - we check for any last known element - Usually the element the trigger the opening of a new layer
                // If it exists it will receive fous
                // 2nd - We check to see if a default focus has been set using the umb-auto-focus directive. If not we set focus on
                // the first focusable element
                // 3rd - Otherwise put the focus on the default focused element
                if(lastKnownElement){
                    lastKnownElement.focus();
                }
                else if(defaultFocusedElement === null ){
                    // If the first focusable elements are either items from the umb-sub-views-nav menu or the umb-button-ellipsis we most likely want to start the focus on the second item
                    var avoidStartElm = focusableElements.findIndex(elm => elm.classList.contains('umb-button-ellipsis') || elm.classList.contains('umb-sub-views-nav-item__action') || elm.classList.contains('umb-tab-button'));

                    if(avoidStartElm === 0) {
                        focusableElements[1].focus();
                    }
                    else {
                        firstFocusableElement.focus();
                    }
                }
                else {
                    defaultFocusedElement.focus();
                }
            }

            function observeDomChanges() {
                // Watch for DOM changes - so we can refresh the focusable elements if an element
                // changes from being disabled to being enabled for instance
                var observer = new MutationObserver(_.debounce(domChange, 200));

                // Options for the observer (which mutations to observe)
                var config = { attributes: true, childList: true, subtree: true};

                // Whenever the DOM changes ensure the list of focused elements is updated
                function domChange() {
                    getFocusableElements();
                }

                // Start observing the target node for configured mutations
                observer.observe(target, config);

                // Disconnect observer
                if(disconnectObserver){
                    observer.disconnect();
                }
            }

            function cleanupEventHandlers() {
                //if we're in infinite editing mode
                if(infiniteEditors.length > 0) {
                    var activeEditor = infiniteEditors[infiniteEditors.length - 1];
                    var inactiveEditors = infiniteEditors.filter(editor => editor !== activeEditor);

                    if(inactiveEditors.length > 0) {
                        for (var index = 0; index < inactiveEditors.length; index++) {
                            var inactiveEditor = inactiveEditors[index];

                            // Remove event handlers from inactive editors
                            inactiveEditor.removeEventListener('keydown', handleKeydown);
                        }
                    }
                    else {
                        // Why is this one only begin called if there is no other infinite editors, wouldn't it make sense always to clean this up?
                        // Remove event handlers from the active editor
                        activeEditor.removeEventListener('keydown', handleKeydown);
                    }
                }
            }

            function onInit(targetElm) {
                $timeout(() => {
                        // Fetch the DOM nodes we need
                        getDomNodes();

                        cleanupEventHandlers();

                        getFocusableElements(targetElm);

                        if(focusableElements.length > 0) {

                            observeDomChanges();

                            setElementFocus();

                            //  Handle keydown
                            target.addEventListener('keydown', handleKeydown);
                        }
                }, 500);
            }

            onInit();

            // If more than one editor is still open then re-initialize otherwise remove the event listener
            scope.$on('$destroy', function () {
                // Make sure to disconnect the observer so we potentially don't end up with having many active ones
                disconnectObserver = true;

                if(infiniteEditors && infiniteEditors.length > 1) {
                    // Pass the correct editor in order to find the focusable elements
                    var newTarget = infiniteEditors[infiniteEditors.length - 2];

                    if(infiniteEditors.length > 1) {
                        // Setting closing till true will let us re-apply the last known focus to then opened layer that then becomes
                        // active
                        closingEditor = true;

                        onInit(newTarget);

                        return;
                    }
                }

                // Clear lastKnownFocusableElements
                clearLastKnownFocusedElements();

                // Cleanup event handler
                target.removeEventListener('keydown', handleKeydown);
            });
        }

        var directive = {
            restrict: 'A',
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbFocusLock', FocusLock);

})();

----
forms/resizetocontent.directive.js
/**
 * @ngdoc directive
 * @name umbraco.directives.directive:resizeToContent
 * @element div
 * @function
 *
 * @description
 * Resize iframe's automatically to fit to the content they contain
 *
 * @example
   <example module="umbraco.directives">
     <file name="index.html">
         <iframe resize-to-content src="meh.html"></iframe>
     </file>
   </example>
 */
angular.module("umbraco.directives")
  .directive('resizeToContent', function ($window, $timeout) {
    return function (scope, el, attrs) {
       var iframe = el[0];
       var iframeWin = iframe.contentWindow || iframe.contentDocument.parentWindow;
       if (iframeWin.document.body) {

          $timeout(function(){
              var height = iframeWin.document.documentElement.scrollHeight || iframeWin.document.body.scrollHeight;
              el.height(height);
          }, 3000);
       }
    };
  });

----
forms/umbselectwhen.directive.js
(function() {
    'use strict';

    function SelectWhen($timeout) {

        function link(scope, el, attr, ctrl) {

            attr.$observe("umbSelectWhen", function(newValue) {
                if (newValue === "true") {
                    $timeout(function() {
                        el.select();
                    });
                }
            });

        }

        var directive = {
            restrict: 'A',
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbSelectWhen', SelectWhen);

})();

----
forms/hexbackgroundcolor.directive.js

/**
* @ngdoc directive
* @name umbraco.directives.directive:hexBgColor
* @restrict A
* @description Used to set a hex background color on an element, this will detect valid hex and when it is valid it will set the color, otherwise
* a color will not be set.
**/
function hexBgColor() {
    return {
        restrict: "A",
        link: function (scope, element, attr, formCtrl) {

            function setBackgroundColor(color) {
                element[0].style.backgroundColor = "#" + color;
            }

            // Only add inline hex background color if defined and not "true".
            if (attr.hexBgInline === undefined || (attr.hexBgInline !== undefined && attr.hexBgInline === "true")) {

                var origColor = null;
                if (attr.hexBgOrig) {
                    // Set the orig based on the attribute if there is one.
                    origColor = attr.hexBgOrig;
                }

                attr.$observe("hexBgColor", function (newVal) {
                    if (newVal) {
                        if (!origColor) {
                            // Get the orig color before changing it.
                            origColor = element.css("border-color");
                        }
                        // Is it a regular hex value - (#)AABBCC ?
                        var match = newVal.match(/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i);
                        if (match && match.length) {
                            setBackgroundColor(match[1]);
                            return;
                        }
                        // Is it a hexa value - (#)AABBCCDD ?
                        match = newVal.match(/^#?([0-9a-f]{4}|[0-9a-f]{8})$/i);
                        if (match && match.length) {
                            setBackgroundColor(match[1]);
                            return;
                        }
                    }

                    setBackgroundColor(origColor);
                });
            }
        }
    };
}
angular.module('umbraco.directives').directive("hexBgColor", hexBgColor);

----
forms/preventdefault.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:preventDefault

@description
Use this directive to prevent default action of an element. Effectively implementing <a href="https://api.jquery.com/event.preventdefault/">jQuery's preventdefault</a>

<h3>Markup example</h3>

<pre>
    <a href="https://umbraco.com" prevent-default>Don't go to Umbraco.com</a>
</pre>

**/
angular.module("umbraco.directives")
    .directive('preventDefault', function() {
        return function(scope, element, attrs) {

            var enabled = true;
            //check if there's a value for the attribute, if there is and it's false then we conditionally don't
            //prevent default.
            if (attrs.preventDefault) {
                attrs.$observe("preventDefault", function (newVal) {
                    enabled = (newVal === "false" || newVal === 0 || newVal === false) ? false : true;
                });
            }

            $(element).on("click", function (event) {
                if (event.metaKey || event.ctrlKey) {
                    return;
                }
                else {
                    if (enabled === true) {
                        event.preventDefault();
                    }
                }
            });
        };
    });

----
forms/umbcheckbox.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbCheckbox
@restrict E
@scope

@description
<b>Added in Umbraco version 7.14.0</b> Use this directive to render an umbraco checkbox.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-checkbox
            name="checkboxlist"
            value="{{key}}"
            model="true"
            text="{{text}}">
        </umb-checkbox>

    </div>
</pre>

@param {boolean} model Set to <code>true</code> or <code>false</code> to set the checkbox to checked or unchecked.
@param {string} inputId Set the <code>id</code> of the checkbox.
@param {string} value Set the value of the checkbox.
@param {string} name Set the name of the checkbox.
@param {string} text Set the text for the checkbox label.
@param {string} labelKey Set a dictinary/localization string for the checkbox label
@param {string} serverValidationField Set the <code>val-server-field</code> of the checkbox.
@param {boolean} disabled Set the checkbox to be disabled.
@param {boolean} required Set the checkbox to be required.
@param {callback} onChange Callback when the value of the checkbox change by interaction.
@param {string} cssClass Set a css class modifier.
@deprecated @param {string} iconClass Set an icon next to checkbox. Use "icon" parameter instead.
@param {string} icon Set an icon next to checkbox.
@param {boolean} disableDirtyCheck Disable checking if the model is dirty.

**/

(function () {
    'use strict';

    function UmbCheckboxController($timeout, $attrs, localizationService) {

        var vm = this;

        vm.readonly = false;

        vm.$onInit = onInit;
        vm.change = change;
        vm.click = click;

        function onInit() {
            vm.inputId = vm.inputId || "umb-check_" + String.CreateGuid();
            vm.disableDirtyCheck =
                $attrs.hasOwnProperty("disableDirtyCheck") &&
                vm.disableDirtyCheck !== '0' &&
                vm.disableDirtyCheck !== 0 &&
                vm.disableDirtyCheck !== 'false' &&
                vm.disableDirtyCheck !== false;
            vm.icon = vm.icon || vm.iconClass || null;

            // If a labelKey is passed let's update the returned text if it's does not contain an opening square bracket [
            if (vm.labelKey) {
                 localizationService.localize(vm.labelKey).then(function (data) {
                      if(data.indexOf('[') === -1){
                        vm.text = data;
                      }
                 });
            }
        }

        function change() {
            if (vm.onChange) {
                $timeout(function () {
                    vm.onChange({ model: vm.model, value: vm.value });
                }, 0);
            }
        }

        function click ($event) {
            if (vm.readonly) {
                $event.preventDefault();
                $event.stopPropagation();
            }
        }

        $attrs.$observe('readonly', (value) => {
            vm.readonly = value !== undefined;
        });
    }

    var component = {
        templateUrl: 'views/components/forms/umb-checkbox.html',
        controller: UmbCheckboxController,
        controllerAs: 'vm',
        transclude: true,
        bindings: {
            model: "=",
            inputId: "@",
            value: "@",
            name: "@",
            text: "@",
            labelKey: "@?",
            serverValidationField: "@",
            disabled: "<",
            required: "<",
            onChange: "&?",
            cssClass: "@?",
            iconClass: "@?", // deprecated
            icon: "@?",
            disableDirtyCheck: "=?"
        }
    };

    angular.module('umbraco.directives').component('umbCheckbox', component);

})();

----
forms/fixnumber.directive.js
﻿
/**
* @ngdoc directive
* @name umbraco.directives.directive:fixNumber
* @restrict A
* @description Used in conjunction with type='number' input fields to ensure that the bound value is converted to a number when using ng-model
*  because normally it thinks it's a string and also validation doesn't work correctly due to an angular bug.
**/
function fixNumber($parse) {
    return {
        restrict: "A",
        require: "ngModel",

        link: function (scope, elem, attrs, ctrl) {

            //parse ngModel onload
            var modelVal = scope.$eval(attrs.ngModel);
            if (modelVal) {
                var asNum = parseFloat(modelVal, 10);
                if (!isNaN(asNum)) {
                    $parse(attrs.ngModel).assign(scope, asNum);
                }
            }

            //always return an int to the model
            ctrl.$parsers.push(function (value) {
                if (value === 0) {
                    return 0;
                }
                return parseFloat(value || '', 10);
            });

            //always try to format the model value as an int
            ctrl.$formatters.push(function (value) {
                if (Utilities.isString(value)) {
                    return parseFloat(value, 10);
                }
                return value;
            });

            //This fixes this angular issue: 
            //https://github.com/angular/angular.js/issues/2144
            // which doesn't actually validate the number input properly since the model only changes when a real number is entered
            // but the input box still allows non-numbers to be entered which do not validate (only via html5)
            if (typeof elem.prop('validity') === 'undefined') {
                return;
            }

            elem.on('input', function (e) {
                var validity = elem.prop('validity');
                scope.$apply(function () {
                    ctrl.$setValidity('number', !validity.badInput);
                });
            });
        }
    };
}
angular.module('umbraco.directives').directive("fixNumber", fixNumber);

----
forms/umbautoresize.directive.js
angular.module("umbraco.directives")
    .directive('umbAutoResize', function ($timeout) {
        return {
            require: ["^?umbTabs", "ngModel"],
            link: function (scope, element, attr, controllersArr) {

                var domEl = element[0];
                var domElType = domEl.type;
                var umbTabsController = controllersArr[0];
                var ngModelController = controllersArr[1];

                function resizeInput() {

                    if (domEl.scrollWidth !== domEl.clientWidth) {
                        if (ngModelController.$modelValue) {
                            element.width(domEl.scrollWidth);
                        }
                    }

                    // if the element is hidden the width will be 0 even though it has a value. 
                    // This could happen if the element is hidden in a tab.
                    if (ngModelController.$modelValue && domEl.clientWidth === 0) {
                        element.width('auto');
                    }

                    if (!ngModelController.$modelValue && attr.placeholder) {
                        attr.$set('size', attr.placeholder.length);
                        element.width('auto');
                    }

                }

                function resizeTextarea() {
                    if (domEl.scrollHeight !== domEl.clientHeight) {
                        element.height(domEl.scrollHeight);
                    }
                }

                var update = function (force) {
                    if (force === true) {
                        if (domElType === "textarea") {
                            element.height(0);
                        } else if (domElType === "text") {
                            element.width(0);
                        }
                    }

                    if (domElType === "textarea") {
                        resizeTextarea();
                    } else if (domElType === "text") {
                        resizeInput();
                    }
                };

                //listen for tab changes
                if (umbTabsController != null) {
                    umbTabsController.onTabShown(function (args) {
                        update();
                    });
                }

                // listen for ng-model changes
                var unbindModelWatcher = scope.$watch(function () {
                    return ngModelController.$modelValue;
                }, function (newValue) {
                    $timeout(
                        function () {
                            update(true);
                        }
                    );
                });

                scope.$on('$destroy', function () {
                    element.off('keyup keydown keypress change', update);
                    element.off('blur', update(true));
                    unbindModelWatcher();
                });
            }
        };
    });

----
buttons/umbbuttonellipsis.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbButtonEllipsis
@restrict E
@scope

@description
<b>Added in Umbraco version 8.7.0</b> Use this directive to render an umbraco ellipsis.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-button-ellipsis
            text="{{text}}"
            labelKey="{{labelKey}}"
            action="{{vm.open()}}"
            >
        </umb-button-ellipsis>

    </div>
</pre>

@param {callback} action Callback when the value of the checkbox changes through interaction.
@param {string} text Set the text for the checkbox label.
@param {string=} labelKey Set a dictionary/localization string for the checkbox label
@param {string=} cssClass Set a css class modifier
@param {string=} color Set a hex code e.g. <code>#f5c1bc</code>. <code>#000000</code> by default
@param {boolean=} showText Set to <code>true</code> to show the text. <code>false</code> by default
@param {string=} element Highlights a DOM-element (HTML selector) e.g. "my-div-name"
@param {string=} state Set the initial state of the component. To have it hidden use <code>hidden</code>
@param {string=} mode Set the mode, which decides how to style the component. "small" and "tab" are currently supported
**/

(function () {
    'use strict';

    function UmbButtonEllipsis($timeout, localizationService) {

        var vm = this;

        vm.$onInit = onInit;
        vm.clickButton = clickButton;

        function onInit() {
            setText();
            setColor();
        }

        function clickButton(event) {
            if(vm.action) {
                vm.action({$event: event});
            }
        }

        function setText() {
            if (vm.labelKey) {
                localizationService.localize(vm.labelKey).then(function (data) {
                    // If a labelKey is passed let's update the returned text if it's does not contain an opening square bracket [
                     if(data.indexOf('[') === -1){
                       vm.text = data;
                     }
                });
           }
        }

        function setColor() {
            vm.color = vm.color ? vm.color : '#000000';
        }
    }

    var component = {
        templateUrl: 'views/components/buttons/umb-button-ellipsis.html',
        controller: UmbButtonEllipsis,
        controllerAs: 'vm',
        transclude: true,
        bindings: {
            text: "@",
            labelKey: "@?",
            action: "&",
            cssClass: "@?",
            color: "@?",
            showText: "<?",
            element: "@?",
            state: "@?",
            mode: "@?"
        }
    };

    angular.module('umbraco.directives').component('umbButtonEllipsis', component);

})();

----
buttons/umbbuttongroup.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbButtonGroup
@restrict E
@scope

@description
Use this directive to render a button with a dropdown of alternative actions.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-button-group
           ng-if="vm.buttonGroup"
           default-button="vm.buttonGroup.defaultButton"
           sub-buttons="vm.buttonGroup.subButtons"
           direction="down"
           float="right">
        </umb-button-group>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;

            vm.buttonGroup = {
                defaultButton: {
                    labelKey: "general_defaultButton",
                    hotKey: "ctrl+d",
                    hotKeyWhenHidden: true,
                    handler: function() {
                        // do magic here
                    }
                },
                subButtons: [
                    {
                        labelKey: "general_subButton",
                        hotKey: "ctrl+b",
                        hotKeyWhenHidden: true,
                        handler: function() {
                            // do magic here
                        }
                    }
                ]
            };
        }

        angular.module("umbraco").controller("My.Controller", Controller);

    })();
</pre>

<h3>Button model description</h3>
<ul>
    <li>
        <strong>labekKey</strong>
        <small>(string)</small> -
        Set a localization key to make a multi lingual button ("general_buttonText").
    </li>
    <li>
        <strong>hotKey</strong>
        <small>(array)</small> -
        Set a keyboard shortcut for the button ("ctrl+c").
    </li>
    <li>
        <strong>hotKeyWhenHidden</strong>
        <small>(boolean)</small> -
        As a default the hotkeys only works on elements visible in the UI. Set to <code>true</code> to set a hotkey on the hidden sub buttons.
    </li>
    <li>
        <strong>handler</strong>
        <small>(callback)</small> -
        Set a callback to handle button click events.
    </li>
</ul>

@param {object} defaultButton The model of the default button.
@param {array} subButtons Array of sub buttons.
@param {string=} state Set a progress state on the button ("init", "busy", "success", "error").
@param {string=} direction Set the direction of the dropdown ("up", "down").
@param {string=} float Set the float of the dropdown. ("left", "right").
**/
(function () {
  'use strict';

  function ButtonGroupDirective() {

    function controller($scope) {
      $scope.toggleStyle = null;
      $scope.blockElement = false;

      var buttonStyle = $scope.buttonStyle;
      if (buttonStyle) {
        // Make it possible to pass in multiple styles
        if (buttonStyle.startsWith("[") && buttonStyle.endsWith("]")) {
          // when using an attr it will always be a string so we need to remove square brackets and turn it into and array
          var withoutBrackets = buttonStyle.replace(/[\[\]']+/g, '');
          // split array by , + make sure to catch whitespaces
          var array = withoutBrackets.split(/\s?,\s?/g);

          Utilities.forEach(array, item => {
            if (item === "block") {
              $scope.blockElement = true;
            } else {
              $scope.toggleStyle = ($scope.toggleStyle ? $scope.toggleStyle + " " : "") + "btn-" + item;
            }
          });
        } else {
          if (buttonStyle === "block") {
            $scope.blockElement = true;
          } else {
            $scope.toggleStyle = "btn-" + buttonStyle;
          }
        }
      }
    }

    function link(scope) {
      scope.dropdown = {
        isOpen: false
      };

      scope.toggleDropdown = function () {
        scope.dropdown.isOpen = !scope.dropdown.isOpen;
      };

      scope.closeDropdown = function () {
        scope.dropdown.isOpen = false;
      };

      scope.executeMenuItem = function (subButton) {
        subButton.handler();
        scope.closeDropdown();
      };
    }

    var directive = {
      restrict: 'E',
      replace: true,
      templateUrl: 'views/components/buttons/umb-button-group.html',
      controller: controller,
      scope: {
        defaultButton: "=",
        subButtons: "=",
        state: "=?",
        direction: "@?",
        float: "@?",
        buttonStyle: "@?",
        size: "@?",
        icon: "@?",
        label: "@?",
        labelKey: "@?",
        disabled: "<?"
      },
      link: link
    };

    return directive;
  }

  angular.module('umbraco.directives').directive('umbButtonGroup', ButtonGroupDirective);
})();

----
buttons/umbbutton.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbButton
@restrict E
@scope

@description
Use this directive to render an umbraco button. The directive can be used to generate all types of buttons, set type, style, translation, shortcut and much more.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-button
            action="vm.clickButton()"
            type="button"
            button-style="action"
            state="vm.buttonState"
            shortcut="ctrl+c"
            label="My button"
            disabled="vm.buttonState === 'busy'">
        </umb-button>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller(myService) {

            var vm = this;
            vm.buttonState = "init";

            vm.clickButton = clickButton;

            function clickButton() {

                vm.buttonState = "busy";

                myService.clickButton().then(function() {
                    vm.buttonState = "success";
                }, function() {
                    vm.buttonState = "error";
                });

            }
        }

        angular.module("umbraco").controller("My.Controller", Controller);

    })();
</pre>

@param {callback} action The button action which should be performed when the button is clicked.
@param {string=} href Url/Path to navigato to. (requires "type" to be set to "link")
@param {string=} type Set the button type ("button", "link", "submit").
@param {string=} buttonStyle Set the style of the button. The directive uses the default bootstrap styles ("primary", "info", "success", "warning", "danger", "inverse", "link", "block"). Pass in array to add multple styles [success,block].
@param {string=} state Set a progress state on the button ("init", "busy", "success", "error").
@param {string=} shortcut Set a keyboard shortcut for the button ("ctrl+c").
@param {string=} label Set the button label.
@param {string=} labelKey Set a localization key to make a multi-lingual button ("general_buttonText").
@param {string=} icon Set a button icon.
@param {string=} size Set a button size ("xs", "m", "l", "xl").
@param {boolean=} disabled Set to <code>true</code> to disable the button.
@param {boolean=} addEllipsis Adds an ellipsis character (…) to the button label which means the button will open a dialog or prompt the user for more information.
@param {boolean=} showCaret Shows a caret on the right side of the button label
@param {boolean=} autoFocus add autoFocus to the button
@param {boolean=} hasPopup Used to expose to the accessibility API whether the button will trigger a popup or not
@param {boolean=} isExpanded Used to add an aria-expanded attribute and expose whether the button controls collapsible content

**/

(function () {
    'use strict';

    angular
        .module('umbraco.directives')
        .component('umbButton', {
            transclude: true,
            templateUrl: 'views/components/buttons/umb-button.html',
            controller: UmbButtonController,
            controllerAs: 'vm',
            bindings: {
                action: "&?",
                href: "@?",
                hrefTarget: "@?",
                type: "@",
                buttonStyle: "@?",
                state: "<?",
                shortcut: "@?",
                shortcutWhenHidden: "@",
                label: "@?",
                labelKey: "@?",
                icon: "@?",
                disabled: "<?",
                size: "@?",
                alias: "@?",
                addEllipsis: "@?",
                showCaret: "@?",
                autoFocus: "<?",
                hasPopup: "@?",
                isExpanded: "<?"
            }
        });

    // TODO: This doesn't seem necessary?
    UmbButtonController.$inject = ['$timeout', 'localizationService'];

    function UmbButtonController($timeout, localizationService) {

        var vm = this;

        vm.$onInit = onInit;
        vm.$onChanges = onChanges;
        vm.clickButton = clickButton;

        function onInit() {

            vm.blockElement = false;
            vm.style = null;
            vm.innerState = "init";
            vm.generalActions = vm.labelKey === "general_actions";

            if (!vm.type) {
                vm.type = "button"; // set the default
            }

            vm.buttonLabel = vm.label;
            // is this a primary button style (i.e. anything but an 'info' button)?
            vm.isPrimaryButtonStyle = vm.buttonStyle && vm.buttonStyle !== 'info';

            if (vm.buttonStyle) {

                // make it possible to pass in multiple styles
                if (vm.buttonStyle.startsWith("[") && vm.buttonStyle.endsWith("]")) {

                    // when using an attr it will always be a string so we need to remove square brackets
                    // and turn it into and array
                    var withoutBrackets = vm.buttonStyle.replace(/[\[\]']+/g,'');
                    // split array by , + make sure to catch whitespaces
                    var array = withoutBrackets.split(/\s?,\s?/g);

                    Utilities.forEach(array, item => {
                        vm.style = vm.style + " " + "btn-" + item;
                        if (item === "block") {
                            vm.blockElement = true;
                        }
                    });

                } else {
                    vm.style = "btn-" + vm.buttonStyle;
                    if (vm.buttonStyle === "block") {
                        vm.blockElement = true;
                    }
                }

            }

            setButtonLabel();

        }

        function onChanges(changes) {

            // watch for state changes
            if (changes.state) {
                if (changes.state.currentValue) {
                    vm.innerState = changes.state.currentValue;
                }
                if (changes.state.currentValue === 'success' || changes.state.currentValue === 'error') {
                    // set the state back to 'init' after a success or error
                    $timeout(function () {
                        vm.innerState = 'init';
                    }, 2000);
                }
            }

            // watch for disabled changes
            if (changes.disabled) {
                if (changes.disabled.currentValue) {
                    vm.disabled = changes.disabled.currentValue;
                }
            }

            // watch for label changes
            if (changes.label && changes.label.currentValue) {
                vm.buttonLabel = changes.label.currentValue;
                setButtonLabel();
            }

            // watch for label key changes
            if (changes.labelKey && changes.labelKey.currentValue) {
                setButtonLabel();
            }

            // watch for type changes
            if (changes.type) {
                if (!vm.type) {
                    vm.type = "button";// set the default
                }
            }

        }

        function clickButton(event) {
            if (vm.action) {
                vm.action({$event: event});
            }
        }

        function setButtonLabel() {
            // if the button opens a dialog add "..." to the label
            if (vm.addEllipsis === "true") {
                vm.buttonLabel = vm.buttonLabel + "...";
            }

            // look up localization key
            if (vm.labelKey) {
                localizationService.localize(vm.labelKey).then(value => {
                    vm.buttonLabel = value;
                    // if the button opens a dialog add "..." to the label
                    if (vm.addEllipsis === "true") {
                        vm.buttonLabel = vm.buttonLabel + "...";
                    }
                });
            }
        }

    }

})();

----
buttons/umbtoggle.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbToggle
@restrict E
@scope

@description
<b>Added in Umbraco version 7.7.0</b> Use this directive to render an umbraco toggle.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-toggle
            checked="vm.checked"
            on-click="vm.toggle()">
        </umb-toggle>

        <umb-toggle
            checked="vm.checked"
            disabled="vm.disabled"
            on-click="vm.toggle()"
            show-labels="true"
            label-on="Start"
            label-off="Stop"
            label-position="right"
            hide-icons="true">
        </umb-toggle>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;
            vm.checked = false;
            vm.disabled = false;

            vm.toggle = toggle;

            function toggle() {
                vm.checked = !vm.checked;
            }
        }

        angular.module("umbraco").controller("My.Controller", Controller);

    })();
</pre>

@param {boolean} checked Set to <code>true</code> or <code>false</code> to toggle the switch.
@param {string} inputId Set the <code>id</code> of the toggle.
@param {callback} onClick The function which should be called when the toggle is clicked.
@param {string=} showLabels Set to <code>true</code> or <code>false</code> to show a "On" or "Off" label next to the switch.
@param {string=} labelOn Set a custom label for when the switched is turned on. It will default to "On".
@param {string=} labelOff Set a custom label for when the switched is turned off. It will default to "Off".
@param {string=} labelPosition Sets the label position to the left or right of the switch. It will default to "left" ("left", "right").
@param {string=} hideIcons Set to <code>true</code> or <code>false</code> to hide the icons on the switch.

**/

(function () {
    'use strict';

    function ToggleDirective(localizationService, eventsService, $timeout) {

        function link(scope, el, attrs, ctrl) {

            scope.displayLabelOn = "";
            scope.displayLabelOff = "";

            function onInit() {
                scope.inputId = scope.inputId || "umb-toggle_" + String.CreateGuid();

                setLabelText();

                // Must wait until the current digest cycle is finished before we emit this event on init, 
                // otherwise other property editors might not yet be ready to receive the event
                $timeout(function () {
                    eventsService.emit("toggleValue", { value: scope.checked, inputId: scope.inputId });
                }, 100);
            }

            function setLabelText() {
                
                if (scope.labelOn) {
                    scope.displayLabelOn = scope.labelOn;
                }
                
                if (scope.labelOff) {
                    scope.displayLabelOff = scope.labelOff;
                }

                if (scope.displayLabelOn.length === 0 && scope.displayLabelOff.length === 0)
                {
                    var labelKeys = [
                        "general_on",
                        "general_off"
                    ];

                    localizationService.localizeMany(labelKeys).then(function (data) {
                        // Set default label for "On"
                        scope.displayLabelOn = data[0];

                        // Set default label for "Off"
                        scope.displayLabelOff = data[1];
                    });
                }

            }

            scope.click = function($event) {
                if (scope.readonly) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    return;
                }

                if (scope.onClick) {
                    eventsService.emit("toggleValue", { value: !scope.checked, inputId: scope.inputId });
                    scope.onClick();
                }
            };

            attrs.$observe('readonly', (value) => {
                scope.readonly = value !== undefined;
            });

            onInit();
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/buttons/umb-toggle.html',
            scope: {
                // TODO: This should have required ngModel so we can track and validate user input correctly
                // https://docs.angularjs.org/api/ng/type/ngModel.NgModelController#custom-control-example
                checked: "=",
                disabled: "=",
                inputId: "@",
                onClick: "&",
                labelOn: "@?",
                labelOff: "@?",
                labelPosition: "@?",
                showLabels: "@?",
                hideIcons: "@?"
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbToggle', ToggleDirective);

})();




----
buttons/umbtogglegroup.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbToggleGroup
@restrict E
@scope

@description
Use this directive to render a group of toggle buttons.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <umb-toggle-group
            items="vm.items"
            on-click="vm.toggle(item)">
        </umb-toggle-group>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;
            vm.toggle = toggle;

            function toggle(item) {
                if(item.checked) {
                    // do something if item is checked
                }
                else {
                    // do something else if item is unchecked
                }
            }

            function init() {
                vm.items = [{
                    name: "Item 1",
                    description: "Item 1 description",
                    checked: false,
                    disabled: false
                }, {
                    name: "Item 2",
                    description: "Item 2 description",
                    checked: true,
                    disabled: true
                }];
            }

            init();
        }

        angular.module("umbraco").controller("My.Controller", Controller);

    })();
</pre>

@param {Array} items The items to list in the toggle group
@param {callback} onClick The function which should be called when the toggle is clicked for one of the items.

**/

(function () {
    'use strict';

    function ToggleGroupDirective() {

        function link(scope, el, attr, ctrl) {
            for(let i = 0; i < scope.items.length; i++) {
                scope.items[i].inputId = "umb-toggle-group-item_" + String.CreateGuid();
            }
            scope.change = function(item) {
                if (item.disabled) {
                    return;
                }

                item.checked = !item.checked;
                if(scope.onClick) {
                    scope.onClick({'item': item});
                }
            };

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/buttons/umb-toggle-group.html',
            scope: {
                items: "=",
                onClick: "&"
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbToggleGroup', ToggleGroupDirective);

})();

----
property/umbpropertygroup.directive.js
angular.module("umbraco.directives.html")
    .directive('umbPropertyGroup', function () {
        return {
            transclude: true,
            restrict: 'E',
            replace: true,        
            templateUrl: 'views/components/property/umb-property-group.html'
        };
    });
----
property/umbproperty.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbProperty
* @restrict E
**/
(function () {
    'use strict';

    angular
        .module("umbraco.directives")
        .component('umbProperty', {
            templateUrl: 'views/components/property/umb-property.html',
            controller: UmbPropertyController,
            controllerAs: 'vm',
            transclude: true,
            require: {
                parentUmbProperty: '?^^umbProperty',
                parentForm: '?^^form'
            },
            bindings: {
                property: "=",
                node: "<",
                elementKey: "@",
                // optional, if set this will be used for the property alias validation path (hack required because NC changes the actual property.alias :/)
                propertyAlias: "@",
                showInherit: "<",
                inheritsFrom: "<",
                hideLabel: "<?"
            }
        });

    

    function UmbPropertyController($scope, userService, serverValidationManager, udiService, angularHelper) {

        const vm = this;

        vm.$onInit = onInit;

        vm.setDirty = function () {
            // NOTE: We need to use scope because we haven't changd it to vm.propertyForm in the html and that
            // might mean a breaking change.
            $scope.propertyForm.$setDirty();
        }

        vm.setPropertyError = function (errorMsg) {
            vm.property.propertyErrorMessage = errorMsg;
        };

        vm.propertyActions = [];
        vm.setPropertyActions = function (actions) {
            vm.propertyActions = actions;
        };

        // returns the validation path for the property to be used as the validation key for server side validation logic
        vm.getValidationPath = function () {

            var parentValidationPath = vm.parentUmbProperty ? vm.parentUmbProperty.getValidationPath() : null;            
            var propAlias = vm.propertyAlias ? vm.propertyAlias : vm.property.alias;
            // the elementKey will be empty when this is not a nested property
            var valPath = vm.elementKey ? vm.elementKey + "/" + propAlias : propAlias;
            return serverValidationManager.createPropertyValidationKey(valPath, parentValidationPath);
        }

        function onInit() {
            vm.controlLabelTitle = null;
            if (Umbraco.Sys.ServerVariables.isDebuggingEnabled) {
                userService.getCurrentUser().then(function (u) {
                    if (u.allowedSections.indexOf("settings") !== -1 ? true : false) {
                        vm.controlLabelTitle = vm.property.alias;
                    }
                });
            }

            if (!vm.parentUmbProperty) {
                // not found, then fallback to searching the scope chain, this may be needed when DOM inheritance isn't maintained but scope
                // inheritance is (i.e.infinite editing)
                var found = angularHelper.traverseScopeChain($scope, s => s && s.vm && s.vm.constructor.name === "UmbPropertyController");
                vm.parentUmbProperty = found ? found.vm : null;
          }

          if (vm.property.description) {
            // split by lines containing only '--'
            var descriptionParts = vm.property.description.split(/^--$/gim);
            if (descriptionParts.length > 1) {
              // if more than one part, we have an extended description,
              // combine to one extended description, and remove leading linebreak
              vm.property.extendedDescription = descriptionParts.splice(1).join("--").substring(1);
              vm.property.extendedDescriptionVisible = false;

              // set propertydescription to first part, and remove trailing linebreak
              vm.property.description = descriptionParts[0].slice(0, -1);
            }
          }
        }

    }

})();

----
property/umbpropertyeditor.directive.js
/**
* @ngdoc directive
* @function
* @name umbraco.directives.directive:umbPropertyEditor 
* @requires formController
* @restrict E
**/

//share property editor directive function
function umbPropEditor(umbPropEditorHelper, localizationService) {
        return {
            scope: {
                model: "=",
                preValues: "<",
                node: "<",
                isPreValue: "@",
                preview: "<",
                allowUnlock: "<?",
                onUnlock: "&?"
            },
            
            require: ["^^form", "?^umbProperty"],
            restrict: 'E',
            replace: true,      
            templateUrl: 'views/components/property/umb-property-editor.html',
            link: function (scope, element, attrs, ctrl) {

                scope.readonly = false;
                scope.labels = {};

                //we need to copy the form controller val to our isolated scope so that
                //it get's carried down to the child scopes of this!
                //we'll also maintain the current form name.
                scope[ctrl[0].$name] = ctrl[0];

                // We will capture a reference to umbProperty in this Directive and pass it on to the Scope, so Property-Editor controllers can use it.
                scope["umbProperty"] = ctrl[1];

                if(!scope.model.alias){
                   scope.model.alias = Math.random().toString(36).slice(2);
                }

                localizationService.localize('languages_invariantPropertyUnlockHelp',  [scope.model.label])
                    .then(function(value) {
                        scope.labels.invariantPropertyUnlockHelp = value;
                    });

                localizationService.localize('languages_invariantCulturePropertyUnlockHelp',  [scope.model.label])
                    .then(function(value) {
                        scope.labels.invariantCulturePropertyUnlockHelp = value;
                    });
                
                localizationService.localize('languages_invariantSegmentPropertyUnlockHelp',  [scope.model.label])
                    .then(function(value) {
                        scope.labels.invariantSegmentPropertyUnlockHelp = value;
                    });

                var unbindWatcher = scope.$watch("model.view",
                    function() {
                        scope.propertyEditorView = umbPropEditorHelper.getViewPath(scope.model.view, scope.isPreValue);
                    }
                );

                scope.unlock = function () {
                    if (scope.onUnlock) {
                        scope.onUnlock();
                    }
                };

                attrs.$observe('readonly', (value) => {
                    scope.readonly = value !== undefined;
                });

                scope.$on("$destroy", function () {
                    unbindWatcher();
                });
            }
        };
    };

angular.module("umbraco.directives").directive('umbPropertyEditor', umbPropEditor);

----
property/umbpropertyactions.component.js
(function () {
    'use strict';

    /**
     * A component to render the property action toggle
     */
    
    function umbPropertyActionsController(keyboardService, localizationService, $scope) {

        var unsubscribe = [];

        var vm = this;

        vm.isOpen = false;
        vm.labels = {
            openText: "Open Property Actions",
            closeText: "Close Property Actions"
        };

        vm.open = open;
        vm.close = close;
        vm.toggle = toggle;
        vm.executeAction = executeAction;

        vm.$onDestroy = onDestroy;
        vm.$onInit = onInit;
        vm.$onChanges = onChanges;

        function initDropDown() {
            keyboardService.bind("esc", vm.close);
        }

        function destroyDropDown() {
            keyboardService.unbind("esc");
        }

        function toggle() {
            if (vm.isOpen === true) {
                vm.close();
            } else {
                vm.open();
            }
        }

        function open() {
            vm.isOpen = true;
            initDropDown();
        }

        function close() {
            vm.isOpen = false;
            destroyDropDown();
        }

        function executeAction(action) {
            action.method();
            vm.close();
        }

        function onDestroy() {
            for (var i = 0; i < unsubscribe.length; i++) {
                unsubscribe[i]();
            }
            if (vm.isOpen === true) {
                destroyDropDown();
            }
        }

        function onInit() {
            
            var labelKeys = [
                "propertyActions_tooltipForPropertyActionsMenu",
                "propertyActions_tooltipForPropertyActionsMenuClose"
            ]

            localizationService.localizeMany(labelKeys).then(values => {
                vm.labels.openText = values[0];
                vm.labels.closeText = values[1];
            });

            unsubscribe.push($scope.$watchCollection("vm.actions",
                function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        updateActions();
                    }
                }
            ));
        }

        function onChanges(simpleChanges) {
            if (simpleChanges.actions) {
                updateActions();
            }
        }

        function updateActions() {

            Utilities.forEach(vm.actions || [], action => {

              if (action.labelKey) {
                  localizationService.localize(action.labelKey, (action.labelTokens || []), action.label).then(data => {
                    action.label = data;
                  });
                  
                  action.useLegacyIcon = action.useLegacyIcon === false ? false : true;
                  action.icon = (action.useLegacyIcon && action.icon.indexOf('icon-') !== 0 ? 'icon-' : '') + action.icon;
              }
            });
        }
    }

    var umbPropertyActionsComponent = {
        templateUrl: 'views/components/property/umb-property-actions.html',
        bindings: {
            actions: "<"
        },
        controllerAs: 'vm',
        controller: umbPropertyActionsController
    };

    angular.module('umbraco.directives').component('umbPropertyActions', umbPropertyActionsComponent);

})();

----
references/umbtrackedreferencesbulkaction.component.js
(function () {
    'use strict';

    /**
     * A component to render the items from a selection which are used in a relation
     */

    function umbTrackedReferencesBulkActionController($q, trackedReferencesResource, localizationService)
    {
        var vm = this;

        vm.referencedItemsTitle = "These items are referenced";

        localizationService.localize("references_labelUsedItems").then(function (value) {
            vm.referencedItemsTitle = value;
        });
      
        vm.changeReferencesPageNumber = changeReferencesPageNumber;
        vm.referencesOptions = {};
        vm.referencesOptions.filterMustBeIsDependency = true;
        vm.hasReferences = false;

        vm.$onInit = onInit;

        function onInit() {

            this.loading = true;
            this.hideNoResult = this.hideNoResult || false;

            loadContentBulkActionUsage().then(function () {
                vm.loading = false;
                if(vm.onLoadingComplete) {
                    vm.onLoadingComplete();
                }
            });
        }

        function changeReferencesPageNumber(pageNumber) {
            vm.referencesOptions.pageNumber = pageNumber;
            loadContentBulkActionUsage();
        }

        function loadContentBulkActionUsage() {
             var ids = vm.selection.map(s => s.id);

             return trackedReferencesResource.getPagedReferencedItems(ids, vm.referencesOptions)
                  .then(function (data) {
                      vm.referencedItems = data;

                      if (data.items.length > 0) {
                          vm.hasReferences = data.items.length > 0;
                          activateWarning();
                      }
                  });
        }

        function activateWarning() {
            if (vm.onWarning) {
                vm.onWarning();
            }
        }
    }

    var umbTrackedReferencesBulkActionComponent = {
        templateUrl: 'views/components/references/umb-tracked-references-bulk-action.html',
        transclude: true,
        bindings: {
            selection: "<",
            hideNoResult: "<?",
            onWarning: "&?",
            onLoadingComplete: "&?"
        },
        controllerAs: 'vm',
        controller: umbTrackedReferencesBulkActionController
    };

    angular.module('umbraco.directives').component('umbTrackedReferencesBulkAction', umbTrackedReferencesBulkActionComponent);

})();

----
references/umbtrackedreferences.component.js
(function () {
    'use strict';

    /**
     * A component to render the tracked references of an item
     */

    function umbTrackedReferencesController($q, trackedReferencesResource, localizationService) {

        var vm = this;

        vm.changeReferencesPageNumber = changeReferencesPageNumber;
        vm.changeDescendantsPageNumber = changeDescendantsPageNumber;

        vm.$onInit = onInit;

        function onInit() {

            vm.referencesTitle = this.hideNoneDependencies ? "The following items depend on this" : "Referenced by the following items";
            vm.referencedDescendantsTitle = this.hideNoneDependencies ? "The following descending items have dependencies" : "The following descendant items have dependencies";
            localizationService.localize(this.hideNoneDependencies ? "references_labelDependsOnThis" : "references_labelUsedByItems").then(function (value) {
                vm.referencesTitle = value;
            });

            localizationService.localize(this.hideNoneDependencies ? "references_labelDependentDescendants" : "references_labelUsedDescendants").then(function (value) {
                vm.referencedDescendantsTitle = value;
            });

            vm.descendantsOptions = {};
            vm.descendantsOptions.filterMustBeIsDependency = this.hideNoneDependencies;
            vm.hasReferencesInDescendants = false;

            vm.referencesOptions = {};
            vm.referencesOptions.filterMustBeIsDependency = this.hideNoneDependencies;
            vm.hasReferences = false;

            this.loading = true;
            this.hideNoResult = this.hideNoResult || false;

            // when vm.id == 0 it means that this is a new item, so it has no references yet
            if (vm.id === 0) {
                vm.loading = false;
                if(vm.onLoadingComplete) {
                    vm.onLoadingComplete();
                }
                return;
            }

            // Make array of promises to load:
            var promises = [loadReferencesRelations()];

            // only load descendants if we want to show them.
            if (vm.showDescendants) {
                promises.push(loadDescendantsUsage());
            }

            $q.all(promises).then(function () {
                vm.loading = false;
                if(vm.onLoadingComplete) {
                    vm.onLoadingComplete();
                }
            });
        }

        function changeReferencesPageNumber(pageNumber) {
            vm.referencesOptions.pageNumber = pageNumber;
            loadReferencesRelations();
        }

        function changeDescendantsPageNumber(pageNumber) {
            vm.descendantsOptions.pageNumber = pageNumber;
            loadDescendantsUsage();
        }

        function loadReferencesRelations() {
            return trackedReferencesResource.getPagedReferences(vm.id, vm.referencesOptions)
                .then(function (data) {
                    vm.references = data;

                    if (data.items.length > 0) {
                        vm.hasReferences = data.items.length > 0;
                        activateWarning();
                    }
                });
        }

        function loadDescendantsUsage() {
            return trackedReferencesResource.getPagedDescendantsInReferences(vm.id, vm.descendantsOptions)
                .then(function (data) {
                    vm.referencedDescendants = data;

                    if (data.items.length > 0) {
                        vm.hasReferencesInDescendants = data.items.length > 0;
                        activateWarning();
                    }
                });
        }

        function activateWarning() {
            if (vm.onWarning) {
                vm.onWarning();
            }
        }
    }

    var umbTrackedReferencesComponent = {
        templateUrl: 'views/components/references/umb-tracked-references.html',
        transclude: true,
        bindings: {
            id: "<",
            hideNoResult: "<?",
            onWarning: "&?",
            onLoadingComplete: "&?",
            compact: "<?",
            showDescendants: "<?",
            hideNoneDependencies: "<?"
        },
        controllerAs: 'vm',
        controller: umbTrackedReferencesController
    };

    angular.module('umbraco.directives').component('umbTrackedReferences', umbTrackedReferencesComponent);

})();

----
references/umbtrackedreferencestable.component.js
(function () {
    'use strict';

    /**
     * A component to render a table for the tracked references of an item
     */

    function umbTrackedReferencesTableController(editorService, udiParser, navigationService, overlayService)
    {
        var vm = this;

        vm.changePageNumber = changePageNumber;
        vm.getUrl = getUrl;
        vm.referenceAnchorClicked = referenceAnchorClicked;

        function changePageNumber(pageNumber) {
            vm.onPageChanged({ 'pageNumber' : pageNumber });
        }

        function getUrl(itemUdi, itemId) {
            // extract the entity type from the udi
            var udi = udiParser.parse(itemUdi);

            if (udi) {
                var entityType = udi.entityType;

                if(udi.entityType === "document") {
                    entityType = "content";
                }
                return "#/" + entityType + "/" + entityType + "/edit/" + itemId;
            }
	          return "#";
	    }

        function close() {
            navigationService.hideMenu(); // close menu
            overlayService.close(); // close overlay
        }

        function referenceAnchorClicked($event, reference) {


            if ($event.shiftKey || $event.ctrlKey || $event.metaKey) {
                // we will let the browser take over here.
                return;
            }

            $event.preventDefault();
            close();

            var editorModel = {
                id: reference.id,
                submit: function (model) {
                    editorService.close();
                },
                close: function () {
                    editorService.close();
                }
            };

            overlayService.close();

            // extract the entity type from the udi
            var udi = udiParser.parse(reference.udi);

            if (udi && udi.entityType === "document")
            {
                editorService.contentEditor(editorModel);
                return;
            }

            if (udi && udi.entityType === "media")
            {
                editorService.mediaEditor(editorModel);
                return;
            }

            if (udi && udi.entityType === "member")
            {
                editorModel.id = reference.key;
                editorService.memberEditor(editorModel);
                return;
            }
        }
    }

    var umbTrackedReferencesTableComponent = {
        templateUrl: 'views/components/references/umb-tracked-references-table.html',
        transclude: true,
        bindings: {
            pageNumber: "<",
            totalPages: "<",
            headline: "<",
            items: "<",
            showPublished: "<?",
            showType: "<?",
            showTypeName: "<?",
            showRelationTypeName: "<?",
            onPageChanged: "&"
        },
        controllerAs: 'vm',
        controller: umbTrackedReferencesTableController
    };

    angular.module('umbraco.directives').component('umbTrackedReferencesTable', umbTrackedReferencesTableComponent);

})();

----
overlays/umboverlaybackdrop.directive.js
(function () {
    'use strict';

    function OverlayBackdropDirective(overlayHelper) {

        function link(scope, el, attr, ctrl) {

            scope.numberOfOverlays = 0;

            // TODO: this shouldn't be a watch, this should be based on an event handler
            scope.$watch(function () {
                return overlayHelper.getNumberOfOverlays();
            }, function (newValue) {
                scope.numberOfOverlays = newValue;
            });

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/overlays/umb-overlay-backdrop.html',
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbOverlayBackdrop', OverlayBackdropDirective);

})();

----
overlays/umboverlay.directive.js
/**
@name umbraco.directives.directive:umbOverlay*
@deprecated
@restrict E
@scope

@description

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">

        <button type="button" ng-click="vm.openOverlay()"></button>

        <umb-overlay
            ng-if="vm.overlay.show"
            model="vm.overlay"
            view="vm.overlay.view"
            position="right">
        </umb-overlay>

    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {

        "use strict";

        function Controller() {

            var vm = this;

            vm.openOverlay = openOverlay;

            function openOverlay() {

                vm.overlay = {
                    view: "mediapicker",
                    show: true,
                    submit: function(model) {

                        vm.overlay.show = false;
                        vm.overlay = null;
                    },
                    close: function(oldModel) {
                        vm.overlay.show = false;
                        vm.overlay = null;
                    }
                }

            };

        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

<h1>General Options</h1>
<table>
    <thead>
        <tr>
            <th>Param</th>
            <th>Type</th>
            <th>Details</th>
        </tr>
    </thead>
    <tr>
        <td>model.title</td>
        <td>String</td>
        <td>Set the title of the overlay.</td>
    </tr>
    <tr>
        <td>model.subtitle</td>
        <td>String</td>
        <td>Set the subtitle of the overlay.</td>
    </tr>
    <tr>
        <td>model.submitButtonLabel</td>
        <td>String</td>
        <td>Set an alternate submit button text</td>
    </tr>
    <tr>
        <td>model.submitButtonLabelKey</td>
        <td>String</td>
        <td>Set an alternate submit button label key for localized texts</td>
    </tr>
    <tr>
        <td>model.submitButtonState</td>
        <td>String</td>
        <td>Set the state for the submit button</td>
    </tr>
    <tr>
        <td>model.hideSubmitButton</td>
        <td>Boolean</td>
        <td>Hides the submit button</td>
    </tr>
    <tr>
        <td>model.closeButtonLabel</td>
        <td>String</td>
        <td>Set an alternate close button text</td>
    </tr>
    <tr>
        <td>model.closeButtonLabelKey</td>
        <td>String</td>
        <td>Set an alternate close button label key for localized texts</td>
    </tr>
    <tr>
        <td>model.show</td>
        <td>Boolean</td>
        <td>Show/hide the overlay</td>
    </tr>
    <tr>
        <td>model.submit</td>
        <td>Function</td>
        <td>Callback function when the overlay submits. Returns the overlay model object</td>
    </tr>
    <tr>
        <td>model.close</td>
        <td>Function</td>
        <td>Callback function when the overlay closes. Returns a copy of the overlay model object before being modified</td>
    </tr>
</table>

<h1>Item Picker</h1>
Opens an item picker.</br>
<strong>view: </strong>itempicker
<table>
    <thead>
        <tr>
            <th>Param</th>
            <th>Type</th>
            <th>Details</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>model.availableItems</td>
            <td>Array</td>
            <td>Array of available items</td>
        </tr>
        <tr>
            <td>model.selectedItems</td>
            <td>Array</td>
            <td>Array of selected items. When passed in the selected items will be filtered from the available items.</td>
        </tr>
        <tr>
            <td>model.filter</td>
            <td>Boolean</td>
            <td>Set to false to hide the filter</td>
        </tr>
    </tbody>
</table>
<table>
    <thead>
        <tr>
            <th>Returns</th>
            <th>Type</th>
            <th>Details</th>
        </tr>
    </thead>
    <tr>
        <td>model.selectedItem</td>
        <td>Object</td>
        <td>The selected item</td>
    </tr>
</table>

<h1>YSOD</h1>
Opens an overlay to show a custom YSOD. </br>
<strong>view: </strong>ysod
<table>
    <thead>
        <tr>
            <th>Param</th>
            <th>Type</th>
            <th>Details</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>model.error</td>
            <td>Object</td>
            <td>Error object</td>
        </tr>
    </tbody>
</table>

@param {object} model Overlay options.
@param {string} view Path to view or one of the default view names.
@param {string} position The overlay position ("left", "right", "center": "target").
**/

(function () {
    'use strict';

    function OverlayDirective($timeout, formHelper, overlayHelper, localizationService, $q, $templateCache, $http, $compile) {

        function link(scope, el, attr, ctrl) {

            scope.directive = {
                enableConfirmButton: false
            };

            var overlayNumber = 0;
            var numberOfOverlays = 0;
            var isRegistered = false;


            var modelCopy = {};
            var unsubscribe = [];

            function activate() {
                setView();

                setButtonText();

                modelCopy = makeModelCopy(scope.model);

                $timeout(function () {

                    if (!scope.name) {
                        scope.name = 'overlay';
                    }

                    if (scope.position === "target" && scope.model.event) {
                        setTargetPosition();

                        // update the position of the overlay on content changes
                        // as these affect the layout/size of the overlay
                        if ('ResizeObserver' in window) {
                            var resizeObserver = new ResizeObserver(setTargetPosition);
                            var contentArea = document.getElementById("contentwrapper");
                            resizeObserver.observe(el[0]);
                            if (contentArea) {
                                resizeObserver.observe(contentArea);
                            }
                            unsubscribe.push(function () {
                                resizeObserver.disconnect();
                            });
                        }
                    }

                    // this has to be done inside a timeout to ensure the destroy
                    // event on other overlays is run before registering a new one
                    registerOverlay();

                    setOverlayIndent();

                    focusOnOverlayHeading()
                });

            }

            // Ideally this would focus on the first natively focusable element in the overlay, but as the content can be dynamic, it is focusing on the heading.
            function focusOnOverlayHeading() {
                var heading = el.find(".umb-overlay__title");

                if (heading) {
                    heading.focus();
                }
            }

            function setView() {

                if (scope.view) {

                    if (scope.view.indexOf(".html") === -1) {
                        var viewAlias = scope.view.toLowerCase();
                        scope.view = "views/common/overlays/" + viewAlias + "/" + viewAlias + ".html";
                    }

                    //if a custom parent scope is defined then we need to manually compile the view
                    if (scope.parentScope) {
                        var element = el.find(".scoped-view");
                        $http.get(scope.view, { cache: $templateCache })
                            .then(function (response) {
                                var templateScope = scope.parentScope.$new();
                                unsubscribe.push(function () {
                                    templateScope.$destroy();
                                });
                                templateScope.model = scope.model;
                                element.html(response.data);
                                element.show();
                                $compile(element)(templateScope);
                            });
                    }
                }

            }

            function setButtonText() {

                var labelKeys = [
                    "general_close",
                    "general_submit"
                ];

                localizationService.localizeMany(labelKeys).then(function (values) {
                    if (!scope.model.closeButtonLabelKey && !scope.model.closeButtonLabel) {
                        scope.model.closeButtonLabel = values[0];
                    }
                    if (!scope.model.submitButtonLabelKey && !scope.model.submitButtonLabel) {
                        scope.model.submitButtonLabel = values[1];
                    }
                });
            }

            function registerOverlay() {

                overlayNumber = overlayHelper.registerOverlay();

                $(document).on("keydown.overlay-" + overlayNumber, function (event) {

                    if (event.which === 27) {

                        numberOfOverlays = overlayHelper.getNumberOfOverlays();

                        if (numberOfOverlays === overlayNumber && !scope.model.disableEscKey) {
                            scope.$apply(function () {
                                scope.closeOverLay();
                            });
                        }

                        event.stopPropagation();
                        event.preventDefault();
                    }

                    if (event.which === 13) {

                        numberOfOverlays = overlayHelper.getNumberOfOverlays();

                        if (numberOfOverlays === overlayNumber) {

                            var activeElementType = document.activeElement.tagName;
                            var clickableElements = ["A", "BUTTON"];
                            var submitOnEnter = document.activeElement.hasAttribute("overlay-submit-on-enter");
                            var submitOnEnterValue = submitOnEnter ? document.activeElement.getAttribute("overlay-submit-on-enter") : "";

                            if (clickableElements.indexOf(activeElementType) >= 0) {
                                // don't do anything, let the browser Enter key handle this
                            } else if (activeElementType === "TEXTAREA" && !submitOnEnter) {
                              // don't do anything
                            } else if (submitOnEnter && submitOnEnterValue === "false") {
                                // don't do anything
                            } else {
                                scope.$apply(function () {
                                    scope.submitForm(scope.model);
                                });
                                event.preventDefault();
                            }

                        }

                    }

                });

                isRegistered = true;

            }

            function unregisterOverlay() {

                if (isRegistered) {

                    overlayHelper.unregisterOverlay();

                    $(document).off("keydown.overlay-" + overlayNumber);

                    isRegistered = false;
                }

            }

            function makeModelCopy(object) {

                var newObject = {};

                for (var key in object) {
                    if (key !== "event" && key !== "parentScope") {
                        newObject[key] = Utilities.copy(object[key]);
                    }
                }

                return newObject;

            }

            function setOverlayIndent() {

                var overlayIndex = overlayNumber - 1;
                var indentSize = overlayIndex * 20;
                var overlayWidth = el[0].clientWidth;

                el.css('width', overlayWidth - indentSize);

                if (scope.position === "center" && overlayIndex > 0 || scope.position === "target" && overlayIndex > 0) {
                    var overlayTopPosition = el[0].offsetTop;
                    el.css('top', overlayTopPosition + indentSize);
                }

            }

            function setTargetPosition() {

                var overlay = $(scope.model.event.target).closest('.umb-overlay');
                var container = overlay.length > 0 ? overlay : $("#contentwrapper");

                let rect = container[0].getBoundingClientRect();

                var containerLeft = rect.left;
                var containerRight = containerLeft + rect.width;
                var containerTop = rect.top;
                var containerBottom = containerTop + rect.height;

                var mousePositionClickX = null;
                var mousePositionClickY = null;
                var elementHeight = null;
                var elementWidth = null;

                var position = {
                    right: "inherit",
                    left: "inherit",
                    top: "inherit",
                    bottom: "inherit"
                };

                // click position
                mousePositionClickX = scope.model.event.pageX;
                mousePositionClickY = scope.model.event.pageY;

                // element size
                elementHeight = el[0].clientHeight;
                elementWidth = el[0].clientWidth;

                // move element to this position
                // when using hotkey it fallback to center of container
                position.left = mousePositionClickX ? mousePositionClickX - (elementWidth / 2) : (containerLeft + containerRight) / 2 - (elementWidth / 2);
                position.top = mousePositionClickY ? mousePositionClickY - (elementHeight / 2) : (containerTop + containerBottom) / 2 - (elementHeight / 2);

                // check to see if element is outside screen
                // outside right
                if (position.left + elementWidth > containerRight) {
                    position.right = 10;
                    position.left = "inherit";
                }

                // outside bottom
                if (position.top + elementHeight > containerBottom) {
                    position.bottom = 10;
                    position.top = "inherit";
                }

                // outside left
                if (position.left < containerLeft) {
                    position.left = containerLeft + 10;
                    position.right = "inherit";
                }

                // outside top
                if (position.top < containerTop) {
                    position.top = 10;
                    position.bottom = "inherit";
                }

                el.css(position);
                el.css("visibility", "visible");
            }

            scope.submitForm = function (model) {
                if (scope.model.submit) {
                    if (formHelper.submitForm({ scope: scope, skipValidation: scope.model.skipFormValidation, keepServerValidation: true })) {

                        if (scope.model.confirmSubmit && scope.model.confirmSubmit.enable && !scope.directive.enableConfirmButton) {
                            //wrap in a when since we don't know if this is a promise or not
                            $q.when(scope.model.submit(model, modelCopy, scope.directive.enableConfirmButton)).then(
                                function () {
                                    formHelper.resetForm({ scope: scope });
                                });
                        } else {
                            unregisterOverlay();
                            //wrap in a when since we don't know if this is a promise or not
                            $q.when(scope.model.submit(model, modelCopy, scope.directive.enableConfirmButton)).then(
                                function () {
                                    formHelper.resetForm({ scope: scope });
                                });
                        }

                    }
                }
            };

            scope.cancelConfirmSubmit = function () {
                scope.model.confirmSubmit.show = false;
            };

            scope.closeOverLay = function () {

                unregisterOverlay();

                if (scope.model && scope.model.close) {
                    scope.model = modelCopy;
                    scope.model.close(scope.model);
                } else {
                    scope.model.show = false;
                    scope.model = null;
                }

            };

            scope.outSideClick = function () {
                if (!scope.model.disableBackdropClick) {
                    scope.closeOverLay();
                }
            };

            unsubscribe.push(unregisterOverlay);
            scope.$on('$destroy', function () {
                for (var i = 0; i < unsubscribe.length; i++) {
                    unsubscribe[i]();
                }
            });

            activate();

        }

        var directive = {
            transclude: true,
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/overlays/umb-overlay.html',
            scope: {
                ngShow: "=",
                model: "=",
                view: "=",
                position: "@",
                size: "=?",
                name: "=?",
                parentScope: "=?"
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbOverlay', OverlayDirective);

})();

----
member/umbmembernodeinfo.directive.js
﻿(function () {
    'use strict';

    function MemberNodeInfoDirective($timeout, $location, eventsService, userService, dateHelper, editorService) {

        function link(scope, element, attrs, ctrl) {

            var evts = [];

            //TODO: Infinite editing is not working yet.
            scope.allowChangeMemberType = false;

            function onInit() {
                
                userService.getCurrentUser().then(function (user) {
                    // only allow change of member type if user has access to the settings sections
                    Utilities.forEach(user.sections, function (section) {
                        if (section.alias === "settings") {
                            scope.allowChangeMemberType = true;
                        }
                    });
                });

                // get member type details
                scope.memberType = scope.node.contentType;

                // make sure dates are formatted to the user's locale
                formatDatesToLocal();
            }

            function formatDatesToLocal() {
                // get current backoffice user and format dates
                userService.getCurrentUser().then(function (currentUser) {
                    scope.node.createDateFormatted = dateHelper.getLocalDate(scope.node.createDate, currentUser.locale, 'LLL');
                    scope.node.updateDateFormatted = dateHelper.getLocalDate(scope.node.updateDate, currentUser.locale, 'LLL');
                });
            }

            scope.openMemberType = function (memberType) {
                var editor = {
                    id: memberType.id,
                    submit: function (model) {
                        editorService.close();
                    },
                    close: function () {
                        editorService.close();
                    }
                };
                editorService.memberTypeEditor(editor);
            };

            // watch for content updates - reload content when node is saved, published etc.
            scope.$watch('node.updateDate', function (newValue, oldValue) {
                if (!newValue) { return; }
                if (newValue === oldValue) { return; }

                // Update the create and update dates
                formatDatesToLocal();
            });

            //ensure to unregister from all events!
            scope.$on('$destroy', function () {
                for (var e in evts) {
                    eventsService.unsubscribe(evts[e]);
                }
            });

            onInit();
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/member/umb-member-node-info.html',
            scope: {
                node: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbMemberNodeInfo', MemberNodeInfoDirective);

})();

----
member/umbmembergroupnodeinfo.directive.js
(function () {
    'use strict';

    function MemberGroupNodeInfoDirective(eventsService, userService, dateHelper) {

        function link(scope, element, attrs, ctrl) {

            var evts = [];

            function onInit() {

                // make sure dates are formatted to the user's locale
                formatDatesToLocal();
            }

            function formatDatesToLocal() {
                // get current backoffice user and format dates
                userService.getCurrentUser().then(function (currentUser) {
                    scope.node.createDateFormatted = dateHelper.getLocalDate(scope.node.createDate, currentUser.locale, 'LLL');
                    scope.node.updateDateFormatted = dateHelper.getLocalDate(scope.node.updateDate, currentUser.locale, 'LLL');
                });
            }

            // watch for content updates - reload content when node is saved, published etc.
            scope.$watch('node.updateDate', function(newValue, oldValue){
                if(!newValue) { return; }
                if(newValue === oldValue) { return; }

                // Update the create and update dates
                formatDatesToLocal();
            });

            //ensure to unregister from all events!
            scope.$on('$destroy', function () {
                for (var e in evts) {
                    eventsService.unsubscribe(evts[e]);
                }
            });

            onInit();
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/member/umb-membergroup-node-info.html',
            scope: {
                node: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbMembergroupNodeInfo', MemberGroupNodeInfoDirective);

})();

----
imaging/umbimagegravity.directive.js
(function() {
    'use strict';

    function umbImageGravityController($scope, $element, $timeout) {

        var vm = this;

        //Internal values for keeping track of the dot and the size of the editor
        vm.dimensions = {
            width: 0,
            height: 0,
            left: 0,
            top: 0
        };

        var imageElement = null; //DOM element reference
        var focalPointElement = null; //DOM element reference
        var draggable = null;

        vm.loaded = false;
        vm.$onInit = onInit;
        vm.$onChanges = onChanges;
        vm.$postLink = postLink;
        vm.$onDestroy = onDestroy;
        vm.style = {};
        vm.overlayStyle = {};
        vm.setFocalPoint = setFocalPoint;
        vm.resetFocalPoint = resetFocalPoint;

        /** Sets the css style for the Dot */
        function updateStyle() {
            vm.style = {
                'top': vm.dimensions.top + 'px',
                'left': vm.dimensions.left + 'px'
            };
            vm.overlayStyle = {
                'width': vm.dimensions.width + 'px',
                'height': vm.dimensions.height + 'px'
            };

        };

        function resetFocalPoint() {
            vm.onValueChanged({
                left: 0.5,
                top: 0.5
            });
        };

        function setFocalPoint(event) {
            $scope.$emit("imageFocalPointStart");

            // We do this to get the right position, no matter the focalPoint was clicked.
            var viewportPosition = imageElement[0].getBoundingClientRect();
            var offsetX = event.clientX - viewportPosition.left;
            var offsetY = event.clientY - viewportPosition.top;

            calculateGravity(offsetX, offsetY);
            $scope.$emit("imageFocalPointStop");
        };

        /** Initializes the component */
        function onInit() {
            if (!vm.center) {
                vm.center = { left: 0.5, top: 0.5 };
            }
        }

        /** Called when the component has linked everything and the DOM is available */
        function postLink() {
            //elements
            imageElement = $element.find("img");
            focalPointElement = $element.find(".focalPoint");

            //Drag and drop positioning, using jquery ui draggable
            draggable = focalPointElement.draggable({
                containment: "parent",
                start: function () {
                    $scope.$emit("imageFocalPointStart");
                },
                stop: function (event, ui) {

                    var offsetX = ui.position.left;
                    var offsetY = ui.position.top;

                    $scope.$evalAsync(calculateGravity(offsetX, offsetY));

                    $scope.$emit("imageFocalPointStop");

                }
            });

            window.addEventListener('resize.umbImageGravity', onResizeHandler);
            window.addEventListener('resize', onResizeHandler);


            //if any ancestor directive emits this event, we need to resize
            $scope.$on("editors.content.splitViewChanged", function () {
                $timeout(resized, 200);
            });

            //listen for the image DOM element loading
            imageElement.on("load", function () {
                $timeout(function () {

                    vm.isCroppable = true;
                    vm.hasDimensions = true;

                    if (vm.src) {
                        if (vm.src.endsWith(".svg")) {
                            vm.isCroppable = false;
                            vm.hasDimensions = false;
                        }
                        else {
                            // From: https://stackoverflow.com/a/51789597/5018
                            var type = vm.src.substring(vm.src.indexOf("/") + 1, vm.src.indexOf(";base64"));
                            if (type.startsWith("svg")) {
                                vm.isCroppable = false;
                                vm.hasDimensions = false;
                            }
                        }
                    }

                    setDimensions();
                    updateStyle();

                    vm.loaded = true;
                    if (vm.onImageLoaded) {
                        vm.onImageLoaded({
                            "isCroppable": vm.isCroppable,
                            "hasDimensions": vm.hasDimensions
                        });
                    }
                }, 100);
            });
        }

        function onDestroy() {
            window.removeEventListener('resize.umbImageGravity', onResizeHandler);
            window.removeEventListener('resize', onResizeHandler);
            /*
            if (focalPointElement) {
                // TODO: This should be destroyed but this will throw an exception:
                // "cannot call methods on draggable prior to initialization; attempted to call method 'destroy'"
                // I've tried lots of things and cannot get this to work, we weren't destroying before so hopefully
                // there's no mem leaks?
                focalPointElement.draggable("destroy");
            }
            */
            if (imageElement) {
                imageElement.off("load");
            }
        }

        /** Called when we need to resize based on window or DOM dimensions to re-center the focal point */
        function resized() {
            $timeout(function () {
                setDimensions();
                updateStyle();
            });
            /*
            // Make sure we can find the offset values for the overlay(dot) before calculating
            // fixes issue with resize event when printing the page (ex. hitting ctrl+p inside the rte)
            if (focalPointElement.is(':visible')) {
                var offsetX = focalPointElement[0].offsetLeft;
                var offsetY = focalPointElement[0].offsetTop;
                calculateGravity(offsetX, offsetY);
            }
            */
        }

        function onResizeHandler() {
            $scope.$evalAsync(resized);
        }

        /** Watches the one way binding changes */
        function onChanges(changes) {
            if (changes.center && !changes.center.isFirstChange()
                && changes.center.currentValue
                && !Utilities.equals(changes.center.currentValue, changes.center.previousValue)) {
                //when center changes update the dimensions
                setDimensions();
                updateStyle();
            }
        }

        /** Sets the width/height/left/top dimentions based on the image size and the "center" value */
        function setDimensions() {

            if (vm.isCroppable && imageElement && vm.center) {
                vm.dimensions.width = imageElement.width();
                vm.dimensions.height = imageElement.height();
                vm.dimensions.left = vm.center.left * vm.dimensions.width;
                vm.dimensions.top = vm.center.top * vm.dimensions.height;
            }

            return vm.dimensions.width;
        };

        /**
         * based on the offset selected calculates the "center" value and calls the callback
         * @param {any} offsetX
         * @param {any} offsetY
         */
        function calculateGravity(offsetX, offsetY) {
            vm.onValueChanged({
                left: Math.min(Math.max(offsetX, 0), vm.dimensions.width) / vm.dimensions.width,
                top: Math.min(Math.max(offsetY, 0), vm.dimensions.height) / vm.dimensions.height
            });
        };

    }

    var umbImageGravityComponent = {
        templateUrl: 'views/components/imaging/umb-image-gravity.html',
        bindings: {
            src: "<",
            center: "<",
            onImageLoaded: "&?",
            onValueChanged: "&",
            disableFocalPoint: "<?"
        },
        controllerAs: 'vm',
        controller: umbImageGravityController
    };

    angular.module("umbraco.directives")
        .component('umbImageGravity', umbImageGravityComponent);

})();

----
imaging/umbimagecrop.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbImageCrop
* @restrict E
* @function
**/
angular.module("umbraco.directives")
    .directive('umbImageCrop',
        function ($timeout, cropperHelper, windowResizeListener) {

            const MAX_SCALE = 4;

            return {
                restrict: 'E',
                replace: true,
                transclude: true,
                templateUrl: 'views/components/imaging/umb-image-crop.html',
                scope: {
                    src: '=',
                    width: '@',
                    height: '@',
                    crop: "=",
                    center: "=",
                    maxSize: '@?',
                    alias: '@?',
                    forceUpdate: '@?'
                },

                link: function (scope, element, attrs) {

                    var unsubscribe = [];
                    let sliderRef = null;

                    scope.loaded = false;
                    scope.width = 0;
                    scope.height = 0;

                    scope.dimensions = {
                        element: {},
                        image: {},
                        cropper: {},
                        viewport: {},
                        margin: {},
                        scale: {
                            min: 1,
                            max: MAX_SCALE,
                            current: 1
                        }
                    };

                    scope.sliderOptions = {
                        "start": scope.dimensions.scale.current,
                        "step": 0.001,
                        "tooltips": [false],
                        "format": {
                            to: function (value) {
                                return parseFloat(parseFloat(value).toFixed(3));
                            },
                            from: function (value) {
                                return parseFloat(parseFloat(value).toFixed(3));
                            }
                        },
                        "range": {
                            "min": scope.dimensions.scale.min,
                            "max": scope.dimensions.scale.max
                        }
                    };

                    scope.setup = function (slider) {
                        sliderRef = slider;
                        updateSlider();
                    };

                    function updateSlider() {
                        if (sliderRef) {
                            // Update slider range min/max
                            sliderRef.noUiSlider.updateOptions({
                                "range": {
                                    "min": scope.dimensions.scale.min,
                                    "max": scope.dimensions.scale.max
                                }
                            });

                            // Set slider handle position
                            sliderRef.noUiSlider.set(scope.dimensions.scale.current);
                        }
                    }

                    scope.slide = function (values) {
                        if (values) {
                            scope.dimensions.scale.current = parseFloat(values);
                        }
                    };

                    scope.change = function (values) {
                        if (values) {
                            scope.dimensions.scale.current = parseFloat(values);
                        }
                    };

                    function onScroll(event) {
                        // cross-browser wheel delta
                        var delta = Math.max(-50, Math.min(50, (event.wheelDelta || -event.detail)));

                        if (sliderRef) {
                            var currentScale =sliderRef.noUiSlider.get();

                            var newScale = Math.min(Math.max(currentScale + delta*.001*scope.dimensions.image.ratio, scope.dimensions.scale.min), scope.dimensions.scale.max);
                            sliderRef.noUiSlider.set(newScale);
                            scope.$evalAsync(() => {
                                scope.dimensions.scale.current = newScale;
                            });

                            if(event.preventDefault)  {
                                event.preventDefault();
                            }
                        }
                    }


                    //live rendering of viewport and image styles
                    function updateStyles() {
                        scope.maskStyle = {
                            'height': (parseInt(scope.dimensions.cropper.height, 10)) + 'px',
                            'width': (parseInt(scope.dimensions.cropper.width, 10)) + 'px',
                            'top': (parseInt(scope.dimensions.margin.top, 10)) + 'px',
                            'left': (parseInt(scope.dimensions.margin.left, 10)) + 'px'
                        }
                    };

                    updateStyles();

                    //elements
                    var $viewport = element.find(".viewport");
                    var $image = element.find("img");
                    var $overlay = element.find(".overlay");

                    $overlay.bind("focus", function () {
                        $overlay.bind("DOMMouseScroll mousewheel onmousewheel", onScroll);
                    });

                    $overlay.bind("blur", function () {
                        $overlay.unbind("DOMMouseScroll mousewheel onmousewheel", onScroll);
                    });

                    //default constraints for drag n drop
                    var constraints = { left: { max: 0, min: 0 }, top: { max: 0, min: 0 } };
                    scope.constraints = constraints;


                    //set constaints for cropping drag and drop
                    var setConstraints = function () {
                        constraints.left.min = scope.dimensions.cropper.width - scope.dimensions.image.width;
                        constraints.top.min = scope.dimensions.cropper.height - scope.dimensions.image.height;
                    };

                    var setDimensions = function () {

                        scope.dimensions.image.width = scope.dimensions.image.originalWidth;
                        scope.dimensions.image.height = scope.dimensions.image.originalHeight;

                        //unscaled editor size
                        var _cropW = parseInt(scope.width, 10);
                        var _cropH = parseInt(scope.height, 10);

                        var ratioCalculation = cropperHelper.scaleToMaxSize(
                            _cropW,
                            _cropH,
                            scope.dimensions.viewport.width - 40,
                            scope.dimensions.viewport.height - 40);

                        //so if we have a max size, override the thumb sizes
                        _cropW = ratioCalculation.width;
                        _cropH = ratioCalculation.height;

                        // set margins:
                        scope.dimensions.margin.left = (scope.dimensions.viewport.width - _cropW) * 0.5;
                        scope.dimensions.margin.top = (scope.dimensions.viewport.height - _cropH) * 0.5;

                        scope.dimensions.cropper.width = _cropW;
                        scope.dimensions.cropper.height = _cropH;
                        updateStyles();
                    };

                    //resize to a given ratio
                    var resizeImageToScale = function (ratio) {

                        var prevWidth = scope.dimensions.image.width;
                        var prevHeight = scope.dimensions.image.height;

                        scope.dimensions.image.width = scope.dimensions.image.originalWidth * ratio;
                        scope.dimensions.image.height = scope.dimensions.image.originalHeight * ratio;

                        var difW = (scope.dimensions.image.width - prevWidth);
                        var difH = (scope.dimensions.image.height - prevHeight);

                        // normalized focus point:
                        var focusNormX = (-scope.dimensions.image.left + scope.dimensions.cropper.width*.5) / prevWidth;
                        var focusNormY = (-scope.dimensions.image.top + scope.dimensions.cropper.height*.5) / prevHeight;

                        scope.dimensions.image.left = scope.dimensions.image.left - difW * focusNormX;
                        scope.dimensions.image.top = scope.dimensions.image.top - difH * focusNormY;

                        setConstraints();
                        validatePosition(scope.dimensions.image.left, scope.dimensions.image.top);
                    };

                    //resize the image to a predefined crop coordinate
                    var resizeImageToCrop = function () {
                        scope.dimensions.image = cropperHelper.convertToStyle(
                            runtimeCrop,
                            { width: scope.dimensions.image.originalWidth, height: scope.dimensions.image.originalHeight },
                            scope.dimensions.cropper,
                            0);

                        var ratioCalculation = cropperHelper.calculateAspectRatioFit(
                            scope.dimensions.image.originalWidth,
                            scope.dimensions.image.originalHeight,
                            scope.dimensions.cropper.width,
                            scope.dimensions.cropper.height,
                            true);

                        scope.dimensions.scale.current = scope.dimensions.image.ratio;

                        // Update min and max based on original width/height
                        // Here we update the slider to use the scala of the current setup, i dont know why its made in this way but this is how it is.
                        scope.dimensions.scale.min = ratioCalculation.ratio;
                        // TODO: Investigate wether we can limit users to not scale bigger than the amount of pixels in the source:
                        //scope.dimensions.scale.max = ratioCalculation.ratio * Math.min(MAX_SCALE, scope.dimensions.image.originalWidth/scope.dimensions.cropper.width);
                        scope.dimensions.scale.max = ratioCalculation.ratio * MAX_SCALE;

                        updateSlider();
                    };

                    var validatePosition = function (left, top) {

                        left = Math.min(Math.max(left, constraints.left.min), constraints.left.max);
                        top = Math.min(Math.max(top, constraints.top.min), constraints.top.max);

                        if (scope.dimensions.image.left !== left) {
                            scope.dimensions.image.left = left;
                        }

                        if (scope.dimensions.image.top !== top) {
                            scope.dimensions.image.top = top;
                        }
                    };


                    //sets scope.crop to the recalculated % based crop
                    function calculateCropBox() {
                        runtimeCrop = cropperHelper.pixelsToCoordinates(scope.dimensions.image, scope.dimensions.cropper.width, scope.dimensions.cropper.height, 0);
                    };
                    function saveCropBox() {
                        scope.crop = Utilities.copy(runtimeCrop);
                    }


                    //Drag and drop positioning, using jquery ui draggable
                    //var onStartDragPosition, top, left;
                    var dragStartPosition = {};
                    $overlay.draggable({
                        start: function (event, ui) {
                            dragStartPosition.left = scope.dimensions.image.left;
                            dragStartPosition.top = scope.dimensions.image.top;
                        },
                        drag: function (event, ui) {
                            scope.$apply(function () {
                                validatePosition(dragStartPosition.left + (ui.position.left - ui.originalPosition.left), dragStartPosition.top + (ui.position.top - ui.originalPosition.top));
                            });
                        },
                        stop: function (event, ui) {
                            scope.$apply(function () {
                                //make sure that every validates one more time...
                                validatePosition(dragStartPosition.left + (ui.position.left - ui.originalPosition.left), dragStartPosition.top + (ui.position.top - ui.originalPosition.top));

                                calculateCropBox();
                                saveCropBox();
                            });
                        }
                    });

                    var runtimeCrop;
                    var init = function () {

                        // store original size:
                        scope.dimensions.image.originalWidth = $image.width();
                        scope.dimensions.image.originalHeight = $image.height();

                        // runtime Crop, should not be saved until we have interactions:
                        runtimeCrop = Utilities.copy(scope.crop);

                        onViewportSizeChanged();

                        scope.loaded = true;
                    };

                    function setCrop() {
                        //create a default crop if we haven't got one already
                        var createDefaultCrop = !scope.crop;
                        if (createDefaultCrop) {
                            calculateCropBox();
                        }

                        resizeImageToCrop();

                        //if we're creating a new crop, make sure to zoom out fully
                        if (createDefaultCrop) {
                            scope.dimensions.scale.current = scope.dimensions.scale.min;
                            resizeImageToScale(scope.dimensions.scale.min);

                            if (scope.center) {
                                // Move image to focal point if set
                                // Repeating a few calls here, but logic is too difficult to follow elsewhere
                                var x1 = Math.min(
                                    Math.max(
                                        scope.center.left * scope.dimensions.image.width - scope.dimensions.cropper.width / 2,
                                        0
                                    ),
                                    scope.dimensions.image.width - scope.dimensions.cropper.width
                                );
                                var y1 = Math.min(
                                    Math.max(
                                        scope.center.top * scope.dimensions.image.height - scope.dimensions.cropper.height / 2,
                                        0
                                    ),
                                    scope.dimensions.image.height - scope.dimensions.cropper.height
                                );
                                scope.dimensions.image.left = x1;
                                scope.dimensions.image.top = y1;
                                calculateCropBox();
                                resizeImageToCrop();
                            }
                        }
                    }


                    function onViewportSizeChanged() {
                        scope.dimensions.viewport.width = $viewport.width();
                        scope.dimensions.viewport.height = $viewport.height();

                        setDimensions();
                        setCrop();
                        setConstraints();
                    }


                    // Watchers
                    unsubscribe.push(scope.$watchCollection('[width, height, alias, forceUpdate]', function (newValues, oldValues) {
                        // We have to reinit the whole thing if
                        // one of the external params changes
                        if (newValues !== oldValues) {
                            runtimeCrop = Utilities.copy(scope.crop);
                            setDimensions();
                            setCrop();
                            setConstraints();
                        }
                    }));

                    var throttledScale = _.throttle(() => scope.$evalAsync(() => {
                        resizeImageToScale(scope.dimensions.scale.current);
                        calculateCropBox();
                        saveCropBox();
                    }), 16);

                    // Happens when we change the scale
                    unsubscribe.push(scope.$watch("dimensions.scale.current", function (newValue, oldValue) {
                        if (scope.loaded) {
                            throttledScale();
                        }
                    }));


                    // Init

                    //if we have a max-size we will use it, to keep this backwards compatible.
                    // I dont see this max size begin usefull, as we should aim for responsive UI.
                    if (scope.maxSize) {
                        element.css("max-width", parseInt(scope.maxSize, 10) + "px");
                        element.css("max-height", parseInt(scope.maxSize, 10) + "px");
                    }

                    $image.on("load", function () {
                        $timeout(function () {
                            init();
                        });
                    });

                    windowResizeListener.register(onViewportSizeChanged);

                    scope.$on('$destroy', function () {
                        $image.prop("src", "");
                        windowResizeListener.unregister(onViewportSizeChanged);
                        unsubscribe.forEach(u => u());
                    })
                }
            };
        });

----
imaging/umbimagethumbnail.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbImageThumbnail
* @restrict E
* @function
* @description
**/
angular.module("umbraco.directives")
	.directive('umbImageThumbnail',
		function ($timeout, localizationService, cropperHelper, $log) {
	    return {
				restrict: 'E',
				replace: true,
				templateUrl: 'views/components/imaging/umb-image-thumbnail.html',

				scope: {
					src: '=',
					width: '@',
					height: '@',
					center: "=",
					crop: "=",
					maxSize: '@'
				},

				link: function(scope, element, attrs) {
					//// INIT /////
					var $image = element.find("img");
					scope.loaded = false;

                    $image.on("load", function() {
                        $timeout(function () {
                            $image.width("auto");
                            $image.height("auto");

                            scope.image = {};
                            scope.image.width = $image[0].width;
                            scope.image.height = $image[0].height;

                            //we force a lower thumbnail size to fit the max size
                            //we do not compare to the image dimensions, but the thumbs
                            if (scope.maxSize) {
                                var ratioCalculation = cropperHelper.calculateAspectRatioFit(
                                    scope.width,
                                    scope.height,
                                    scope.maxSize,
                                    scope.maxSize,
                                    false);

                                //so if we have a max size, override the thumb sizes
                                scope.width = ratioCalculation.width;
                                scope.height = ratioCalculation.height;
                            }

                            setPreviewStyle();
                            scope.loaded = true;
                        });
                    })

					/// WATCHERS ////
					scope.$watchCollection('[crop, center]', function(newValues, oldValues){
							//we have to reinit the whole thing if
							//one of the external params changes
							setPreviewStyle();
					});

					scope.$watch("center", function(){
						setPreviewStyle();
					}, true);

					function setPreviewStyle(){
						if(scope.crop && scope.image){
							scope.preview = cropperHelper.convertToStyle(
												scope.crop,
												scope.image,
												{width: scope.width, height: scope.height},
												0);
						}else if(scope.image){

							//returns size fitting the cropper
							var p = cropperHelper.calculateAspectRatioFit(
									scope.image.width,
									scope.image.height,
									scope.width,
									scope.height,
									true);


							if(scope.center){
								var xy = cropperHelper.alignToCoordinates(p, scope.center, {width: scope.width, height: scope.height});
								p.top = xy.top;
								p.left = xy.left;
							}

							p.position = "absolute";
							scope.preview = p;
						}
					}
				}
			};
		});

----
content/umbvariantnotificationlist.directive.js
﻿(function () {
    'use strict';

    function umbNotificationList() {

        var vm = this;
        
    }

    var umbNotificationListComponent = {
        templateUrl: 'views/components/content/umb-variant-notification-list.html',
        bindings: {
            notifications: "<"
        },
        controllerAs: 'vm',
        controller: umbNotificationList
    };

    angular.module("umbraco.directives")
        .component('umbVariantNotificationList', umbNotificationListComponent);

})();

----
content/umbcontentnodeinfo.directive.js
(function () {
    'use strict';

    function ContentNodeInfoDirective($timeout, logResource, eventsService, userService, localizationService, dateHelper, editorService, redirectUrlsResource, overlayService, entityResource) {

        function link(scope) {

            var evts = [];
            var isInfoTab = false;
            var auditTrailLoaded = false;
            var labels = {};

            scope.publishStatus = [];
            scope.currentVariant = null;
            scope.currentUrls = [];
            scope.loadingReferences = false;

            scope.disableTemplates = Umbraco.Sys.ServerVariables.features.disabledFeatures.disableTemplates;
            scope.allowChangeDocumentType = false;
            scope.allowChangeTemplate = false;
            scope.allTemplates = [];

            scope.historyLabelKey = scope.node.variants && scope.node.variants.length === 1 ? "general_history" : "auditTrails_historyIncludingVariants";

            function onInit() {
                entityResource.getAll("Template").then(templates => scope.allTemplates = templates);

                // set currentVariant
                scope.currentVariant = scope.node.variants.find(v => v.active);

                updateCurrentUrls();

                // if there are any infinite editors open we are in infinite editing
                scope.isInfiniteMode = editorService.getNumberOfEditors() > 0 ? true : false;

                userService.getCurrentUser().then(user => {
                    // only allow change of media type if user has access to the settings sections
                    const hasAccessToSettings = user.allowedSections.indexOf("settings") !== -1 ? true : false;
                    scope.allowChangeDocumentType = hasAccessToSettings;
                    scope.allowChangeTemplate = hasAccessToSettings;
                });

                var keys = [
                    "general_deleted",
                    "content_unpublished",
                    "content_published",
                    "content_publishedPendingChanges",
                    "content_notCreated",
                    "prompt_unsavedChanges",
                    "prompt_doctypeChangeWarning",
                    "content_itemNotPublished",
                    "general_choose"
                ];

                localizationService.localizeMany(keys)
                    .then(data => {
                        [labels.deleted,
                        labels.unpublished,
                        labels.published,
                        labels.publishedPendingChanges,
                        labels.notCreated,
                        labels.unsavedChanges,
                        labels.doctypeChangeWarning,
                        labels.notPublished,
                        scope.chooseLabel] = data;

                        setNodePublishStatus();

                        if (scope.currentUrls && scope.currentUrls.length === 0) {
                            if (scope.node.id > 0) {
                                //it's created but not published
                                scope.currentUrls.push({ text: labels.notPublished, isUrl: false });
                            }
                            else {
                                //it's new
                                scope.currentUrls.push({ text: labels.notCreated, isUrl: false })
                            }
                        }

                    });

                scope.auditTrailOptions = {
                    id: scope.node.id
                };

                // make sure dates are formatted to the user's locale
                formatDatesToLocal();

                // get available templates
                scope.availableTemplates = scope.node.allowedTemplates;

                // get document type details
                scope.documentType = scope.node.documentType;

                //default setting for redirect url management
                scope.urlTrackerDisabled = false;

                // Declare a fallback URL for the <umb-node-preview/> directive
                if (scope.documentType !== null) {
                    scope.previewOpenUrl = '#/settings/documentTypes/edit/' + scope.documentType.id;
                }

                var activeApp = scope.node.apps.find(a => a.active);
                if (activeApp.alias === "umbInfo") {
                    loadRedirectUrls();
                    loadAuditTrail();
                    isInfoTab = true;
                }

                // never show templates for element types (if they happen to have been created in the content tree)
                scope.disableTemplates = scope.disableTemplates || scope.node.isElement;
            }

            scope.auditTrailPageChange = function (pageNumber) {
                scope.auditTrailOptions.pageNumber = pageNumber;
                loadAuditTrail(true);
            };

            scope.openDocumentType = function (documentType) {

                // add confirmation dialog before opening the doc type editor
                if (scope.node.variants.some(variant => variant.isDirty)) {
                    const confirm = {
                        title: labels.unsavedChanges,
                        view: "default",
                        content: labels.doctypeChangeWarning,
                        submitButtonLabelKey: "general_continue",
                        submitButtonStyle: "warning",
                        closeButtonLabelKey: "general_cancel",
                        submit: function () {
                            openDocTypeEditor(documentType);
                            overlayService.close();
                        },
                        close: function () {
                            overlayService.close();
                        }
                    };
                    overlayService.open(confirm);
                } else {
                    openDocTypeEditor(documentType);
                }

            };

            function openDocTypeEditor(documentType) {
                const editor = {
                    id: documentType.id,
                    submit: function () {
                        editorService.close();
                    },
                    close: function () {
                        editorService.close();
                    }
                };
                editorService.documentTypeEditor(editor);
            }

            scope.openTemplate = function () {
                var template = scope.allTemplates.find(x => x.alias === scope.node.template);

                if (!template) {
                    return;
                }
                var templateEditor = {
                    id: template.id,
                    submit: function () {
                        editorService.close();
                    },
                    close: function () {
                        editorService.close();
                    }
                };
                editorService.templateEditor(templateEditor);
            }

            scope.updateTemplate = function (templateAlias) {
                // update template value
                scope.node.template = templateAlias;
            };

            scope.openRollback = function () {

                var rollback = {
                    node: scope.node,
                    submit: function () {
                        const args = { node: scope.node };
                        eventsService.emit("editors.content.reload", args);
                        editorService.close();
                    },
                    close: function () {
                        editorService.close();
                    }
                };
                editorService.rollback(rollback);
            };

            function loadAuditTrail(forceReload) {

                //don't load this if it's already done
                if (auditTrailLoaded && !forceReload) {
                    return;
                }

                scope.loadingAuditTrail = true;

                logResource.getPagedEntityLog(scope.auditTrailOptions)
                    .then(data => {

                        // get current backoffice user and format dates
                        userService.getCurrentUser().then(currentUser => {
                            data.items.forEach(item => {
                                item.timestampFormatted = dateHelper.getLocalDate(item.timestamp, currentUser.locale, 'LLL');
                            });
                        });

                        scope.auditTrail = data.items;
                        scope.auditTrailOptions.pageNumber = data.pageNumber;
                        scope.auditTrailOptions.pageSize = data.pageSize;
                        scope.auditTrailOptions.totalItems = data.totalItems;
                        scope.auditTrailOptions.totalPages = data.totalPages;

                        setAuditTrailLogTypeColor(scope.auditTrail);

                        scope.loadingAuditTrail = false;

                        auditTrailLoaded = true;
                    });

            }

            function loadReferences(){
              scope.loadingReferences = true;
            }
            function loadRedirectUrls() {
                scope.loadingRedirectUrls = true;
                //check if Redirect URL Management is enabled
                redirectUrlsResource.getEnableState().then(response => {
                    scope.urlTrackerDisabled = response.enabled !== true;
                    if (scope.urlTrackerDisabled === false) {

                        redirectUrlsResource.getRedirectsForContentItem(scope.node.udi)
                            .then(data => {
                                scope.redirectUrls = data.searchResults;
                                scope.hasRedirects = (typeof data.searchResults !== 'undefined' && data.searchResults.length > 0);
                                scope.loadingRedirectUrls = false;
                            });
                    }
                    else {
                        scope.loadingRedirectUrls = false;
                    }
                });
            }

            function setAuditTrailLogTypeColor(auditTrail) {
                auditTrail.forEach(item => {

                    switch (item.logType) {
                        case "Save":
                            item.logTypeColor = "primary";
                            break;
                        case "Publish":
                        case "PublishVariant":
                            item.logTypeColor = "success";
                            break;
                        case "Unpublish":
                        case "UnpublishVariant":
                            item.logTypeColor = "warning";
                            break;
                        case "Delete":
                            item.logTypeColor = "danger";
                            break;
                        default:
                            item.logTypeColor = "gray";
                    }
                });
            }

            function setNodePublishStatus() {

                scope.status = {};

                // deleted node
                if (scope.node.trashed === true) {
                    scope.status.color = "danger";
                    return;
                }

                // variant status
                if (scope.currentVariant.state === "NotCreated") {
                    // not created
                    scope.status.color = "gray";
                }
                else if (scope.currentVariant.state === "Draft") {
                    // draft node
                    scope.status.color = "gray";
                }
                else if (scope.currentVariant.state === "Published") {
                    // published node
                    scope.status.color = "success";
                }
                else if (scope.currentVariant.state === "PublishedPendingChanges") {
                    // published node with pending changes
                    scope.status.color = "success";
                }
            }

            function formatDatesToLocal() {
                // get current backoffice user and format dates
                userService.getCurrentUser().then(currentUser => {
                    scope.currentVariant.createDateFormatted = dateHelper.getLocalDate(scope.currentVariant.createDate, currentUser.locale, 'LLL');
                    scope.currentVariant.releaseDateFormatted = dateHelper.getLocalDate(scope.currentVariant.releaseDate, currentUser.locale, 'LLL');
                    scope.currentVariant.expireDateFormatted = dateHelper.getLocalDate(scope.currentVariant.expireDate, currentUser.locale, 'LLL');
                });
            }

            function updateCurrentUrls() {
                // never show URLs for element types (if they happen to have been created in the content tree)
                if (scope.node.isElement || scope.node.urls === null) {
                    scope.currentUrls = null;
                    return;
                }

                // find the urls for the currently selected language
                // when there is no selected language (allow vary by culture == false), show all urls of the node.
                scope.currentUrls = scope.node.urls.filter(url => scope.currentVariant.language == null || scope.currentVariant.language.culture === url.culture);

                // figure out if multiple cultures apply across the content URLs
                // by getting an array of the url cultures, then checking that more than one culture exists in the array
                scope.currentUrlsHaveMultipleCultures = scope.currentUrls
                    .map(x => x.culture)
                    .filter((v, i, arr) => arr.indexOf(v) === i)
                    .length > 1;
            }

            // load audit trail and redirects when on the info tab
            evts.push(eventsService.on("app.tabChange", function (event, args) {
                $timeout(function () {
                    if (args.alias === "umbInfo") {
                        isInfoTab = true;
                        loadAuditTrail();
                        loadRedirectUrls();
                        setNodePublishStatus();
                        formatDatesToLocal();
                        loadReferences();
                    } else {
                        isInfoTab = false;
                    }
                });
            }));

            // watch for content state updates
            scope.$watch('node.updateDate', function (newValue, oldValue) {

                if (!newValue) { return; }
                if (newValue === oldValue) { return; }

                if (isInfoTab) {
                    loadAuditTrail(true);
                    loadRedirectUrls();
                    setNodePublishStatus();
                    formatDatesToLocal();
                    loadReferences();
                }
                updateCurrentUrls();
            });

            //ensure to unregister from all events!
            scope.$on('$destroy', function () {
                for (var e in evts) {
                    eventsService.unsubscribe(evts[e]);
                }
            });

            onInit();

        }

        var directive = {
            require: '^^umbVariantContent',
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/content/umb-content-node-info.html',
            scope: {
                node: "="
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbContentNodeInfo', ContentNodeInfoDirective);

})();

----
content/umbvariantcontent.directive.js
﻿(function () {
    'use strict';

    /**
     * A component to encapsulate each variant editor which includes the name header and all content apps for a given variant
     */
    var umbVariantContent = {
        templateUrl: 'views/components/content/umb-variant-content.html',
        bindings: {
            content: "<",
            page: "<",
            editor: "<",
            editorIndex: "<",
            editorCount: "<",
            onCloseSplitView: "&",
            onSelectVariant: "&",
            onOpenSplitView: "&",
            onSelectApp: "&",
            onSelectAppAnchor: "&",
            onBack: "&?",
            showBack: "<?"
        },
        controllerAs: 'vm',
        controller: umbVariantContentController
    };

    function umbVariantContentController($scope, contentAppHelper) {

        var unsubscribe = [];

        var vm = this;

        vm.$onInit = onInit;
        vm.$postLink = postLink;
        vm.$onDestroy = onDestroy;

        vm.selectVariant = selectVariant;
        vm.openSplitView = openSplitView;
        vm.selectApp = selectApp;
        vm.selectAppAnchor = selectAppAnchor;
        vm.showBackButton = showBackButton;

        function onInit() {

            // Make copy of apps, so we can have a variant specific model for the App. (needed for validation etc.)
            vm.editor.variantApps = Utilities.copy(vm.content.apps);

            var activeApp = vm.content.apps.find((app) => app.active);

            onAppChanged(activeApp);
        }

        function showBackButton() {
            return vm.page.listViewPath !== null && vm.showBack;
        }

        /** Called when the component has linked all elements, this is when the form controller is available */
        function postLink() {
            //set the content to dirty if the header changes
            unsubscribe.push($scope.$watch("vm.editor.content.name",
                function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        vm.editor.content.isDirty = true;
                    }
                }));
        }

        function onDestroy() {
            for (var i = 0; i < unsubscribe.length; i++) {
                unsubscribe[i]();
            }
        }

        /**
         * Used to proxy a callback
         * @param {any} variant
         */
        function selectVariant(variant) {
            if (vm.onSelectVariant) {
                vm.onSelectVariant({ "variant": variant });
            }
        }

        /**
         * Used to proxy a callback
         * @param {any} item
         */
        function selectApp(item) {
            // call the callback if any is registered
            if (vm.onSelectApp) {
                vm.onSelectApp({ "app": item });
            }
        }

        $scope.$on("editors.apps.appChanged", function ($event, $args) {
            var activeApp = $args.app;

            // sync varaintApps active with new active.
            _.forEach(vm.editor.variantApps, function (app) {
                app.active = (app.alias === activeApp.alias);
            });

            onAppChanged(activeApp);
        });

        $scope.$on("listView.itemsChanged", function ($event, $args) {
            vm.disableActionsMenu = $args.items.length > 0;
        });

        function onAppChanged(activeApp) {
            // set the name field to readonly if the user don't have update permissions or the active content app is not "Content" or "Info"
            const allowUpdate = vm.editor.content.allowedActions.includes('A');
            const isContentBasedApp = activeApp && contentAppHelper.isContentBasedApp(activeApp);
            vm.nameReadonly = !allowUpdate || !isContentBasedApp;
        }

        /**
         * Used to proxy a callback
         * @param {any} item
         */
        function selectAppAnchor(item, anchor) {
            // call the callback if any is registered
            if (vm.onSelectAppAnchor) {
                vm.onSelectAppAnchor({ "app": item, "anchor": anchor });
            }
        }

        /**
         * Used to proxy a callback
         * @param {any} variant
         */
        function openSplitView(variant) {
            if (vm.onOpenSplitView) {
                vm.onOpenSplitView({ "variant": variant });
            }
        }
    }

    angular.module('umbraco.directives').component('umbVariantContent', umbVariantContent);

})();

----
content/umbtabbedcontent.directive.js
(function () {
    'use strict';

    /** This directive is used to render out the current variant tabs and properties and exposes an API for other directives to consume  */
    function tabbedContentDirective($timeout, $filter, contentEditingHelper, contentTypeHelper) {

        function link($scope, $element) {

            var appRootNode = $element[0];

            // Directive for cached property groups.
            var propertyGroupNodesDictionary = {};

            var scrollableNode = appRootNode.closest(".umb-scrollable");

            $scope.activeTabAlias = null;
            $scope.tabs = [];
            $scope.allowUpdate = $scope.content.allowedActions.includes('A');
            $scope.allowEditInvariantFromNonDefault = Umbraco.Sys.ServerVariables.umbracoSettings.allowEditInvariantFromNonDefault;

            $scope.$watchCollection('content.tabs', (newValue) => {

                contentTypeHelper.defineParentAliasOnGroups(newValue);
                contentTypeHelper.relocateDisorientedGroups(newValue);

                // make a collection with only tabs and not all groups
                $scope.tabs = $filter("filter")(newValue, (tab) => {
                    return tab.type === contentTypeHelper.TYPE_TAB;
                });

                if ($scope.tabs.length > 0) {
                    // if we have tabs and some groups that doesn't belong to a tab we need to render those on an "Other" tab.
                    contentEditingHelper.registerGenericTab(newValue);

                    $scope.setActiveTab($scope.tabs[0]);

                    scrollableNode.removeEventListener("scroll", onScroll);
                    scrollableNode.removeEventListener("mousewheel", cancelScrollTween);

                // only trigger anchor scroll when there are no tabs
                } else {
                    scrollableNode.addEventListener("scroll", onScroll);
                    scrollableNode.addEventListener("mousewheel", cancelScrollTween);
                }
            });

            function onScroll(event) {

                var viewFocusY = scrollableNode.scrollTop + scrollableNode.clientHeight * .5;

                for(var i in $scope.content.tabs) {
                    var group = $scope.content.tabs[i];
                    var node = propertyGroupNodesDictionary[group.id];

                    if (!node) {
                        return;
                    }

                    if (viewFocusY >= node.offsetTop && viewFocusY <= node.offsetTop + node.clientHeight) {
                        setActiveAnchor(group);
                        return;
                    }
                }

            }

            function setActiveAnchor(tab) {
                if (tab.active !== true) {
                    var i = $scope.content.tabs.length;
                    while(i--) {
                        $scope.content.tabs[i].active = false;
                    }
                    tab.active = true;
                }
            }

            function getActiveAnchor() {
                var i = $scope.content.tabs.length;
                while(i--) {
                    if ($scope.content.tabs[i].active === true)
                        return $scope.content.tabs[i];
                }
                return false;
            }

            function getScrollPositionFor(id) {
                if (propertyGroupNodesDictionary[id]) {
                    return propertyGroupNodesDictionary[id].offsetTop - 20;// currently only relative to closest relatively positioned parent
                }
                return null;
            }

            function scrollTo(id) {
                var y = getScrollPositionFor(id);
                if (getScrollPositionFor !== null) {

                    var viewportHeight = scrollableNode.clientHeight;
                    var from = scrollableNode.scrollTop;
                    var to = Math.min(y, scrollableNode.scrollHeight - viewportHeight);

                    var animeObject = {_y: from};
                    $scope.scrollTween = anime({
                        targets: animeObject,
                        _y: to,
                        easing: 'easeOutExpo',
                        duration: 200 + Math.min(Math.abs(to-from)/viewportHeight*100, 400),
                        update: () => {
                            scrollableNode.scrollTo(0, animeObject._y);
                        }
                    });

                }
            }

            function jumpTo(id) {
                var y = getScrollPositionFor(id);
                if (getScrollPositionFor !== null) {
                    cancelScrollTween();
                    scrollableNode.scrollTo(0, y);
                }
            }

            function cancelScrollTween() {
                if($scope.scrollTween) {
                    $scope.scrollTween.pause();
                }
            }

            $scope.registerPropertyGroup = function(element, appAnchor) {
                propertyGroupNodesDictionary[appAnchor] = element;
            };

            $scope.setActiveTab = function(tab) {
                $scope.activeTabAlias = tab.alias;
                $scope.tabs.forEach(tab => tab.active = false);
                tab.active = true;
            };

            $scope.$on("editors.apps.appChanged", function($event, $args) {
                // if app changed to this app, then we want to scroll to the current anchor
                if($args.app.alias === "umbContent" && $scope.tabs.length === 0) {
                    var activeAnchor = getActiveAnchor();
                    $timeout(jumpTo.bind(null, [activeAnchor.id]));
                }
            });

            $scope.$on("editors.apps.appAnchorChanged", function($event, $args) {
                if($args.app.alias === "umbContent") {
                    setActiveAnchor($args.anchor);
                    scrollTo($args.anchor.id);
                }
            });

            //ensure to unregister from all dom-events
            $scope.$on('$destroy', function () {
                cancelScrollTween();
                scrollableNode.removeEventListener("scroll", onScroll);
                scrollableNode.removeEventListener("mousewheel", cancelScrollTween);
            });

        }

        function controller($scope) {

            //expose the property/methods for other directives to use
            this.content = $scope.content;

            if($scope.contentNodeModel) {
                $scope.defaultVariant = _.find($scope.contentNodeModel.variants, variant => {
                    // defaultVariant will never have segment. Wether it has a language or not depends on the setup.
                    return !variant.segment && ((variant.language && variant.language.isDefault) || (!variant.language));
                });
            }

            $scope.unlockInvariantValue = function(property) {
                property.unlockInvariantValue = !property.unlockInvariantValue;
            };

            $scope.$watch("tabbedContentForm.$dirty",
                function (newValue, oldValue) {
                    if (newValue === true) {
                        $scope.content.isDirty = true;
                    }
                }
            );

            $scope.propertyEditorDisabled = function (property) {
                if (property.unlockInvariantValue) {
                    return false;
                }

                var contentLanguage = $scope.content.language;
                var variants = $scope.contentNodeModel && $scope.contentNodeModel.variants || [];
                var otherCreatedVariants = variants.filter(x => x.compositeId !== $scope.content.compositeId && (x.state !== "NotCreated" || x.name !== null)).length === 0;

                var canEditCulture = !contentLanguage ||
                    // If the property culture equals the content culture it can be edited
                    property.culture === contentLanguage.culture ||
                    // A culture-invariant property can only be edited by the default language variant
                    (otherCreatedVariants || $scope.allowEditInvariantFromNonDefault !== true && property.culture == null && contentLanguage.isDefault);

                var canEditSegment = property.segment === $scope.content.segment;

                return !canEditCulture || !canEditSegment;
            }
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/content/umb-tabbed-content.html',
            controller: controller,
            link: link,
            scope: {
                content: "=", // in this context the content is the variant model.
                contentNodeModel: "=?", //contentNodeModel is the content model for the node,
                contentApp: "=?" // contentApp is the origin app model for this view
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbTabbedContent', tabbedContentDirective);

})();

----
content/umbvariantstate.directive.js
﻿(function () {
    'use strict';

    function umbVariantStateController($scope, $element) {

        var vm = this;
        
    }

    var umbVariantStateComponent = {
        templateUrl: 'views/components/content/umb-variant-state.html',
        bindings: {
            variant: "<"
        },
        controllerAs: 'vm',
        controller: umbVariantStateController
    };

    angular.module("umbraco.directives")
        .component('umbVariantState', umbVariantStateComponent);

})();

----
content/edit.controller.js
(function () {
    'use strict';

    function ContentEditController($rootScope, $scope, $routeParams, $q, $window,
        appState, contentResource, entityResource, navigationService, notificationsService, contentAppHelper,
        serverValidationManager, contentEditingHelper, localizationService, formHelper, umbRequestHelper,
        editorState, $http, eventsService, overlayService, $location, localStorageService, treeService,
        $exceptionHandler, uploadTracker) {

        var evts = [];
        var infiniteMode = $scope.infiniteModel && $scope.infiniteModel.infiniteMode;
        var watchingCulture = false;

        //setup scope vars
        $scope.defaultButton = null;
        $scope.subButtons = [];

        $scope.page = {};
        $scope.page.loading = false;
        $scope.page.menu = {};
        $scope.page.menu.currentNode = null;
        $scope.page.menu.currentSection = appState.getSectionState("currentSection");
        $scope.page.listViewPath = null;
        $scope.page.isNew = $scope.isNew ? true : false;

        if (infiniteMode) {
            $scope.page.allowInfinitePublishAndClose = $scope.infiniteModel.allowPublishAndClose;
            $scope.page.allowInfiniteSaveAndClose = $scope.infiniteModel.allowSaveAndClose;
        }

        $scope.page.buttonGroupState = "init";
        $scope.page.hideActionsMenu = infiniteMode ? true : false;
        $scope.page.hideChangeVariant = false;
        $scope.allowOpen = true;
        $scope.activeApp = null;

        //initializes any watches
        function startWatches(content) {

            //watch for changes to isNew, set the page.isNew accordingly and load the breadcrumb if we can
            $scope.$watch('isNew', function (newVal, oldVal) {

                $scope.page.isNew = Object.toBoolean(newVal);

                //We fetch all ancestors of the node to generate the footer breadcrumb navigation
                if (content.parentId && content.parentId !== -1 && content.parentId !== -20) {
                    loadBreadcrumb();
                    if (!watchingCulture) {
                        $scope.$watch('culture',
                            function (value, oldValue) {
                                if (value !== oldValue) {
                                    loadBreadcrumb();
                                }
                            });
                    }
                }
            });

        }

        //this initializes the editor with the data which will be called more than once if the data is re-loaded
        function init() {

            var content = $scope.content;
            if (content.id && content.isChildOfListView && content.trashed === false) {
                $scope.page.listViewPath = "/content/content/edit/" + content.parentId
                    + "?list=" + $routeParams.list
                    + "&page=" + $routeParams.page
                    + "&filter=" + $routeParams.filter
                    + "&orderBy=" + $routeParams.orderBy
                    + "&orderDirection=" + $routeParams.orderDirection;
            }

            // we need to check wether an app is present in the current data, if not we will present the default app.
            var isAppPresent = false;

            // on first init, we dont have any apps. but if we are re-initializing, we do, but ...
            if ($scope.activeApp) {

                _.forEach(content.apps, function (app) {
                    if (app.alias === $scope.activeApp.alias) {
                        isAppPresent = true;
                        $scope.appChanged(app);
                    }
                });

                if (isAppPresent === false) {
                    // active app does not exist anymore.
                    $scope.activeApp = null;
                }
            }

            // if we still dont have a app, lets show the first one:
            if ($scope.activeApp === null && content.apps.length) {
                $scope.appChanged(content.apps[0]);
            }
            // otherwise make sure the save options are up to date with the current content state
            else {
                createButtons($scope.content);
            }

            editorState.set(content);

            bindEvents();

            resetVariantFlags();
        }

        function loadBreadcrumb() {
            // load the parent breadcrumb when creating new content
            var id = $scope.page.isNew ? $scope.content.parentId : $scope.content.id;
            if (!id) {
                return;
            }
            entityResource.getAncestors(id, "document", $scope.culture)
                .then(function (anc) {
                    $scope.ancestors = anc;
                });
        }

        /**
         * This will reset isDirty flags if save is true.
         * When working with multiple variants, this will set the save/publish flags of each one to false.
         * When working with a single variant, this will set the publish flag to false and the save flag to true.
         */
        function resetVariantFlags() {
            if ($scope.content.variants.length > 1) {
                for (var i = 0; i < $scope.content.variants.length; i++) {
                    var v = $scope.content.variants[i];
                    if (v.save) {
                        v.isDirty = false;
                    }
                    v.save = false;
                    v.publish = false;
                }
            }
            else {
                if ($scope.content.variants[0].save) {
                    $scope.content.variants[0].isDirty = false;
                }
                $scope.content.variants[0].save = true;
                $scope.content.variants[0].publish = false;
            }
        }

        /** Returns true if the content item varies by culture */
        function hasVariants(content) {
            return content.variants.length > 1;
        }

        function reload() {
            $scope.page.loading = true;

            if ($scope.page.isNew) {
                loadScaffold().then(function () {
                    $scope.page.loading = false;
                });
            } else {
                loadContent().then(function () {
                    $scope.page.loading = false;
                });
            }
        }

        function bindEvents() {
            //bindEvents can be called more than once and we don't want to have multiple bound events
            for (var e in evts) {
                eventsService.unsubscribe(evts[e]);
            }

            evts.push(eventsService.on("editors.documentType.saved", function (name, args) {
                // if this content item uses the updated doc type we need to reload the content item
                if (args && args.documentType && $scope.content.documentType.id === args.documentType.id) {
                    reload();
                }
            }));

            evts.push(eventsService.on("editors.content.reload", function (name, args) {
                if (args && args.node && $scope.content.id === args.node.id) {
                    reload();
                    loadBreadcrumb();
                    syncTreeNode($scope.content, $scope.content.path);
                }
            }));

            evts.push(eventsService.on("uploadTracker.uploadsInProgressChanged", function (name, args) {
                $scope.page.uploadsInProgress = args.uploadsInProgress.filter(x => x.entityKey === $scope.content.key).length > 0;
            }));

            evts.push(eventsService.on("rte.file.uploading", function () {
                $scope.page.saveButtonState = "busy";
                $scope.page.buttonGroupState = "busy";

            }));

            evts.push(eventsService.on("rte.file.uploaded", function () {
                $scope.page.saveButtonState = "success";
                $scope.page.buttonGroupState = "success";
            }));

            evts.push(eventsService.on("rte.shortcut.save", function () {
                if ($scope.page.showSaveButton) {
                    $scope.save();
                }
            }));

            evts.push(eventsService.on("rte.shortcut.saveAndPublish", function () {
                $scope.saveAndPublish();
            }));

            evts.push(eventsService.on("content.saved", function () {
                // Clear out localstorage keys that start with tinymce__
                // When we save/perist a content node
                // NOTE: clearAll supports a RegEx pattern of items to remove
                localStorageService.clearAll(/^tinymce__/);
            }));
        }

        function appendRuntimeData() {
            $scope.content.variants.forEach((variant) => {
                variant.compositeId = contentEditingHelper.buildCompositeVariantId(variant);
                variant.htmlId = "_content_variant_" + variant.compositeId + "_";
            });
        }

        /**
         *  This does the content loading and initializes everything, called on first load
         */
        function loadContent() {

            //we are editing so get the content item from the server
            return $scope.getMethod()($scope.contentId)
                .then(function (data) {

                    $scope.content = data;

                    appendRuntimeData();
                    init();
                    startWatches($scope.content);

                    syncTreeNode($scope.content, $scope.content.path, true);

                    resetLastListPageNumber($scope.content);

                    eventsService.emit("content.loaded", { content: $scope.content });

                    return $q.resolve($scope.content);
                });
        }

        /**
        *  This loads the content scaffold for when creating new content
        */
        function loadScaffold() {
            //we are creating so get an empty content item
            return $scope.getScaffoldMethod()()
                .then(function (data) {

                    $scope.content = data;

                    appendRuntimeData();
                    init();
                    startWatches($scope.content);

                    resetLastListPageNumber($scope.content);

                    eventsService.emit("content.newReady", { content: $scope.content });

                    return $q.resolve($scope.content);

                });
        }

        /**
         * Create the save/publish/preview buttons for the view
         * @param {any} content the content node
         * @param {any} app the active content app
         */
        function createButtons(content) {

            var isBlueprint = content.isBlueprint;

            if ($scope.page.isNew && $location.path().search(/contentBlueprints/i) !== -1) {
               isBlueprint = true;
            }

            // for trashed and element type items, the save button is the primary action - otherwise it's a secondary action
            $scope.page.saveButtonStyle = content.trashed || content.isElement || isBlueprint ? "primary" : "info";
            // only create the save/publish/preview buttons if the
            // content app is "Conent"

            if ($scope.activeApp && !contentAppHelper.isContentBasedApp($scope.activeApp)) {
                $scope.defaultButton = null;
                $scope.subButtons = null;
                $scope.page.showSaveButton = false;
                $scope.page.showPreviewButton = false;
                return;
            }

            // create the save button
            if (_.contains($scope.content.allowedActions, "A")) {
                $scope.page.showSaveButton = true;
                // add ellipsis to the save button if it opens the variant overlay
                $scope.page.saveButtonEllipsis = content.variants && content.variants.length > 1 ? "true" : "false";
            } else {
                $scope.page.showSaveButton = false;
            }

            // create the pubish combo button
            $scope.page.buttonGroupState = "init";
            var buttons = contentEditingHelper.configureContentEditorButtons({
                create: $scope.page.isNew,
                content: content,
                methods: {
                    saveAndPublish: $scope.saveAndPublish,
                    sendToPublish: $scope.sendToPublish,
                    unpublish: $scope.unpublish,
                    schedulePublish: $scope.schedule,
                    publishDescendants: $scope.publishDescendants
                }
            });

            $scope.defaultButton = buttons.defaultButton;
            $scope.subButtons = buttons.subButtons;
            $scope.page.showPreviewButton = true;
        }

        /** Syncs the content item to it's tree node - this occurs on first load and after saving */
        function syncTreeNode(content, path, initialLoad, reloadChildren) {

            if (infiniteMode || !path) {
                return;
            }

            if (!$scope.content.isChildOfListView) {
                navigationService.syncTree({ tree: $scope.treeAlias, path: path.split(","), forceReload: initialLoad !== true })
                    .then(function (syncArgs) {
                        $scope.page.menu.currentNode = syncArgs.node;
                        if (reloadChildren && syncArgs.node.expanded) {
                            treeService.loadNodeChildren({ node: syncArgs.node });
                        }
                    }, function () {
                        //handle the rejection
                        console.log("A problem occurred syncing the tree! A path is probably incorrect.")
                    });
            }
            else if (initialLoad === true) {

                //it's a child item, just sync the ui node to the parent
                navigationService.syncTree({ tree: $scope.treeAlias, path: path.substring(0, path.lastIndexOf(",")).split(","), forceReload: initialLoad !== true });

                //if this is a child of a list view and it's the initial load of the editor, we need to get the tree node
                // from the server so that we can load in the actions menu.
                umbRequestHelper.resourcePromise(
                    $http.get(content.treeNodeUrl),
                    'Failed to retrieve data for child node ' + content.id).then(function (node) {
                        $scope.page.menu.currentNode = node;
                    });
            }
        }

        function checkValidility() {
            //Get all controls from the 'contentForm'
            var allControls = $scope.contentForm.$getControls();

            //An array to store items in when we find child form fields (no matter how many deep nested forms)
            var childFieldsToMarkAsValid = [];

            //Exclude known formControls 'contentHeaderForm' and 'tabbedContentForm'
            //Check property - $name === "contentHeaderForm"
            allControls = _.filter(allControls, function (obj) {
                return obj.$name !== 'contentHeaderForm' && obj.$name !== 'tabbedContentForm' && obj.hasOwnProperty('$submitted');
            });

            for (var i = 0; i < allControls.length; i++) {
                var nestedForm = allControls[i];

                //Get Nested Controls of this form in the loop
                var nestedFormControls = nestedForm.$getControls();

                //Need to recurse through controls (could be more nested forms)
                childFieldsToMarkAsValid = recurseFormControls(nestedFormControls, childFieldsToMarkAsValid);
            }

            return childFieldsToMarkAsValid;
        }

        //Controls is the
        function recurseFormControls(controls, array) {

            //Loop over the controls
            for (var i = 0; i < controls.length; i++) {
                var controlItem = controls[i];

                //Check if the controlItem has a property ''
                if (controlItem.hasOwnProperty('$submitted')) {
                    //This item is a form - so lets get the child controls of it & recurse again
                    var childFormControls = controlItem.$getControls();
                    recurseFormControls(childFormControls, array);
                }
                else {
                    //We can assume its a field on a form
                    if (controlItem.hasOwnProperty('$error')) {
                        //Set the validlity of the error/s to be valid
                        //String of keys of error invalid messages
                        var errorKeys = [];

                        for (var key in controlItem.$error) {
                            errorKeys.push(key);
                            controlItem.$setValidity(key, true);
                        }

                        //Create a basic obj - storing the control item & the error keys
                        var obj = { 'control': controlItem, 'errorKeys': errorKeys };

                        //Push the updated control into the array - so we can set them back
                        array.push(obj);
                    }
                }
            }
            return array;
        }

        function resetNestedFieldValiation(array) {
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                //Item is an object containing two props
                //'control' (obj) & 'errorKeys' (string array)
                var fieldControl = item.control;
                var fieldErrorKeys = item.errorKeys;

                for (var j = 0; j < fieldErrorKeys.length; j++) {
                    fieldControl.$setValidity(fieldErrorKeys[j], false);
                }
            }
        }

        function ensureDirtyIsSetIfAnyVariantIsDirty() {

            $scope.contentForm.$dirty = false;

            for (var i = 0; i < $scope.content.variants.length; i++) {
                if ($scope.content.variants[i].isDirty) {
                    $scope.contentForm.$dirty = true;
                    return;
                }
            }
        }

        // This is a helper method to reduce the amount of code repitition for actions: Save, Publish, SendToPublish
        function performSave(args) {
            //Used to check validility of nested form - coming from Content Apps mostly
            //Set them all to be invalid
            var fieldsToRollback = checkValidility();
            eventsService.emit("content.saving", { content: $scope.content, action: args.action });

            return contentEditingHelper.contentEditorPerformSave({
                saveMethod: args.saveMethod,
                scope: $scope,
                content: $scope.content,
                create: $scope.page.isNew,
                action: args.action,
                showNotifications: args.showNotifications,
                softRedirect: true,
                skipValidation: args.skipValidation
            }).then(function (data) {
                //success
                init();

                //needs to be manually set for infinite editing mode
                $scope.page.isNew = false;

                syncTreeNode($scope.content, data.path, false, args.reloadChildren);

                eventsService.emit("content.saved", { content: $scope.content, action: args.action, valid: true });

                if($scope.contentForm.$invalid !== true) {
                    resetNestedFieldValiation(fieldsToRollback);
                }
                ensureDirtyIsSetIfAnyVariantIsDirty();

                return $q.when(data);
            },
                function (err) {
                    syncTreeNode($scope.content, $scope.content.path);

                    if($scope.contentForm.$invalid !== true) {
                        resetNestedFieldValiation(fieldsToRollback);
                    }
                    if (err && err.status === 400 && err.data) {
                        // content was saved but is invalid.
                        eventsService.emit("content.saved", { content: $scope.content, action: args.action, valid: false });
                    }

                    return $q.reject(err);
                });
        }

        function clearNotifications(content) {
            if (content.notifications) {
                content.notifications = [];
            }
            if (content.variants) {
                for (var i = 0; i < content.variants.length; i++) {
                    if (content.variants[i].notifications) {
                        content.variants[i].notifications = [];
                    }
                }
            }
        }

        function resetLastListPageNumber(content) {
            // We're using rootScope to store the page number for list views, so if returning to the list
            // we can restore the page.  If we've moved on to edit a piece of content that's not the list or it's children
            // we should remove this so as not to confuse if navigating to a different list
            if (!content.isChildOfListView && !content.isContainer) {
                $rootScope.lastListViewPageViewed = null;
            }
        }

        /**
         * Used to clear the dirty state for successfully saved variants when not all variant saving was successful
         * @param {any} variants
         */
        function clearDirtyState(variants) {
            for (var i = 0; i < variants.length; i++) {
                var v = variants[i];
                if (v.notifications) {
                    var isSuccess = _.find(v.notifications, function (n) {
                        return n.type === 3; //this is a success notification
                    });
                    if (isSuccess) {
                        v.isDirty = false;
                    }
                }
            }
        }

        function handleHttpException(err) {
            if (err && !err.status) {
                $exceptionHandler(err);
            }
        }

        /** Just shows a simple notification that there are client side validation issues to be fixed */
        function showValidationNotification() {
            //TODO: We need to make the validation UI much better, there's a lot of inconsistencies in v8 including colors, issues with the property groups and validation errors between variants

            //need to show a notification else it's not clear there was an error.
            localizationService.localizeMany([
                "speechBubbles_validationFailedHeader",
                "speechBubbles_validationFailedMessage"
            ]
            ).then(function (data) {
                notificationsService.error(data[0], data[1]);
            });
        }

        if ($scope.page.isNew) {

            $scope.page.loading = true;

            loadScaffold().then(function () {
                $scope.page.loading = false;
            });
        }
        else {

            $scope.page.loading = true;

            loadContent().then(function () {
                $scope.page.loading = false;
            });
        }

        $scope.unpublish = function () {
            clearNotifications($scope.content);
            if (formHelper.submitForm({ scope: $scope, action: "unpublish", skipValidation: true })) {
                var dialog = {
                    parentScope: $scope,
                    view: "views/content/overlays/unpublish.html",
                    variants: $scope.content.variants, //set a model property for the dialog
                    skipFormValidation: true, //when submitting the overlay form, skip any client side validation
                    includeUnpublished: false,
                    submitButtonLabelKey: "content_unpublish",
                    submitButtonStyle: "warning",
                    submit: function (model) {

                        model.submitButtonState = "busy";

                        var selectedVariants = _.filter(model.variants, v => v.save && v.language); //ignore invariant
                        var culturesForUnpublishing = _.map(selectedVariants, v => v.language.culture);

                        contentResource.unpublish($scope.content.id, culturesForUnpublishing)
                            .then(function (data) {
                                formHelper.resetForm({ scope: $scope });
                                contentEditingHelper.reBindChangedProperties($scope.content, data);
                                init();
                                syncTreeNode($scope.content, data.path);
                                $scope.page.buttonGroupState = "success";
                                eventsService.emit("content.unpublished", { content: $scope.content });
                                overlayService.close();
                            }, function (err) {
                                formHelper.resetForm({ scope: $scope, hasErrors: true });
                                $scope.page.buttonGroupState = 'error';
                                handleHttpException(err);
                            });
                    },
                    close: function () {
                        overlayService.close();
                    }
                };

                overlayService.open(dialog);
            }
        };

        $scope.sendToPublish = function () {
            clearNotifications($scope.content);
            if (hasVariants($scope.content)) {
                //before we launch the dialog we want to execute all client side validations first
                if (formHelper.submitForm({ scope: $scope, action: "publish" })) {

                    var dialog = {
                        parentScope: $scope,
                        view: "views/content/overlays/sendtopublish.html",
                        variants: $scope.content.variants, //set a model property for the dialog
                        skipFormValidation: true, //when submitting the overlay form, skip any client side validation
                        submitButtonLabelKey: "buttons_saveToPublish",
                        submit: function (model) {
                            model.submitButtonState = "busy";
                            clearNotifications($scope.content);
                            //we need to return this promise so that the dialog can handle the result and wire up the validation response
                            return performSave({
                                saveMethod: contentResource.sendToPublish,
                                action: "sendToPublish",
                                showNotifications: false
                            }).then(function (data) {
                                //show all notifications manually here since we disabled showing them automatically in the save method
                                formHelper.showNotifications(data);
                                clearNotifications($scope.content);
                                overlayService.close();
                                return $q.when(data);
                            },
                            function (err) {
                                clearDirtyState($scope.content.variants);
                                model.submitButtonState = "error";
                                //re-map the dialog model since we've re-bound the properties
                                dialog.variants = $scope.content.variants;

                                handleHttpException(err);
                            });
                        },
                        close: function () {
                            overlayService.close();
                        }
                    };

                    overlayService.open(dialog);
                }
                else {
                    showValidationNotification();
                }
            }
            else {
                $scope.page.buttonGroupState = "busy";
                return performSave({
                    saveMethod: contentResource.sendToPublish,
                    action: "sendToPublish"
                }).then(function () {
                    $scope.page.buttonGroupState = "success";
                }, function (err) {
                    $scope.page.buttonGroupState = "error";
                    handleHttpException(err);
                });;
            }
        };

        $scope.saveAndPublish = function (submitButtonLabelKey) {
            var deferred = $q.defer();
            clearNotifications($scope.content);
            if (hasVariants($scope.content)) {
                //before we launch the dialog we want to execute all client side validations first
                if (formHelper.submitForm({ scope: $scope, action: "publish" })) {
                    var dialog = {
                        parentScope: $scope,
                        view: "views/content/overlays/publish.html",
                        variants: $scope.content.variants, //set a model property for the dialog
                        skipFormValidation: true, //when submitting the overlay form, skip any client side validation
                        submitButtonLabelKey: submitButtonLabelKey || "buttons_saveAndPublish",
                        submit: function (model) {
                            model.submitButtonState = "busy";
                            clearNotifications($scope.content);
                            //we need to return this promise so that the dialog can handle the result and wire up the validation response
                            return performSave({
                                saveMethod: contentResource.publish,
                                action: "publish",
                                showNotifications: false
                            }).then(function (data) {
                                //show all notifications manually here since we disabled showing them automatically in the save method
                                formHelper.showNotifications(data);
                                clearNotifications($scope.content);
                                overlayService.close();
                                deferred.resolve();
                                return $q.when(data);
                            }, function (err) {
                                clearDirtyState($scope.content.variants);
                                model.submitButtonState = "error";
                                //re-map the dialog model since we've re-bound the properties
                                dialog.variants = $scope.content.variants;

                                //ensure error messages are displayed
                                formHelper.showNotifications(err.data);
                                clearNotifications($scope.content);
                                
                                handleHttpException(err);
                                deferred.reject(err);
                            });
                        },
                        close: function () {
                            overlayService.close();
                            deferred.reject();
                        }
                    };
                    overlayService.open(dialog);
                }
                else {
                    showValidationNotification();
                    deferred.reject();
                }
            }
            else {
                //ensure the flags are set
                $scope.content.variants[0].save = true;
                $scope.content.variants[0].publish = true;
                $scope.page.buttonGroupState = "busy";
                return performSave({
                    saveMethod: contentResource.publish,
                    action: "publish"
                }).then(function () {
                    $scope.page.buttonGroupState = "success";
                    deferred.resolve();
                }, function (err) {
                    $scope.page.buttonGroupState = "error";
                    handleHttpException(err);
                    deferred.reject(err);
                });
            }

            return deferred.promise;
        };

        $scope.save = function (submitButtonLabelKey) {
            var deferred = $q.defer();
            clearNotifications($scope.content);
            // TODO: Add "..." to save button label if there are more than one variant to publish - currently it just adds the elipses if there's more than 1 variant
            if (hasVariants($scope.content)) {
                var dialog = {
                    parentScope: $scope,
                    view: "views/content/overlays/save.html",
                    variants: $scope.content.variants, //set a model property for the dialog
                    skipFormValidation: true, //when submitting the overlay form, skip any client side validation
                    submitButtonLabelKey: submitButtonLabelKey || "buttons_save",
                    submit: function (model) {
                        model.submitButtonState = "busy";
                        clearNotifications($scope.content);
                        //we need to return this promise so that the dialog can handle the result and wire up the validation response
                        return performSave({
                            saveMethod: $scope.saveMethod(),
                            action: "save",
                            showNotifications: false,
                            skipValidation: true
                        }).then(function (data) {
                            //show all notifications manually here since we disabled showing them automatically in the save method
                            formHelper.showNotifications(data);
                            clearNotifications($scope.content);
                            overlayService.close();
                            deferred.resolve();
                            return $q.when(data);
                        }, function (err) {
                            clearDirtyState($scope.content.variants);
                            //model.submitButtonState = "error";
                            // Because this is the "save"-action, then we actually save though there was a validation error, therefor we will show success and display the validation errors politely.
                            if(err && err.data && err.data.ModelState && Object.keys(err.data.ModelState).length > 0) {
                                model.submitButtonState = "success";
                            } else {
                                model.submitButtonState = "error";
                                //re-map the dialog model since we've re-bound the properties
                                dialog.variants = $scope.content.variants;

                                //ensure error messages are displayed
                                formHelper.showNotifications(err.data);
                                clearNotifications($scope.content);

                                handleHttpException(err);
                            }
                            deferred.reject();
                        })
                    },
                    close: function (oldModel) {
                        overlayService.close();
                        deferred.reject();
                    }
                };

                overlayService.open(dialog);
            }
            else {
                //ensure the flags are set
                $scope.content.variants[0].save = true;
                $scope.page.saveButtonState = "busy";
                return performSave({
                    saveMethod: $scope.saveMethod(),
                    action: "save",
                    skipValidation: true
                }).then(function () {
                    $scope.page.saveButtonState = "success";
                    deferred.resolve();
                }, function (err) {
                    // Because this is the "save"-action, then we actually save though there was a validation error, therefor we will show success and display the validation errors politely.
                    if(err && err.data && err.data.ModelState && Object.keys(err.data.ModelState).length > 0) {
                        $scope.page.saveButtonState = "success";
                    } else {
                        $scope.page.saveButtonState = "error";
                    }
                    handleHttpException(err);
                    deferred.reject();
                });
            }

            return deferred.promise;
        };

        $scope.schedule = function () {
            clearNotifications($scope.content);
            //before we launch the dialog we want to execute all client side validations first
            if (formHelper.submitForm({ scope: $scope, action: "schedule" })) {
                if (!hasVariants($scope.content)) {
                    //ensure the flags are set
                    $scope.content.variants[0].save = true;
                }

                var dialog = {
                    parentScope: $scope,
                    view: "views/content/overlays/schedule.html",
                    variants: Utilities.copy($scope.content.variants), //set a model property for the dialog
                    skipFormValidation: true, //when submitting the overlay form, skip any client side validation
                    submitButtonLabelKey: "buttons_schedulePublish",
                    submit: function (model) {
                        for (let i = 0; i < $scope.content.variants.length; i++) {
                            $scope.content.variants[i].releaseDate = model.variants[i].releaseDate;
                            $scope.content.variants[i].expireDate = model.variants[i].expireDate;
                            $scope.content.variants[i].releaseDateFormatted = model.variants[i].releaseDateFormatted;
                            $scope.content.variants[i].expireDateFormatted = model.variants[i].expireDateFormatted;
                            $scope.content.variants[i].save = model.variants[i].save;
                        }

                        model.submitButtonState = "busy";
                        clearNotifications($scope.content);

                        //we need to return this promise so that the dialog can handle the result and wire up the validation response
                        return performSave({
                            saveMethod: contentResource.saveSchedule,
                            action: "schedule",
                            showNotifications: false
                        }).then(function (data) {
                            //show all notifications manually here since we disabled showing them automatically in the save method
                            formHelper.showNotifications(data);
                            clearNotifications($scope.content);
                            overlayService.close();
                            return $q.when(data);
                        }, function (err) {
                            clearDirtyState($scope.content.variants);
                            //if this is invariant, show the notification errors, else they'll be shown inline with the variant
                            if (!hasVariants($scope.content)) {
                                formHelper.showNotifications(err.data);
                            }
                            model.submitButtonState = "error";
                            //re-map the dialog model since we've re-bound the properties
                            dialog.variants = Utilities.copy($scope.content.variants);
                            handleHttpException(err);
                        });

                    },
                    close: function () {
                        overlayService.close();
                    }
                };
                overlayService.open(dialog);
            }
            else {
                showValidationNotification();
            }
        };

        $scope.publishDescendants = function () {
            clearNotifications($scope.content);
            //before we launch the dialog we want to execute all client side validations first
            if (formHelper.submitForm({ scope: $scope, action: "publishDescendants" })) {

                if (!hasVariants($scope.content)) {
                    //ensure the flags are set
                    $scope.content.variants[0].save = true;
                    $scope.content.variants[0].publish = true;
                }

                var dialog = {
                    parentScope: $scope,
                    view: "views/content/overlays/publishdescendants.html",
                    variants: $scope.content.variants, //set a model property for the dialog
                    skipFormValidation: true, //when submitting the overlay form, skip any client side validation
                    submitButtonLabelKey: "buttons_publishDescendants",
                    submit: function (model) {
                        model.submitButtonState = "busy";
                        clearNotifications($scope.content);

                        //we need to return this promise so that the dialog can handle the result and wire up the validation response
                        return performSave({
                            saveMethod: function (content, create, files, showNotifications) {
                                return contentResource.publishWithDescendants(content, create, model.includeUnpublished, files, showNotifications);
                            },
                            action: "publishDescendants",
                            showNotifications: false,
                            reloadChildren: model.includeUnpublished
                        }).then(function (data) {
                            //show all notifications manually here since we disabled showing them automatically in the save method
                            formHelper.showNotifications(data);
                            clearNotifications($scope.content);
                            overlayService.close();
                            return $q.when(data);
                        }, function (err) {
                            clearDirtyState($scope.content.variants);
                            //if this is invariant, show the notification errors, else they'll be shown inline with the variant
                            if (!hasVariants($scope.content)) {
                                formHelper.showNotifications(err.data);
                            }
                            model.submitButtonState = "error";
                            //re-map the dialog model since we've re-bound the properties
                            dialog.variants = $scope.content.variants;
                            handleHttpException(err);
                        });

                    },
                    close: function () {
                        overlayService.close();
                    }
                };
                overlayService.open(dialog);
            }
            else {
                showValidationNotification();
            }
        };

        $scope.preview = function (content) {

            const openPreviewWindow = () => {
                // Chromes popup blocker will kick in if a window is opened
                // without the initial scoped request. This trick will fix that.
              
              const previewWindow = $window.open(`preview/?id=${content.id}${$scope.culture ? `&culture=${$scope.culture}` : ''}`, 'umbpreview');

              previewWindow.addEventListener('load', () => {
                previewWindow.location.href = previewWindow.document.URL;
              });

            }

            //The user cannot save if they don't have access to do that, in which case we just want to preview
            //and that's it otherwise they'll get an unauthorized access message
            if (!_.contains(content.allowedActions, "A")) {
                openPreviewWindow();
            }
            else {
                var selectedVariant = $scope.content.variants[0];
                if ($scope.culture) {
                    var found = _.find($scope.content.variants, function (v) {
                        return (v.language && v.language.culture === $scope.culture);
                    });

                    if (found) {
                        selectedVariant = found;
                    }
                }

                //reset save flag for all variants
                $scope.content.variants.forEach(variant => variant.save = false);
                //ensure the save flag is set for the active variant
                selectedVariant.save = true;
                performSave({ saveMethod: $scope.saveMethod(), action: "save" }).then(function (data) {
                    openPreviewWindow()
                }, function (err) {
                    //validation issues ....
                });
            }
        };

        /* publish method used in infinite editing */
        $scope.publishAndClose = function (content) {
            $scope.publishAndCloseButtonState = "busy";
            $scope.saveAndPublish("buttons_publishAndClose").then(
                function() {
                    if ($scope.infiniteModel.submit) {
                        $scope.infiniteModel.contentNode = content;
                        $scope.infiniteModel.submit($scope.infiniteModel);
                    }
                    $scope.publishAndCloseButtonState = "success";
                },
                function() {
                    $scope.publishAndCloseButtonState = "error";
                }
            );
        };

        /* save method used in infinite editing */
        $scope.saveAndClose = function (content) {
            $scope.saveAndCloseButtonState = "busy";
            $scope.save("buttons_saveAndClose").then(
                function() {
                    if ($scope.infiniteModel.submit) {
                        $scope.infiniteModel.contentNode = content;
                        $scope.infiniteModel.submit($scope.infiniteModel);
                    }
                    $scope.saveAndCloseButtonState = "success";
                },
                function() {
                    $scope.saveAndCloseButtonState = "error";
                }
            );
        };

        /**
         * Call back when a content app changes
         * @param {any} app
         */
        $scope.appChanged = function (activeApp) {

            $scope.activeApp = activeApp;

            _.forEach($scope.content.apps, function (app) {
                app.active = false;
                if (app.alias === $scope.activeApp.alias) {
                    app.active = true;
                }
            });

            $scope.$broadcast("editors.apps.appChanged", { app: activeApp });

            createButtons($scope.content);

        };

        /**
         * Call back when a content app changes
         * @param {any} app
         */
        $scope.appAnchorChanged = function (app, anchor) {
            //send an event downwards
            $scope.$broadcast("editors.apps.appAnchorChanged", { app: app, anchor: anchor });
        };

        // methods for infinite editing
        $scope.close = function () {
            if ($scope.infiniteModel.close) {
                $scope.infiniteModel.close($scope.infiniteModel);
            }
        };

        /**
         * Call back when user click the back-icon
         */
        $scope.onBack = function () {
            if ($scope.infiniteModel && $scope.infiniteModel.close) {
                $scope.infiniteModel.close($scope.infiniteModel);
            } else {
                // navigate backwards if content has a parent.
                $location.path('/' + $routeParams.section + '/' + $routeParams.tree + '/' + $routeParams.method + '/' + $scope.content.parentId);
            }
        };

        //ensure to unregister from all events!
        $scope.$on('$destroy', function () {
            for (var e in evts) {
                eventsService.unsubscribe(evts[e]);
            }
            //since we are not notifying and clearing server validation messages when they are received due to how the variant
            //switching works, we need to ensure they are cleared when this editor is destroyed
            serverValidationManager.clear();
        });

    }

    function createDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/content/edit.html',
            controller: 'Umbraco.Editors.Content.EditorDirectiveController',
            scope: {
                contentId: "=",
                isNew: "=?",
                treeAlias: "@",
                page: "=?",
                saveMethod: "&",
                getMethod: "&",
                getScaffoldMethod: "&?",
                culture: "=?",
                segment: "=?",
                infiniteModel: "=?"
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').controller('Umbraco.Editors.Content.EditorDirectiveController', ContentEditController);
    angular.module('umbraco.directives').directive('contentEditor', createDirective);

})();

----
content/umbvariantcontenteditors.directive.js
﻿(function () {
    'use strict';

    /**
     * A component for split view content editing
     */
    var umbVariantContentEditors = {
        templateUrl: 'views/components/content/umb-variant-content-editors.html',
        bindings: {
            page: "<",
            content: "<",
            culture: "<",
            segment: "<",
            onSelectApp: "&?",
            onSelectAppAnchor: "&?",
            onBack: "&?",
            showBack: "<?"
        },
        controllerAs: 'vm',
        controller: umbVariantContentEditorsController
    };

    function umbVariantContentEditorsController($scope, $location, eventsService) {

        var prevContentDateUpdated = null;

        var vm = this;

        vm.$onInit = onInit;
        vm.$onChanges = onChanges;
        vm.$doCheck = doCheck;
        vm.$postLink = postLink;

        vm.openSplitView = openSplitView;
        vm.closeSplitView = closeSplitView;
        vm.selectVariant = selectVariant;
        vm.selectApp = selectApp;
        vm.selectAppAnchor = selectAppAnchor;
        vm.requestSplitView = requestSplitView;

        vm.getScope = getScope;// used by property editors to get a scope that is the root of split view, content apps etc.

        //Used to track how many content views there are (for split view there will be 2, it could support more in theory)
        vm.editors = [];

        /** Called when the component initializes */
        function onInit() {
            prevContentDateUpdated = Utilities.copy(vm.content.updateDate);
            setActiveVariant();
        }

        /** Called when the component has linked all elements, this is when the form controller is available */
        function postLink() {

        }

        /**
         * Watch for model changes
         * @param {any} changes
         */
        function onChanges(changes) {

            if (changes.culture && !changes.culture.isFirstChange() && changes.culture.currentValue !== changes.culture.previousValue) {
                setActiveVariant();
            } else if (changes.segment && !changes.segment.isFirstChange() && changes.segment.currentValue !== changes.segment.previousValue) {
                setActiveVariant();
            } else if (changes.content) {
                setActiveVariant();
            }
        }

        /** Allows us to deep watch whatever we want - executes on every digest cycle */
        function doCheck() {
            if (!Utilities.equals(vm.content.updateDate, prevContentDateUpdated)) {
                setActiveVariant();
                prevContentDateUpdated = Utilities.copy(vm.content.updateDate);
            }
        }

        /** This is called when the split view changes based on the umb-variant-content */
        function splitViewChanged() {
            //send an event downwards
            $scope.$broadcast("editors.content.splitViewChanged", { editors: vm.editors });
        }

        /**
         * Set the active variant based on the current culture or segment (query string)
         */
        function setActiveVariant() {
            // set the active variant
            var activeVariant = null;
            vm.content.variants.forEach(v => {
                if ((vm.culture === "invariant" || v.language && v.language.culture === vm.culture) && v.segment === vm.segment) {
                    activeVariant = v;
                }
            });

            if (!activeVariant) {
                // Set the first variant to active if we can't find it.
                // If the content item is invariant, then only one item exists in the array.
                activeVariant = vm.content.variants[0];
            }

            insertVariantEditor(0, activeVariant);

            if (vm.editors.length > 1) {
                //now re-sync any other editor content (i.e. if split view is open)
                for (var s = 1; s < vm.editors.length; s++) {
                    //get the variant from the scope model
                    var variant = vm.content.variants.find(v =>
                        (!v.language || v.language.culture === vm.editors[s].content.language.culture) && v.segment === vm.editors[s].content.segment);

                    vm.editors[s].content = variant;
                }
            }
            
            if (vm.content.variants.length > 1) {
                eventsService.emit('editors.content.cultureChanged', activeVariant.language);
            }
        }

        /**
         * Updates the editors collection for a given index for the specified variant
         * @param {any} index
         * @param {any} variant
         */
        function insertVariantEditor(index, variant) {

            if (vm.editors[index]) {
                if (vm.editors[index].content === variant) {
                    // This variant is already the content of the editor in this index.
                    return;
                }
                vm.editors[index].content.active = false;
            }
            variant.active = true;

            var variantCulture = variant.language ? variant.language.culture : "invariant";
            var variantSegment = variant.segment;

            var currentCulture = index < vm.editors.length ? vm.editors[index].culture : null;
            var currentSegment = index < vm.editors.length ? vm.editors[index].segment : null;
            
            // if index not already exists or if the culture or segment isnt identical then we do a replacement.
            if (index >= vm.editors.length || currentCulture !== variantCulture || currentSegment !== variantSegment) {

                //Not the current culture or segment which means we need to modify the array.
                //NOTE: It is not good enough to just replace the `content` object at a given index in the array
                // since that would mean that directives are not re-initialized.
                vm.editors.splice(index, 1, {
                    compositeId: variant.compositeId,
                    content: variant,
                    culture: variantCulture,
                    segment: variantSegment
                });
            }
            else {
                //replace the content of the editor, since the culture and segment is the same.
                vm.editors[index].content = variant;
            }
            
        }
        
        /**
         * Adds a new editor to the editors array to show content in a split view
         * @param {any} selectedVariant
         */
        function openSplitView(selectedVariant) {
            // enforce content contentApp in splitview.
            var contentApp = vm.content.apps.find(app => app.alias === "umbContent");
            if(contentApp) {
                selectApp(contentApp);
            }
            
            insertVariantEditor(vm.editors.length, selectedVariant);
            
            splitViewChanged();            
        }
        
        function requestSplitView(args) {
            var culture = args.culture;
            var segment = args.segment;

            var variant = vm.content.variants.find(v =>
                (!v.language || v.language.culture === culture) && v.segment === segment);

            if (variant != null) {
                openSplitView(variant);
            }
        }

        var unbindSplitViewRequest = eventsService.on("editors.content.splitViewRequest", (_, args) => requestSplitView(args));
        /** Closes the split view */
        function closeSplitView(editorIndex) {
            // TODO: hacking animation states - these should hopefully be easier to do when we upgrade angular
            var editor = vm.editors[editorIndex];
            vm.editors.splice(editorIndex, 1);
            editor.content.active = false;
            
            //update the current culture to reflect the last open variant (closing the split view corresponds to selecting the other variant)
            const culture = vm.editors[0].content.language ? vm.editors[0].content.language.culture : null;

            $location.search({"cculture": culture, "csegment": vm.editors[0].content.segment});
            splitViewChanged();
            unbindSplitViewRequest();
        }
        
        // if split view was never closed, the listener is not disposed when changing nodes - this unbinds it
        $scope.$on('$destroy', () => unbindSplitViewRequest());

        /**
         * Changes the currently selected variant
         * @param {any} variant This is the model of the variant/language drop down item in the editor header
         * @param {any} editorIndex The index of the editor being changed
         */
        function selectVariant(variant, editorIndex) {

            var variantCulture = variant.language ? variant.language.culture : "invariant";
            var variantSegment = variant.segment || null;
            
            // Check if we already have this editor open, if so, do nothing.
            if (vm.editors.find((editor) => (!editor.content.language || editor.content.language.culture === variantCulture) && editor.content.segment === variantSegment)) {
                return;
            }
            
            //if the editor index is zero, then update the query string to track the lang selection, otherwise if it's part
            //of a 2nd split view editor then update the model directly.
            if (editorIndex === 0) {
                //If we've made it this far, then update the query string.
                //The editor will respond to this query string changing.
                $location.search("cculture", variantCulture).search("csegment", variantSegment);
            }
            else {
                //update the editors collection
                insertVariantEditor(editorIndex, variant);                
            }            
        }

        /**
         * Stores the active app in a variable so we can remember it when changing language
         * @param {any} app This is the model of the selected app
         */
        function selectApp(app) {
            if(vm.onSelectApp) {
                vm.onSelectApp({"app": app});
            }
        }
        
        function selectAppAnchor(app, anchor) {
            if(vm.onSelectAppAnchor) {
                vm.onSelectAppAnchor({"app": app, "anchor": anchor});
            }
        }
        function getScope() {
            return $scope;
        }

    }

    angular.module('umbraco.directives').component('umbVariantContentEditors', umbVariantContentEditors);

})();

----
html/umbpane.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbPane
* @restrict E
**/
angular.module("umbraco.directives.html")
    .directive('umbPane', function () {
        return {
            transclude: true,
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/html/umb-pane.html'
        };
    });

----
html/readme.md
The html directives does nothing but display html, with simple one-way binding
and is therefore simpler to use then alot of the strict property bound ones
----
html/umbpanel.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbPanel
* @restrict E
**/
angular.module("umbraco.directives.html")
	.directive('umbPanel', function($timeout, $log){
		return {
			restrict: 'E',
			replace: true,
			transclude: 'true',
			templateUrl: 'views/components/html/umb-panel.html'
		};
	});

----
html/umbcontrolgroup.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbControlGroup
* @restrict E

@param {string=} label The label for the control group field.
@param {string=} description The description for the control group field.
@param {boolean=} hideLabel Set to <code>true</code> to hide the label.
@param {string=} alias The alias of the field within the control group.
@param {string=} labelFor The alias of the field that the label is for, used for validation.
@param {boolean=} required Set to <code>true</code> to mark the field as required.

**/

angular.module("umbraco.directives.html")
  .directive('umbControlGroup', function (localizationService) {
    return {
      scope: {
        label: "@label",
        description: "@",
        hideLabel: "@",
        alias: "@",
        labelFor: "@",
        required: "@?"
      },
      require: '?^^form',
      transclude: true,
      restrict: 'E',
      replace: true,
      templateUrl: 'views/components/html/umb-control-group.html',
      link: function (scope, element, attr, formCtrl) {

        scope.formValid = function () {
          if (formCtrl && scope.labelFor) {
            //if a label-for has been set, use that for the validation
            return formCtrl[scope.labelFor].$valid;
          }
          //there is no form.
          return true;
        };

        if (scope.label && scope.label[0] === "@") {
          localizationService.localize(scope.label.substring(1))
            .then(function(data){
              scope.labelstring = data;
            });
        }
        else {
          scope.labelstring = scope.label;
        }

        if (scope.description && scope.description[0] === "@") {
          localizationService.localize(scope.description.substring(1))
            .then(function(data){
              scope.descriptionstring = data;
            });
        }
        else {
          scope.descriptionstring = scope.description;
        }

      }
    };
  });

----
html/umbbox/umbboxheader.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbBoxHeader
@restrict E
@scope

@description
Use this directive to construct a title. Recommended to use it inside an {@link umbraco.directives.directive:umbBox umbBox} directive. See documentation for {@link umbraco.directives.directive:umbBox umbBox}.

<h3>Markup example</h3>
<pre>
    <umb-box>
        <umb-box-header title="This is a title" description="I can enter a description right here"></umb-box-header>
        <umb-box-content>
            // Content here
        </umb-box-content>
    </umb-box>
</pre>

<h3>Markup example with using titleKey</h3>
<pre>
    <umb-box>
        // the title-key property needs an areaAlias_keyAlias from the language files
        <umb-box-header title-key="areaAlias_keyAlias" description-key="areaAlias_keyAlias"></umb-box-header>
        <umb-box-content>
            // Content here
        </umb-box-content>
    </umb-box>
</pre>
{@link https://our.umbraco.com/documentation/extending/language-files/ Here you can see more about the language files}

<h3>Use in combination with:</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbBox umbBox}</li>
    <li>{@link umbraco.directives.directive:umbBoxContent umbBoxContent}</li>
</ul>

@param {string=} title (<code>attrbute</code>): Custom title text.
@param {string=} titleKey (<code>attrbute</code>): The translation key from the language xml files.
@param {string=} description (<code>attrbute</code>): Custom description text.
@param {string=} descriptionKey (<code>attrbute</code>): The translation key from the language xml files.
**/


(function(){
    'use strict';

    function BoxHeaderDirective(localizationService) {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/html/umb-box/umb-box-header.html',
            scope: {
                titleKey: "@?",
                title: "@?",
                descriptionKey: "@?",
                description: "@?"
            },
            link: function (scope) {

                scope.titleLabel = scope.title;

                if (scope.titleKey) {
                    localizationService.localize(scope.titleKey, [], scope.title).then((data) => {
                        scope.titleLabel = data;
                    });

                }

                scope.descriptionLabel = scope.description;

                if (scope.descriptionKey) {
                    localizationService.localize(scope.descriptionKey, [], scope.description).then((data) => {
                        scope.descriptionLabel = data;
                    });

                }
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbBoxHeader', BoxHeaderDirective);

})();

----
html/umbbox/umbbox.directive.js
/** 
@ngdoc directive
@name umbraco.directives.directive:umbBox
@restrict E

@description
Use this directive to render an already styled empty div tag.

<h3>Markup example</h3>
<pre>
    <umb-box>
        <umb-box-header title="this is a title"></umb-box-header>
        <umb-box-content>
            // Content here
        </umb-box-content>
    </umb-box>
</pre>

<h3>Use in combination with:</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbBoxHeader umbBoxHeader}</li>
    <li>{@link umbraco.directives.directive:umbBoxContent umbBoxContent}</li>
</ul>
**/

(function(){
    'use strict';

    function BoxDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/html/umb-box/umb-box.html'
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbBox', BoxDirective);

})();
----
html/umbbox/umbboxcontent.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbBoxContent
@restrict E

@description
Use this directive to render an empty container. Recommended to use it inside an {@link umbraco.directives.directive:umbBox umbBox} directive. See documentation for {@link umbraco.directives.directive:umbBox umbBox}.

<h3>Markup example</h3>
<pre>
    <umb-box>
        <umb-box-header title="this is a title"></umb-box-header>
        <umb-box-content>
            // Content here
        </umb-box-content>
    </umb-box>
</pre>

<h3>Use in combination with:</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbBox umbBox}</li>
    <li>{@link umbraco.directives.directive:umbBoxHeader umbBoxHeader}</li>
</ul>
**/

(function(){
    'use strict';

    function BoxContentDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/html/umb-box/umb-box-content.html'
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbBoxContent', BoxContentDirective);

})();
----
tags/umbtagseditor.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTagsEditor
**/

(function () {
    'use strict';

    angular
        .module('umbraco.directives')
        .component('umbTagsEditor', {
            transclude: true,
            templateUrl: 'views/components/tags/umb-tags-editor.html',
            controller: umbTagsEditorController,
            controllerAs: 'vm',
            bindings: {
                value: "<",
                config: "<",
                validation: "<",
                culture: "<?",
                inputId: "@?",
                onValueChanged: "&"
            }
        });

    function umbTagsEditorController($rootScope, assetsService, umbRequestHelper, angularHelper, $timeout, $element, $attrs) {

        let vm = this;

        let typeahead;
        let tagsHound;

        let initLoad = true;

        vm.$onInit = onInit;
        vm.$onChanges = onChanges;
        vm.$onDestroy = onDestroy;

        vm.validateMandatory = validateMandatory;
        vm.addTagOnEnter = addTagOnEnter;
        vm.addTag = addTag;
        vm.removeTag = removeTag;
        vm.showPrompt = showPrompt;
        vm.hidePrompt = hidePrompt;
        vm.onKeyUpOnTag = onKeyUpOnTag;

        vm.isLoading = true;
        vm.tagToAdd = "";
        vm.promptIsVisible = "-1";
        vm.viewModel = [];
        vm.readonly = false;

        $attrs.$observe('readonly', (value) => {
            vm.readonly = value !== undefined;
        });

        function onInit() {
            vm.inputId = vm.inputId || "t" + String.CreateGuid();

            assetsService.loadJs("lib/typeahead.js/typeahead.bundle.min.js").then(function () {

                vm.isLoading = false;

                //ensure that the models are formatted correctly
                configureViewModel(true);

                // Set the visible prompt to -1 to ensure it will not be visible
                vm.promptIsVisible = "-1";

                tagsHound = new Bloodhound({
                    initialize: false,
                    identify: function (obj) { return obj.id; },
                    datumTokenizer: Bloodhound.tokenizers.obj.whitespace('text'),
                    queryTokenizer: Bloodhound.tokenizers.whitespace,
                    //pre-fetch the tags for this category
                    prefetch: {
                        url: umbRequestHelper.getApiUrl("tagsDataBaseUrl", "GetTags", { tagGroup: vm.config.group, culture: vm.culture }),
                        //TTL = 5 minutes
                        ttl: 300000
                    },
                    //dynamically get the tags for this category (they may have changed on the server)
                    remote: {
                        url: umbRequestHelper.getApiUrl("tagsDataBaseUrl", "GetTags", { tagGroup: vm.config.group, culture: vm.culture, query: "%QUERY" }),
                        wildcard: "%QUERY"
                    }
                });

                tagsHound.initialize().then(function() {

                    //configure the type ahead
                    
                    var sources = {
                        //see: https://github.com/twitter/typeahead.js/blob/master/doc/jquery_typeahead.md#options
                        // name = the data set name, we'll make this the tag group name + culture
                        name: (vm.config.group + (vm.culture ? vm.culture : "")).replace(/\W/g, '-'),
                        display: "text",
                        //source: tagsHound
                        source: function (query, syncCallback, asyncCallback) {
                            tagsHound.search(query,
                                function(suggestions) {
                                    syncCallback(removeCurrentTagsFromSuggestions(suggestions));
                                }, function(suggestions) {
                                    asyncCallback(removeCurrentTagsFromSuggestions(suggestions));
                                });
                        }
                    };

                    var opts = {
                        hint: true,
                        highlight: true,
                        cacheKey: new Date(),  // Force a cache refresh each time the control is initialized
                        minLength: 1
                    };

                    typeahead = $element.find('.tags-' + vm.inputId).typeahead(opts, sources)
                        .bind("typeahead:selected", function (obj, datum, name) {
                            angularHelper.safeApply($rootScope, function () {
                                addTagInternal(datum["text"]);
                                vm.tagToAdd = "";
                                // clear the typed text
                                typeahead.typeahead('val', '');
                            });
                        }).bind("typeahead:autocompleted", function (obj, datum, name) {
                            angularHelper.safeApply($rootScope, function () {
                                addTagInternal(datum["text"]);
                                vm.tagToAdd = "";
                                // clear the typed text
                                typeahead.typeahead('val', '');
                            });

                        }).bind("typeahead:opened", function (obj) {

                        });

                });
                
            });
        }

        /**
         * Watch for value changes
         * @param {any} changes
         */
        function onChanges(changes) {

            //when the model 'value' changes, sync the viewModel object
            if (changes.value) {
                if (!changes.value.isFirstChange() && changes.value.currentValue !== changes.value.previousValue) {

                    configureViewModel();
                    reValidate();
                }
            }
        }

        function onDestroy() {
            if (tagsHound) {
                tagsHound.clearPrefetchCache();
                tagsHound.clearRemoteCache();
                tagsHound = null;
            }
            $element.find('.tags-' + vm.inputId).typeahead('destroy');
        }

        function configureViewModel(isInitLoad) {
            if (vm.value) {
                if (Utilities.isString(vm.value) && vm.value.length > 0) {
                    if (vm.config.storageType === "Json") {
                        //json storage
                        vm.viewModel = JSON.parse(vm.value);

                        //if this is the first load, we are just re-formatting the underlying model to be consistent
                        //we don't want to notify the component parent of any changes, that will occur if the user actually
                        //changes a value. If we notify at this point it will signal a form dirty change which we don't want.
                        if (!isInitLoad) {
                            updateModelValue(vm.viewModel);
                        }
                    }
                    else {
                        //csv storage

                        // split the csv string, and remove any duplicate values
                        let tempArray = vm.value.split(',').map(function (v) {
                            return v.trim();
                        });

                        vm.viewModel = tempArray.filter(function (v, i, self) {
                            return self.indexOf(v) === i;
                        });

                        //if this is the first load, we are just re-formatting the underlying model to be consistent
                        //we don't want to notify the component parent of any changes, that will occur if the user actually
                        //changes a value. If we notify at this point it will signal a form dirty change which we don't want.
                        if (!isInitLoad) {
                            updateModelValue(vm.viewModel);
                        }
                    }
                }
                else if (Utilities.isArray(vm.value)) {
                    vm.viewModel = vm.value;
                }
            }
        }

        function updateModelValue(val) {

            val = val ? val : [];

            vm.onValueChanged({ value: val });

            reValidate();
        }

        /**
         * Method required by the valPropertyValidator directive (returns true if the property editor has at least one tag selected)
         */
        function validateMandatory() {
            return {
                isValid: !vm.validation.mandatory || (vm.viewModel != null && vm.viewModel.length > 0)|| (vm.value != null && vm.value.length > 0),
                errorMsg: "Value cannot be empty",
                errorKey: "required"
            };
        }

        function addTagInternal(tagToAdd) {
            if (tagToAdd != null && tagToAdd.length > 0) {
                if (vm.viewModel.indexOf(tagToAdd) < 0) {
                    vm.viewModel.push(tagToAdd);
                    updateModelValue(vm.viewModel);
                }
            }
        }

        function addTagOnEnter(e) {
            var code = e.keyCode || e.which;
            if (code == 13) { //Enter keycode
                if ($element.find('.tags-' + vm.inputId).parent().find(".tt-menu .tt-cursor").length === 0) {
                    //this is required, otherwise the html form will attempt to submit.
                    e.preventDefault();
                    addTag();
                }
            }
        }
        function addTag() {
            //ensure that we're not pressing the enter key whilst selecting a typeahead value from the drop down
            //we need to use jquery because typeahead duplicates the text box
            addTagInternal(vm.tagToAdd);
            vm.tagToAdd = "";
            //this clears the value stored in typeahead so it doesn't try to add the text again
            // https://issues.umbraco.org/issue/U4-4947
            typeahead.typeahead('val', '');
        }

        function removeTag(tag) {
            var i = vm.viewModel.indexOf(tag);

            if (i >= 0) {
                // Make sure to hide the prompt so it does not stay open because another item gets a new number in the array index
                vm.promptIsVisible = "-1";

                // Remove the tag from the index
                vm.viewModel.splice(i, 1);

                updateModelValue(vm.viewModel);
            }
        }

        function showPrompt(idx, tag) {

            var i = vm.viewModel.indexOf(tag);

            // Make the prompt visible for the clicked tag only
            if (i === idx) {
                vm.promptIsVisible = i;
            }
        }

        function hidePrompt() {
            vm.promptIsVisible = "-1";
        }
        
        function onKeyUpOnTag(tag, $event) {
            if ($event.keyCode === 8 || $event.keyCode === 46) {
                removeTag(tag);
            }
        }
        
        // helper method to remove current tags
        function removeCurrentTagsFromSuggestions(suggestions) {
            return $.grep(suggestions, function (suggestion) {
                return ($.inArray(suggestion.text, vm.viewModel) === -1);
            });
        }

        function reValidate() {
            //this is required to re-validate for the mandatory validation
            if (vm.tagEditorForm && vm.tagEditorForm.tagCount) {
                vm.tagEditorForm.tagCount.$setViewValue(vm.viewModel.length);
            }
        }

    }

})();

----
contenttype/umbcontenttypegroups.component.js
(function () {
  'use strict';

  /**
   * A component to render the content type groups
   */
  
  function umbContentTypeGroupsController() {

      const vm = this;

  }

  const umbContentTypeGroupsComponent = {
      templateUrl: 'views/components/contenttype/umb-content-type-groups.html',
      controllerAs: 'vm',
      transclude: true,
      controller: umbContentTypeGroupsController
  };

  angular.module('umbraco.directives').component('umbContentTypeGroups', umbContentTypeGroupsComponent);

})();

----
contenttype/umbcontenttypegroup.component.js
(function () {
  'use strict';

  /**
   * A component to render the content type group
   */

  function umbContentTypeGroupController() {

    const vm = this;

    vm.updateName = updateName;
    vm.removeGroup = removeGroup;
    vm.whenNameFocus = whenNameFocus;
    vm.whenFocus = whenFocus;
    vm.changeSortOrderValue = changeSortOrderValue;
    vm.clickComposition = clickComposition;

    function updateName (group) {
      if (vm.onUpdateName) {
        vm.onUpdateName({ group });
      }
    }

    function removeGroup () {
      if (vm.onRemove) {
        vm.onRemove({ group: vm.group });
      }
    }

    function whenNameFocus () {
      if (vm.onNameFocus) {
        vm.onNameFocus();
      }
    }

    function whenFocus () {
      if (vm.onFocus) {
        vm.onFocus();
      }
    }

    function changeSortOrderValue () {
      if (vm.onChangeSortOrderValue) {
        vm.onChangeSortOrderValue( {group: vm.group});
      }
    }
    function clickComposition (contentTypeId) {
      if (vm.onClickComposition) {
        vm.onClickComposition({contentTypeId: contentTypeId});
      }
    }
  }

  const umbContentTypeGroupComponent = {
    templateUrl: 'views/components/contenttype/umb-content-type-group.html',
    controllerAs: 'vm',
    transclude: true,
    bindings: {
      group: '<',
      allowName: '<',
      onUpdateName: '&',
      allowRemove: '<',
      onRemove: '&',
      sorting: '<',
      onNameFocus: '&',
      onFocus: '&',
      onChangeSortOrderValue: '&',
      valServerFieldName: '@',
      valTabAlias: "@",
      onClickComposition: '&?'
    },
    controller: umbContentTypeGroupController
  };

  angular.module('umbraco.directives').component('umbContentTypeGroup', umbContentTypeGroupComponent);
})();

----
contenttype/umbcontenttypeproperty.component.js
(function () {
  'use strict';

  /**
   * A component to render the content type property
   */
  
  function umbContentTypePropertyController() {

    const vm = this;

    vm.edit = edit;
    vm.remove = remove;
    vm.changeSortOrderValue = changeSortOrderValue;
    vm.clickComposition = clickComposition;

    function edit () {
      if (vm.onEdit) {
        vm.onEdit();
      }
    }

    function remove () {
      if (vm.onRemove) {
        vm.onRemove({ property: vm.property });
      }
    }

    function changeSortOrderValue () {
      if (vm.onChangeSortOrderValue) {
        vm.onChangeSortOrderValue( {property: vm.property});
      }
    }

    function clickComposition(contentTypeId) {
      if (vm.onClickComposition) {
        vm.onClickComposition({ contentTypeId: contentTypeId });
      }
    }

  }

  const umbContentTypePropertyComponent = {
    templateUrl: 'views/components/contenttype/umb-content-type-property.html',
    bindings: {
      property: '<',
      sortable: '<',
      onEdit: '&',
      onRemove: '&',
      onChangeSortOrderValue: '&',
      onClickComposition: '&?',
      valServerFieldAlias: '@',
      valServerFieldLabel: '@',
      valTabAlias: '@'
    },
    controllerAs: 'vm',
    controller: umbContentTypePropertyController
  };

  angular.module('umbraco.directives').component('umbContentTypeProperty', umbContentTypePropertyComponent);

})();

----
contenttype/umbcontenttypetab.component.js
(function () {
  'use strict';

  /**
   * A component to render the content type tab
   */

  function umbContentTypeTabController($timeout) {

    const vm = this;

    vm.compositionLabelIsVisible = false;

    vm.click = click;
    vm.removeTab = removeTab;
    vm.whenFocusName = whenFocusName;
    vm.whenFocus = whenFocus;
    vm.changeSortOrderValue = changeSortOrderValue;
    vm.changeName = changeName;
    vm.clickComposition = clickComposition;
    vm.mouseenter = mouseenter;
    vm.mouseleave = mouseleave;
    
    let timeout = null;

    function click () {
      if (vm.onClick) {
        vm.onClick({ tab: vm.tab });
      }
    }

    function removeTab () {
      if (vm.onRemove) {
        vm.onRemove({ tab: vm.tab });
      }
    }

    function whenFocusName () {
      if (vm.onFocusName) {
        vm.onFocusName();
      }
    }

    function whenFocus () {
      if (vm.onFocus) {
        vm.onFocus();
      }
    }

    function changeSortOrderValue () {
      if (vm.onChangeSortOrderValue) {
        vm.onChangeSortOrderValue( {tab: vm.tab});
      }
    }

    function changeName () {
      if (vm.onChangeName) {
        vm.onChangeName({ key: vm.tab.key, name: vm.tab.name });
      }
    }

    function clickComposition(contentTypeId) {
      if (vm.onClickComposition) {
        vm.onClickComposition({ contentTypeId: contentTypeId});
      }
    }

    function mouseenter () {
      if (vm.tab.inherited) {
        vm.compositionLabelIsVisible = true;
        $timeout.cancel(timeout);
      }
    }

    function mouseleave () {
      if (vm.tab.inherited) {
        timeout = $timeout(() => {
          vm.compositionLabelIsVisible = false;
        }, 300);
      }
    }

  }

  const umbContentTypeTabComponent = {
    templateUrl: 'views/components/contenttype/umb-content-type-tab.html',
    controllerAs: 'vm',
    transclude: true,
    bindings: {
      tab: '<',
      onClick: '&?',
      onClickComposition: '&?',
      isOpen: '<?',
      allowRemove: '<?',
      onRemove: '&?',
      sorting: '<?',
      onFocusName: '&?',
      onFocus: '&?',
      onChangeSortOrderValue: '&?',
      allowChangeName: '<?',
      onChangeName: '&?',
      valServerFieldName: '@'
    },
    controller: umbContentTypeTabController
  };

  angular.module('umbraco.directives').component('umbContentTypeTab', umbContentTypeTabComponent);
})();

----
users/umbusergrouppreview.directive.js
/** 
@ngdoc directive
@name umbraco.directives.directive:umbUserGroupPreview
@restrict E
@scope

@description
Use this directive to render a user group preview, where you can see the permissions the user or group has in the back office.

<h3>Markup example</h3>
<pre>
    <div>
        <umb-user-group-preview
            ng-repeat="userGroup in vm.user.userGroups"
            icon="userGroup.icon"
            name="userGroup.name"
            sections="userGroup.sections"
            content-start-node="userGroup.contentStartNode"
            media-start-node="userGroup.mediaStartNode"
            allow-remove="!vm.user.isCurrentUser"
            on-remove="vm.removeSelectedItem($index, vm.user.userGroups)">
        </umb-user-group-preview>
    </div>
</pre>

@param {string} icon (<code>binding</code>): The user group icon.
@param {string} name (<code>binding</code>): The user group name.
@param {array} sections (<code>binding</code>) Lists out the sections where the user has authority to edit.
@param {string} contentStartNode (<code>binding</code>)
<ul>
    <li>The starting point in the tree of the content section.</li>
    <li>So the user has no authority to work on other branches, only on this branch in the content section.</li>
</ul>
@param {boolean} hideContentStartNode (<code>binding</code>) Hides the contentStartNode.
@param {string} mediaStartNode (<code>binding</code>)
<ul>
<li> The starting point in the tree of the media section.</li>
<li> So the user has no authority to work on other branches, only on this branch in the media section.</li>
</ul>
@param {boolean} hideMediaStartNode (<code>binding</code>) Hides the mediaStartNode.
@param {array} permissions (<code>binding<code>) A list of permissions, the user can have.
@param {boolean} allowRemove (<code>binding</code>): Shows or Hides the remove button.
@param {function} onRemove (<code>expression</code>): Callback function when the remove button is clicked.
@param {boolean} allowEdit (<code>binding</code>): Shows or Hides the edit button.
@param {function} onEdit (<code>expression</code>): Callback function when the edit button is clicked.
**/


(function () {
    'use strict';

    function UserGroupPreviewDirective() {

        function link(scope, el, attr, ctrl) {

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/users/umb-user-group-preview.html',
            scope: {
                icon: "=?",
                name: "=",
                sections: "=?",
                contentStartNode: "=?", 
                hideContentStartNode: "@?",
                mediaStartNode: "=?",
                hideMediaStartNode: "@?",
                permissions: "=?",
                allowRemove: "=?",
                allowEdit: "=?",
                onRemove: "&?",
                onEdit: "&?"
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbUserGroupPreview', UserGroupPreviewDirective);

})();
----
users/umbuserpreview.directive.js
(function () {
    'use strict';

    function UserPreviewDirective() {

        function link(scope, el, attr, ctrl) {

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/users/umb-user-preview.html',
            scope: {
                avatars: "=?",
                name: "=",
                allowRemove: "=?",
                onRemove: "&?"
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbUserPreview', UserPreviewDirective);

})();
----
users/changepassword.directive.js
(function () {
    'use strict';

    function ChangePasswordController($scope) {

        var vm = this;

        vm.$onInit = onInit;
        vm.$onDestroy = onDestroy;
        vm.doChange = doChange;
        vm.cancelChange = cancelChange;
        vm.showOldPass = showOldPass;
        vm.showCancelBtn = showCancelBtn;
        vm.newPasswordKeyUp = newPasswordKeyUp;

        var unsubscribe = [];

        function resetModel(isNew) {
            //the model config will contain an object, if it does not we'll create defaults
            /*
            {
                hasPassword: true/false,
                minPasswordLength: 10
            }
            */

            //set defaults if they are not available
            if (vm.config.disableToggle === undefined) {
                vm.config.disableToggle = false;
            }
            if (vm.config.hasPassword === undefined) {
                vm.config.hasPassword = false;
            }
            if (vm.config.minPasswordLength === undefined) {
                vm.config.minPasswordLength = 0;
            }

            // Check non-alpha pwd settings for tooltip display
            if (vm.config.minNonAlphaNumericChars === undefined) {
                vm.config.minNonAlphaNumericChars = 0;
            }

            //set the model defaults
            if (!Utilities.isObject(vm.passwordValues)) {
                //if it's not an object then just create a new one
                vm.passwordValues = {
                    newPassword: null,
                    oldPassword: null
                };
            }
            else {
                //just reset the values

                if (!isNew) {
                    //if it is new, then leave the generated pass displayed
                    vm.passwordValues.newPassword = null;
                    vm.passwordValues.oldPassword = null;
                }
            }

            // set initial value for new password value
            vm.passwordVal = vm.passwordValues.newPassword;

            //the value to compare to match passwords
            if (!isNew) {
                vm.passwordValues.confirm = "";
            }
            else if (vm.passwordValues.newPassword && vm.passwordValues.newPassword.length > 0) {
                //if it is new and a new password has been set, then set the confirm password too
                vm.passwordValues.confirm = vm.passwordValues.newPassword;
            }

        }

        //when the scope is destroyed we need to unsubscribe
        function onDestroy() {
            for (var u in unsubscribe) {
                unsubscribe[u]();
            }
        }

        function onInit() {
            //listen for the saved event, when that occurs we'll
            //change to changing = false;
            unsubscribe.push($scope.$on("formSubmitted", function () {
                if (vm.config.disableToggle === false) {
                    vm.changing = false;
                }
            }));

            unsubscribe.push($scope.$on("formSubmitting", function () {
                if (!vm.changing) {
                    //we are not changing, so the model needs to be null
                    vm.passwordValues = null;
                }
            }));

            resetModel(vm.isNew);

            //if there is no password saved for this entity , it must be new so we do not allow toggling of the change password, it is always there
            //with validators turned on.
            vm.changing = vm.config.disableToggle === true || !vm.config.hasPassword;

            //we're not currently changing so set the model to null
            if (!vm.changing) {
                vm.passwordValues = null;
            }
        }

        function doChange() {
            resetModel();
            vm.changing = true;
            vm.passwordValues.confirm = null;
        };

        function cancelChange() {
            vm.changing = false;
            //set model to null
            vm.passwordValues = null;
        };

        function showOldPass() {
            return vm.config.hasPassword &&
                !vm.config.allowManuallyChangingPassword;
        };

        // TODO: I don't think we need this or the cancel button, this can be up to the editor rendering this component
        function showCancelBtn() {
            return vm.config.disableToggle !== true && vm.config.hasPassword;
        };

        function newPasswordKeyUp(event) {
            vm.passwordVal = event.target.value;
        }
    }

    var component = {
        templateUrl: 'views/components/users/change-password.html',
        controller: ChangePasswordController,
        controllerAs: 'vm',
        bindings: {
            isNew: "<",
            passwordValues: "=", //TODO: Do we need bi-directional vals?
            config: "=" //TODO: Do we need bi-directional vals?
            //TODO: Do we need callbacks?
        }
    };

    angular.module('umbraco.directives').component('changePassword', component);


})();

----
application/umbpasswordtip.directive.js
(function () {
    'use strict';

    angular
        .module('umbraco.directives')
        .component('umbPasswordTip', {
            controller: UmbPasswordTipController,
            controllerAs: 'vm',
            template:
                '<span class="help-inline" style="display: block;" ng-if="vm.passwordTip" ng-bind-html="vm.passwordTip"></span>',
            bindings: {
                passwordVal: "<",
                minPwdLength: "<",
                minPwdNonAlphaNum: "<"
            }
        });

    function UmbPasswordTipController(localizationService) {

        let defaultMinPwdLength = Umbraco.Sys.ServerVariables.umbracoSettings.minimumPasswordLength;
        let defaultMinPwdNonAlphaNum = Umbraco.Sys.ServerVariables.umbracoSettings.minimumPasswordNonAlphaNum;

        var vm = this;

        vm.passwordNonAlphaTip = '';
        vm.passwordTip = '';
        vm.passwordLength = 0;

        vm.$onInit = onInit;
        vm.$onChanges = onChanges;

        function onInit() {
            if (vm.minPwdLength === undefined) {
                vm.minPwdLength = defaultMinPwdLength;
            }

            if (vm.minPwdNonAlphaNum === undefined) {
                vm.minPwdNonAlphaNum = defaultMinPwdNonAlphaNum;
            }

            if (vm.minPwdNonAlphaNum > 0) {
                localizationService.localize('user_newPasswordFormatNonAlphaTip', [vm.minPwdNonAlphaNum]).then(data => {
                    vm.passwordNonAlphaTip = data;
                    updatePasswordTip(vm.passwordLength);
                });
            } else {
                vm.passwordNonAlphaTip = '';
                updatePasswordTip(vm.passwordLength);
            }
        }

        function onChanges(simpleChanges) {

            if (simpleChanges.passwordVal) {
                vm.passwordLength = simpleChanges.passwordVal.currentValue ? simpleChanges.passwordVal.currentValue.length : 0;

                updatePasswordTip(vm.passwordLength);
            }
        }

        const updatePasswordTip = passwordLength => {

            const remainingLength = vm.minPwdLength - passwordLength;
            
            if (remainingLength > 0) {
                localizationService.localize('user_newPasswordFormatLengthTip', [remainingLength]).then(data => {
                    vm.passwordTip = data;
                    if (vm.passwordNonAlphaTip) {
                        vm.passwordTip += `<br/>${vm.passwordNonAlphaTip}`;
                    }
                });
            } else {
                vm.passwordTip = vm.passwordNonAlphaTip;
            }
        }
    }
})();

----
application/umbcontextmenu.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbContextMenu
* @restrict A
 *
 * @description
 * Handles the click events on the context menu
**/
angular.module("umbraco.directives")
.directive('umbContextMenu', function (navigationService, keyboardService) {
    return {
        scope: {
            menuDialogTitle: "@",
            currentSection: "@",
            currentNode: "=",
            menuActions: "="
        },
        restrict: 'E',
        replace: true,
        templateUrl: 'views/components/application/umb-contextmenu.html',
        link: function (scope, element, attrs, ctrl) {

            // Map action icons using legacy icon font or svg icons.
            Utilities.forEach(scope.menuActions, action => {
              action.icon = (action.useLegacyIcon ? 'icon-' : '') + action.icon;
            });
            
            //adds a handler to the context menu item click, we need to handle this differently
            //depending on what the menu item is supposed to do.
            scope.executeMenuItem = action => {
                navigationService.executeMenuAction(action, scope.currentNode, scope.currentSection);
            };
            
            scope.outSideClick = () => {
                navigationService.hideNavigation();
            };
            
            keyboardService.bind("esc", () =>  {
                navigationService.hideNavigation();
            });
            
            //ensure to unregister from all events!
            scope.$on('$destroy', () =>  {
                keyboardService.unbind("esc");
            });
        }
    };
});

----
application/umbsearch.directive.js
(function () {
    'use strict';

    /**
     * A component to render the pop up search field
     */
    var umbSearch = {
        templateUrl: 'views/components/application/umb-search.html',
        controllerAs: 'vm',
        controller: umbSearchController,
        bindings: {
            onClose: "&"
        }
    };

    function umbSearchController($timeout, backdropService, searchService, focusService) {

        var vm = this;

        vm.$onInit = onInit;
        vm.$onDestroy = onDestroy;
        vm.search = search;
        vm.clickItem = clickItem;
        vm.clearSearch = clearSearch;
        vm.handleKeyDown = handleKeyDown;
        vm.closeSearch = closeSearch;
        vm.focusSearch = focusSearch;

        //we need to capture the focus before this element is initialized.
        vm.focusBeforeOpening = focusService.getLastKnownFocus();

        vm.activeResult = null;
        vm.activeResultGroup = null;

        function onInit() {
            vm.searchQuery = "";
            vm.searchResults = [];
            vm.hasResults = false;
            focusSearch();
            backdropService.open();
        }

        function onDestroy() {
            backdropService.close();
        }

        /**
         * Handles when a search result is clicked
         */
        function clickItem() {
            closeSearch();
        }

        /**
         * Clears the search query
         */
        function clearSearch() {
            vm.searchQuery = "";
            vm.searchResults = [];
            vm.hasResults = false;
            focusSearch();
        }

        /**
         * Add focus to the search field
         */
        function focusSearch() {
            vm.searchHasFocus = false;
            $timeout(function () {
                vm.searchHasFocus = true;
            });
        }

        /**
         * Handles all keyboard events
         * @param {object} event
         */
        function handleKeyDown(event) {

            // esc
            if (event.keyCode === 27) {
                event.stopPropagation();
                event.preventDefault();

                closeSearch();
                return;
            }

            // up/down (navigate search results)
            if (vm.hasResults && (event.keyCode === 38 || event.keyCode === 40)) {
                event.stopPropagation();
                event.preventDefault();

                var allGroups = _.values(vm.searchResults);
                var down = event.keyCode === 40;
                if (vm.activeResultGroup === null) {
                    // it's the first time navigating, pick the appropriate group and result 
                    // - first group and first result when navigating down
                    // - last group and last result when navigating up
                    vm.activeResultGroup = down ? _.first(allGroups) : _.last(allGroups);
                    vm.activeResult = down ? _.first(vm.activeResultGroup.results) : _.last(vm.activeResultGroup.results);
                }
                else if (down) {
                    // handle navigation down through the groups and results
                    if (vm.activeResult === _.last(vm.activeResultGroup.results)) {
                        if (vm.activeResultGroup === _.last(allGroups)) {
                            vm.activeResultGroup = _.first(allGroups);
                        }
                        else {
                            vm.activeResultGroup = allGroups[allGroups.indexOf(vm.activeResultGroup) + 1];
                        }
                        vm.activeResult = _.first(vm.activeResultGroup.results);
                    }
                    else {
                        vm.activeResult = vm.activeResultGroup.results[vm.activeResultGroup.results.indexOf(vm.activeResult) + 1];
                    }
                }
                else {
                    // handle navigation up through the groups and results
                    if (vm.activeResult === _.first(vm.activeResultGroup.results)) {
                        if (vm.activeResultGroup === _.first(allGroups)) {
                            vm.activeResultGroup = _.last(allGroups);
                        }
                        else {
                            vm.activeResultGroup = allGroups[allGroups.indexOf(vm.activeResultGroup) - 1];
                        }
                        vm.activeResult = _.last(vm.activeResultGroup.results);
                    }
                    else {
                        vm.activeResult = vm.activeResultGroup.results[vm.activeResultGroup.results.indexOf(vm.activeResult) - 1];
                    }
                }

                $timeout(function () {
                    var resultElementLink = $(".umb-search-item[active-result='true'] .umb-search-result__link");
                    resultElementLink[0].focus();
                });
            }
        }

        /**
         * Used to proxy a callback
         */
        function closeSearch() {
            if (vm.focusBeforeOpening) {
                vm.focusBeforeOpening.focus();
            }
            if (vm.onClose) {
                vm.onClose();
            }
        }

        /**
         * Used to search
         * @param {string} searchQuery
         */
        function search(searchQuery) {
            if (searchQuery.length > 0) {
                var search = { "term": searchQuery };
                searchService.searchAll(search).then(function (result) {
                    //result is a dictionary of group Title and it's results
                    var filtered = {};
                    Object.keys(result).forEach(key => {
                        let value = result[key];
                        if (value.results.length > 0) {
                            filtered[key] = value;
                        }
                    });
                    // bind to view model
                    vm.searchResults = filtered;
                    // check if search has results
                    vm.hasResults = Object.keys(vm.searchResults).length > 0;
                });

            } else {
                clearSearch();
            }
        }

    }

    angular.module('umbraco.directives').component('umbSearch', umbSearch);

})();

----
application/umbtour.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTour
@restrict E
@scope

@description
<b>Added in Umbraco 7.8</b>. The tour component is a global component and is already added to the umbraco markup.
In the Umbraco UI the tours live in the "Help drawer" which opens when you click the Help-icon in the bottom left corner of Umbraco.
You can easily add you own tours to the Help-drawer or show and start tours from
anywhere in the Umbraco backoffice. To see a real world example of a custom tour implementation, install <a href="https://our.umbraco.com/projects/starter-kits/the-starter-kit/">The Starter Kit</a> in Umbraco 7.8

<h1><b>Extending the help drawer with custom tours</b></h1>
The easiet way to add new tours to Umbraco is through the Help-drawer. All it requires is a my-tour.json file.
Place the file in <i>App_Plugins/{MyPackage}/backoffice/tours/{my-tour}.json</i> and it will automatically be
picked up by Umbraco and shown in the Help-drawer.

<h3><b>The tour object</b></h3>
The tour object consist of two parts - The overall tour configuration and a list of tour steps. We have split up the tour object for a better overview.
<pre>
// The tour config object
{
    "name": "My Custom Tour", // (required)
    "alias": "myCustomTour", // A unique tour alias (required)
    "group": "My Custom Group" // Used to group tours in the help drawer
    "groupOrder": 200 // Control the order of tour groups
    "allowDisable": // Adds a "Don't" show this tour again"-button to the intro step
    "culture" : // From v7.11+. Specifies the culture of the tour (eg. en-US), if set the tour will only be shown to users with this culture set on their profile. If omitted or left empty the tour will be visible to all users
    "requiredSections":["content", "media", "mySection"] // Sections that the tour will access while running, if the user does not have access to the required tour sections, the tour will not load.
    "steps": [] // tour steps - see next example
}
</pre>
<pre>
// A tour step object
{
    "title": "Title",
    "content": "<p>Step content</p>",
    "type": "intro" // makes the step an introduction step,
    "element": "[data-element='my-table-row']", // the highlighted element
    "event": "click" // forces the user to click the UI to go to next step
    "eventElement": "[data-element='my-table-row'] [data-element='my-tour-button']" // specify an element to click inside a highlighted element
    "elementPreventClick": false // prevents user interaction in the highlighted element
    "backdropOpacity": 0.4 // the backdrop opacity
    "view": "" // add a custom view
    "customProperties" : {} // add any custom properties needed for the custom view
    "skipStepIfVisible": ".dashboard div [data-element='my-tour-button']" // if we can find this DOM element on the page then we will skip this step
}
</pre>

<h1><b>Adding tours to other parts of the Umbraco backoffice</b></h1>
It is also possible to add a list of custom tours to other parts of the Umbraco backoffice,
as an example on a Dashboard in a Custom section. You can then use the {@link umbraco.services.tourService tourService} to start and stop tours but you don't have to register them as part of the tour service.

<h1><b>Using the tour service</b></h1>
<h3>Markup example - show custom tour</h3>
<pre>
    <div ng-controller="My.TourController as vm">

        <div>{{vm.tour.name}}</div>
        <button type="button" ng-click="vm.startTour()">Start tour</button>

        <!-- This button will be clicked in the tour -->
        <button data-element="my-tour-button" type="button">Click me</button>

    </div>
</pre>

<h3>Controller example - show custom tour</h3>
<pre>
    (function () {
        "use strict";

        function TourController(tourService) {

            var vm = this;

            vm.tour = {
                "name": "My Custom Tour",
                "alias": "myCustomTour",
                "steps": [
                    {
                        "title": "Welcome to My Custom Tour",
                        "content": "",
                        "type": "intro"
                    },
                    {
                        "element": "[data-element='my-tour-button']",
                        "title": "Click the button",
                        "content": "Click the button",
                        "event": "click",
                        "skipStepIfVisible": "[data-element='my-other-tour-button']"
                    }
                ]
            };

            vm.startTour = startTour;

            function startTour() {
                tourService.startTour(vm.tour);
            }

        }

        angular.module("umbraco").controller("My.TourController", TourController);

    })();
</pre>

<h1><b>Custom step views</b></h1>
In some cases you will need a custom view for one of your tour steps. 
This could be for validation or for running any other custom logic for that step. 
We have added a couple of helper components to make it easier to get the step scaffolding to look like a regular tour step. 
In the following example you see how to run some custom logic before a step goes to the next step.

<h3>Markup example - custom step view</h3>
<pre>
    <div ng-controller="My.TourStep as vm">

        <umb-tour-step on-close="model.endTour()">
                
            <umb-tour-step-header
                title="model.currentStep.title">
            </umb-tour-step-header>
            
            <umb-tour-step-content
                content="model.currentStep.content">

                <!-- Add any custom content here  -->

            </umb-tour-step-content>

            <umb-tour-step-footer class="flex justify-between items-center">

                <umb-tour-step-counter
                    current-step="model.currentStepIndex + 1"
                    total-steps="model.steps.length">
                </umb-tour-step-counter>

                <div>
                    <umb-button 
                        size="xs" 
                        button-style="action" 
                        type="button" 
                        action="vm.initNextStep()" 
                        label="Next">
                    </umb-button>
                </div>

            </umb-tour-step-footer>

        </umb-tour-step>

    </div>
</pre>

<h3>Controller example - custom step view</h3>
<pre>
    (function () {
        "use strict";

        function StepController() {

            var vm = this;
            
            vm.initNextStep = initNextStep;

            function initNextStep() {
                // run logic here before going to the next step
                $scope.model.nextStep();
            }

        }

        angular.module("umbraco").controller("My.TourStep", StepController);

    })();
</pre>


<h3>Related services</h3>
<ul>
    <li>{@link umbraco.services.tourService tourService}</li>
</ul>

@param {string} model (<code>binding</code>): Tour object

**/

(function () {
    'use strict';

    function TourDirective($timeout, $http, $q, tourService, backdropService) {

        function link(scope, el, attr, ctrl) {

            var popover;
            var pulseElement;
            var pulseTimer;

            scope.loadingStep = false;
            scope.elementNotFound = false;

            scope.model.nextStep = function () {
                nextStep();
            };

            scope.model.endTour = function () {
                unbindEvent();
                tourService.endTour(scope.model);
                backdropService.close();
            };

            scope.model.completeTour = function () {
                unbindEvent();
                tourService.completeTour(scope.model).then(function () {
                    backdropService.close();
                });
            };

            scope.model.disableTour = function () {
                unbindEvent();
                tourService.disableTour(scope.model).then(function () {
                    backdropService.close();
                });
            }

            function onInit() {
                popover = el.find(".umb-tour__popover");
                pulseElement = el.find(".umb-tour__pulse");
                popover.hide();
                scope.model.currentStepIndex = 0;
                backdropService.open({ disableEventsOnClick: true });
                startStep();
            }

            function setView() {
                if (scope.model.currentStep.view && scope.model.alias) {
                    //we do this to avoid a hidden dialog to start loading unconfigured views before the first activation
                    var configuredView = scope.model.currentStep.view;
                    if (scope.model.currentStep.view.indexOf(".html") === -1) {
                        var viewAlias = scope.model.currentStep.view.toLowerCase();
                        var tourAlias = scope.model.alias.toLowerCase();
                        configuredView = "views/common/tours/" + tourAlias + "/" + viewAlias + "/" + viewAlias + ".html";
                    }
                    if (configuredView !== scope.configuredView) {
                        scope.configuredView = configuredView;
                    }
                } else {
                    scope.configuredView = null;
                }
            }

            function nextStep() {

                popover.hide();
                pulseElement.hide();
                $timeout.cancel(pulseTimer);
                scope.model.currentStepIndex++;

                // make sure we don't go too far
                if (scope.model.currentStepIndex !== scope.model.steps.length) {

                    var upcomingStep = scope.model.steps[scope.model.currentStepIndex];

                    // If the currentStep JSON object has 'skipStepIfVisible'
                    // It's a DOM selector - if we find it then we ship over this step
                    if (upcomingStep.skipStepIfVisible) {
                        let tryFindDomEl = document.querySelector(upcomingStep.skipStepIfVisible);
                        if (tryFindDomEl) {
                            // check if element is visible:
                            if( tryFindDomEl.offsetWidth || tryFindDomEl.offsetHeight || tryFindDomEl.getClientRects().length ) {
                                // if it was visible then we skip the step.
                                nextStep();
                                return;
                            }
                        }
                    }

                    startStep();
                } else {
                    // tour completed - final step
                    scope.loadingStep = true;

                    waitForPendingRerequests().then(function () {
                        scope.loadingStep = false;
                        // clear current step
                        scope.model.currentStep = {};
                        // set popover position to center
                        setPopoverPosition(null);
                        // remove backdrop hightlight and custom opacity
                        backdropService.setHighlight(null);
                        backdropService.setOpacity(null);
                    });
                }
            }

            function startStep() {
                scope.loadingStep = true;
                backdropService.setOpacity(scope.model.steps[scope.model.currentStepIndex].backdropOpacity);
                backdropService.setHighlight(null);

                waitForPendingRerequests().then(function () {

                    scope.model.currentStep = scope.model.steps[scope.model.currentStepIndex];

                    setView();

                    // if highlight element is set - find it
                    findHighlightElement();

                    // if a custom event needs to be bound we do it now
                    if (scope.model.currentStep.event) {
                        bindEvent();
                    }

                    scope.loadingStep = false;

                });
            }

            function findHighlightElement() {

                scope.elementNotFound = false;

                $timeout(function () {
                    // clear element when step as marked as intro, so it always displays in the center
                    if (scope.model.currentStep && scope.model.currentStep.type === "intro") {
                        scope.model.currentStep.element = null;
                        scope.model.currentStep.eventElement = null;
                        scope.model.currentStep.event = null;
                    }

                    // if an element isn't set - show the popover in the center
                    if (scope.model.currentStep && !scope.model.currentStep.element) {
                        setPopoverPosition(null);
                        return;
                    }

                    var element = $(scope.model.currentStep.element);

                    // we couldn't find the element in the dom - abort and show error
                    if (element.length === 0) {
                        scope.elementNotFound = true;
                        setPopoverPosition(null);
                        return;
                    }

                    var scrollParent = element.scrollParent();
                    var el = element;
                    var offsetTop = 0;
                    if (scrollParent[0] === document) {
                        offsetTop = el[0].offsetTop;
                    } else {
                        while ($.contains(scrollParent[0], el[0])) {
                            offsetTop += el[0].offsetTop;
                            el = el.offsetParent();
                        }
                    }

                    var scrollToCenterOfContainer = offsetTop - (scrollParent[0].clientHeight / 2);
                    if (element[0].clientHeight < scrollParent[0].clientHeight) {
                        scrollToCenterOfContainer += (element[0].clientHeight / 2);
                    }

                    // Detect if scroll is needed
                    if (offsetTop > scrollParent[0].clientHeight - 200) {
                        scrollParent.animate({
                            scrollTop: scrollToCenterOfContainer
                        }, function () {
                            // Animation complete.
                            setPopoverPosition(element);
                            setPulsePosition();
                            backdropService.setHighlight(scope.model.currentStep.element, scope.model.currentStep.elementPreventClick);
                        });
                    } else {
                        setPopoverPosition(element);
                        setPulsePosition();
                        backdropService.setHighlight(scope.model.currentStep.element, scope.model.currentStep.elementPreventClick);
                    }

                });

            }

            function setPopoverPosition(element) {

                $timeout(function () {

                    var position = "center";
                    var margin = 20;
                    var css = {};

                    var popoverWidth = popover.outerWidth();
                    var popoverHeight = popover.outerHeight();
                    var popoverOffset = popover.offset();
                    var documentWidth = $(document).width();
                    var documentHeight = $(document).height();

                    if (element) {

                        var offset = element.offset();
                        var width = element.outerWidth();
                        var height = element.outerHeight();

                        // messure available space on each side of the target element
                        var space = {
                            "top": offset.top,
                            "right": documentWidth - (offset.left + width),
                            "bottom": documentHeight - (offset.top + height),
                            "left": offset.left
                        };

                        // get the posistion with most available space
                        position = findMax(space);

                        if (position === "top") {
                            if (offset.left < documentWidth / 2) {
                                css.top = offset.top - popoverHeight - margin;
                                css.left = offset.left;
                            } else {
                                css.top = offset.top - popoverHeight - margin;
                                css.left = offset.left - popoverWidth + width;
                            }
                        }

                        if (position === "right") {
                            if (offset.top + popoverHeight < documentHeight) {
                                css.top = offset.top;
                                css.left = offset.left + width + margin;
                            } else {
                                css.top = offset.top + height - popoverHeight;
                                css.left = offset.left + width + margin;
                            }
                        }

                        if (position === "bottom") {
                            if (offset.left < documentWidth / 2) {
                                css.top = offset.top + height + margin;
                                css.left = offset.left;
                            } else {
                                css.top = offset.top + height + margin;
                                css.left = offset.left - popoverWidth + width;
                            }
                        }

                        if (position === "left") {
                            if (offset.top + popoverHeight < documentHeight) {
                                css.top = offset.top;
                                css.left = offset.left - popoverWidth - margin;
                            } else {
                                css.top = offset.top + height - popoverHeight;
                                css.left = offset.left - popoverWidth - margin;
                            }
                        }

                    } else {
                        // if there is no dom element center the popover
                        css.top = "calc(50% - " + popoverHeight / 2 + "px)";
                        css.left = "calc(50% - " + popoverWidth / 2 + "px)";
                    }

                    popover.css(css).fadeIn("fast");

                });


            }

            function setPulsePosition() {
                if (scope.model.currentStep.event) {

                    pulseTimer = $timeout(function () {

                        var clickElementSelector = scope.model.currentStep.eventElement ? scope.model.currentStep.eventElement : scope.model.currentStep.element;
                        var clickElement = $(clickElementSelector);

                        var offset = clickElement.offset();
                        var width = clickElement.outerWidth();
                        var height = clickElement.outerHeight();

                        pulseElement.css({ "width": width, "height": height, "left": offset.left, "top": offset.top });
                        pulseElement.fadeIn();

                    }, 1000);
                }
            }

            function waitForPendingRerequests() {
                var deferred = $q.defer();
                var timer = window.setInterval(function () {

                    var requestsReady = false;
                    var animationsDone = false;

                    // check for pending requests both in angular and on the document
                    if ($http.pendingRequests.length === 0 && document.readyState === "complete") {
                        requestsReady = true;
                    }

                    // check for animations. ng-enter and ng-leave are default angular animations. 
                    // Also check for infinite editors animating
                    if (document.querySelectorAll(".ng-enter, .ng-leave, .umb-editor--animating").length === 0) {
                        animationsDone = true;
                    }

                    if (requestsReady && animationsDone) {
                        $timeout(function () {
                            deferred.resolve();
                            clearInterval(timer);
                        });
                    }

                }, 50);
                return deferred.promise;
            }

            function findMax(obj) {
                var keys = Object.keys(obj);
                var max = keys[0];
                for (var i = 1, n = keys.length; i < n; ++i) {
                    var k = keys[i];
                    if (obj[k] > obj[max]) {
                        max = k;
                    }
                }
                return max;
            }

            function bindEvent() {

                var bindToElement = scope.model.currentStep.element;
                var eventName = scope.model.currentStep.event + ".step-" + scope.model.currentStepIndex;
                var removeEventName = "remove.step-" + scope.model.currentStepIndex;
                var handled = false;

                if (scope.model.currentStep.eventElement) {
                    bindToElement = scope.model.currentStep.eventElement;
                }

                $(bindToElement).on(eventName, function () {
                    if (!handled) {
                        unbindEvent();
                        nextStep();
                        handled = true;
                    }
                });

                // Hack: we do this to handle cases where ng-if is used and removes the element we need to click.
                // for some reason it seems the elements gets removed before the event is raised. This is a temp solution which assumes:
                // "if you ask me to click on an element, and it suddenly gets removed from the dom, let's go on to the next step".
                $(bindToElement).on(removeEventName, function () {
                    if (!handled) {
                        unbindEvent();
                        nextStep();
                        handled = true;
                    }
                });

            }

            function unbindEvent() {
                var eventName = scope.model.currentStep.event + ".step-" + scope.model.currentStepIndex;
                var removeEventName = "remove.step-" + scope.model.currentStepIndex;

                if (scope.model.currentStep.eventElement) {
                    $(scope.model.currentStep.eventElement).off(eventName);
                    $(scope.model.currentStep.eventElement).off(removeEventName);
                } else {
                    $(scope.model.currentStep.element).off(eventName);
                    $(scope.model.currentStep.element).off(removeEventName);
                }
            }

            function resize() {
                findHighlightElement();
            }

            onInit();

            $(window).on('resize.umbTour', resize);

            scope.$on('$destroy', function () {
                $(window).off('resize.umbTour');
                unbindEvent();
                $timeout.cancel(pulseTimer);
            });

        }

        var directive = {
            transclude: true,
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/application/umb-tour.html',
            link: link,
            scope: {
                model: "="
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbTour', TourDirective);

})();

----
application/umblogin.directive.js
(function () {
    'use strict';

    angular
        .module('umbraco.directives')
        .component('umbLogin', {
            templateUrl: 'views/components/application/umb-login.html',
            controller: UmbLoginController,
            controllerAs: 'vm',
            bindings: {
                isTimedOut: "<",
                onLogin: "&"
            }
        });

    function UmbLoginController($scope, $location, currentUserResource, formHelper,
        mediaHelper, umbRequestHelper, Upload, localizationService,
        userService, externalLoginInfo, externalLoginInfoService,
        resetPasswordCodeInfo, authResource, $q) {

        const vm = this;

        vm.invitedUser = null;

        vm.invitedUserPasswordModel = {
            password: "",
            confirmPassword: "",
            buttonState: "",
            passwordPolicies: null,
            passwordPolicyText: ""
        };

        vm.loginStates = {
            submitButton: "init"
        };

        vm.avatarFile = {
            filesHolder: null,
            uploadStatus: null,
            uploadProgress: 0,
            maxFileSize: Umbraco.Sys.ServerVariables.umbracoSettings.maxFileSize + "KB",
            acceptedFileTypes: mediaHelper.formatFileTypes(Umbraco.Sys.ServerVariables.umbracoSettings.imageFileTypes),
            uploaded: false
        };

        vm.allowPasswordReset = Umbraco.Sys.ServerVariables.umbracoSettings.canSendRequiredEmail && Umbraco.Sys.ServerVariables.umbracoSettings.allowPasswordReset;
        vm.errorMsg = "";
        const tempUrl = new URL(Umbraco.Sys.ServerVariables.umbracoUrls.externalLoginsUrl, window.location.origin);
        tempUrl.searchParams.append("redirectUrl", decodeURIComponent($location.search().returnPath ?? ""))

        vm.externalLoginFormAction = tempUrl.pathname + tempUrl.search;
        vm.externalLoginProviders = externalLoginInfoService.getLoginProviders();
        vm.externalLoginProviders.forEach(x => {
            x.customView = externalLoginInfoService.getLoginProviderView(x);
            // if there are errors set for this specific provider than assign them directly to the model
            if (externalLoginInfo.errorProvider === x.authType) {
                x.errors = externalLoginInfo.errors;
            }
        });
        vm.denyLocalLogin = externalLoginInfoService.hasDenyLocalLogin();
        vm.externalLoginInfo = externalLoginInfo;
        vm.resetPasswordCodeInfo = resetPasswordCodeInfo;
        vm.logoImage = Umbraco.Sys.ServerVariables.umbracoSettings.loginLogoImage;
        vm.backgroundImage = Umbraco.Sys.ServerVariables.umbracoSettings.loginBackgroundImage;
        vm.usernameIsEmail = Umbraco.Sys.ServerVariables.umbracoSettings.usernameIsEmail;

        vm.$onInit = onInit;
        vm.togglePassword = togglePassword;
        vm.changeAvatar = changeAvatar;
        vm.getStarted = getStarted;
        vm.inviteSavePassword = inviteSavePassword;
        vm.showLogin = showLogin;
        vm.showRequestPasswordReset = showRequestPasswordReset;
        vm.showSetPassword = showSetPassword;
        vm.loginSubmit = loginSubmit;
        vm.requestPasswordResetSubmit = requestPasswordResetSubmit;
        vm.setPasswordSubmit = setPasswordSubmit;
        vm.newPasswordKeyUp = newPasswordKeyUp;
        vm.labels = {};
        localizationService.localizeMany([
            vm.usernameIsEmail ? "general_email" : "general_username",
            vm.usernameIsEmail ? "placeholders_email" : "placeholders_usernameHint",
            vm.usernameIsEmail ? "placeholders_emptyEmail" : "placeholders_emptyUsername",
            "placeholders_emptyPassword"]
        ).then(function (data) {
            vm.labels.usernameLabel = data[0];
            vm.labels.usernamePlaceholder = data[1];
            vm.labels.usernameError = data[2];
            vm.labels.passwordError = data[3];
        });

        vm.twoFactor = {};

        vm.loginSuccess = loginSuccess;

        function onInit() {

            // Check if it is a new user
            const inviteVal = $location.search().invite;

            //1 = enter password, 2 = password set, 3 = invalid token
            if (inviteVal && (inviteVal === "1" || inviteVal === "2")) {

                $q.all([
                    //get the current invite user
                    authResource.getCurrentInvitedUser().then(function (data) {
                        vm.invitedUser = data;
                    },
                        function () {
                            //it failed so we should remove the search
                            $location.search('invite', null);
                        }),
                    //get the membership provider config for password policies
                    authResource.getPasswordConfig(0).then(function (data) {
                        vm.invitedUserPasswordModel.passwordPolicies = data;

                        //localize the text
                        localizationService.localize("errorHandling_errorInPasswordFormat", [
                            vm.invitedUserPasswordModel.passwordPolicies.minPasswordLength,
                            vm.invitedUserPasswordModel.passwordPolicies.minNonAlphaNumericChars
                        ]).then(function (data) {
                            vm.invitedUserPasswordModel.passwordPolicyText = data;
                        });
                    })
                ]).then(function () {
                    vm.inviteStep = Number(inviteVal);
                });

            } else if (inviteVal && inviteVal === "3") {
                vm.inviteStep = Number(inviteVal);
            }

            // set the welcome greeting
            setGreeting();

            // show the correct panel
            if (vm.resetPasswordCodeInfo.resetCodeModel) {
                vm.showSetPassword();
            }
            else if (vm.resetPasswordCodeInfo.errors.length > 0) {
                vm.view = "password-reset-code-expired";
            }
            else {
                vm.showLogin();
            }

            SetTitle();
        }

        function togglePassword() {
            var elem = $("form[name='vm.loginForm'] input[name='password']");
            elem.attr("type", (elem.attr("type") === "text" ? "password" : "text"));
            elem.focus();
            $(".password-text.show, .password-text.hide").toggle();
        }

        function changeAvatar(files, event) {
            if (files && files.length > 0) {
                upload(files[0]);
            }
        }

        function getStarted() {
            $location.search('invite', null);
            if (vm.onLogin) {
                vm.onLogin();
            }
        }

        function inviteSavePassword() {

            if (formHelper.submitForm({ scope: $scope, formCtrl: vm.inviteUserPasswordForm })) {

                vm.invitedUserPasswordModel.buttonState = "busy";

                currentUserResource.performSetInvitedUserPassword(vm.invitedUserPasswordModel.password)
                    .then(function (data) {

                        //success
                        formHelper.resetForm({ scope: $scope, formCtrl: vm.inviteUserPasswordForm });
                        vm.invitedUserPasswordModel.buttonState = "success";
                        //set the user and set them as logged in
                        vm.invitedUser = data;
                        userService.setAuthenticationSuccessful(data);

                        vm.inviteStep = 2;

                    }, function (err) {
                        formHelper.resetForm({ scope: $scope, hasErrors: true, formCtrl: vm.inviteUserPasswordForm });
                        formHelper.handleError(err);
                        vm.invitedUserPasswordModel.buttonState = "error";
                    });
            }
        }

        function showLogin() {
            vm.errorMsg = "";
            resetInputValidation();
            vm.view = "login";
            SetTitle();
        }

        function showRequestPasswordReset() {
            vm.errorMsg = "";
            resetInputValidation();
            vm.view = "request-password-reset";
            vm.showEmailResetConfirmation = false;
            SetTitle();
        }

        function showSetPassword() {
            vm.errorMsg = "";
            resetInputValidation();
            vm.view = "set-password";
            SetTitle();
        }

        function loginSuccess() {
            vm.loginStates.submitButton = "success";
            userService._retryRequestQueue(true);
            if (vm.onLogin) {
                vm.onLogin();
            }
        }

        function loginSubmit() {

            if (formHelper.submitForm({ scope: $scope, formCtrl: vm.loginForm })) {
                //if the login and password are not empty we need to automatically
                // validate them - this is because if there are validation errors on the server
                // then the user has to change both username & password to resubmit which isn't ideal,
                // so if they're not empty, we'll just make sure to set them to valid.
                if (vm.login && vm.password && vm.login.length > 0 && vm.password.length > 0) {
                    vm.loginForm.username.$setValidity('auth', true);
                    vm.loginForm.password.$setValidity('auth', true);
                }

                if (vm.loginForm.$invalid) {
                    SetTitle();
                    return;
                }

                // make sure that we are returning to the login view.
                vm.view = "login";

                vm.loginStates.submitButton = "busy";

                userService.authenticate(vm.login, vm.password)
                    .then(function (data) {
                        loginSuccess();
                    },
                        function (reason) {

                            //is Two Factor required?
                            if (reason.status === 402) {
                                vm.errorMsg = "Additional authentication required";
                                show2FALoginDialog(reason.data.twoFactorView);
                            } else {
                                vm.loginStates.submitButton = "error";
                                vm.errorMsg = reason.errorMsg;

                                //set the form inputs to invalid
                                vm.loginForm.username.$setValidity("auth", false);
                                vm.loginForm.password.$setValidity("auth", false);
                            }

                            userService._retryRequestQueue();

                        });

                //setup a watch for both of the model values changing, if they change
                // while the form is invalid, then revalidate them so that the form can
                // be submitted again.
                vm.loginForm.username.$viewChangeListeners.push(function () {
                    if (vm.loginForm.$invalid) {
                        vm.loginForm.username.$setValidity('auth', true);
                        vm.loginForm.password.$setValidity('auth', true);
                    }
                });
                vm.loginForm.password.$viewChangeListeners.push(function () {
                    if (vm.loginForm.$invalid) {
                        vm.loginForm.username.$setValidity('auth', true);
                        vm.loginForm.password.$setValidity('auth', true);
                    }
                });
            }
        }

        function requestPasswordResetSubmit(email) {

            // TODO: Do validation properly like in the invite password update

            if (email && email.length > 0) {
                vm.requestPasswordResetForm.email.$setValidity('auth', true);
            }

            vm.showEmailResetConfirmation = false;

            if (vm.requestPasswordResetForm.$invalid) {
                vm.errorMsg = 'Email address cannot be empty';
                return;
            }

            vm.errorMsg = "";

            authResource.performRequestPasswordReset(email)
                .then(function () {
                    //remove the email entered
                    vm.email = "";
                    vm.showEmailResetConfirmation = true;
                }, function (reason) {
                    vm.errorMsg = reason.errorMsg;
                    vm.requestPasswordResetForm.email.$setValidity("auth", false);
                });

            vm.requestPasswordResetForm.email.$viewChangeListeners.push(function () {
                if (vm.requestPasswordResetForm.email.$invalid) {
                    vm.requestPasswordResetForm.email.$setValidity('auth', true);
                }
            });
        }

        function setPasswordSubmit(password, confirmPassword) {

            vm.showSetPasswordConfirmation = false;

            if (password && confirmPassword && password.length > 0 && confirmPassword.length > 0) {
                vm.setPasswordForm.password.$setValidity('auth', true);
                vm.setPasswordForm.confirmPassword.$setValidity('auth', true);
            }

            if (vm.setPasswordForm.$invalid) {
                return;
            }

            // TODO: All of this logic can/should be shared! We should do validation the nice way instead of all of this manual stuff, see: inviteSavePassword
            authResource.performSetPassword(vm.resetPasswordCodeInfo.resetCodeModel.userId, password, confirmPassword, vm.resetPasswordCodeInfo.resetCodeModel.resetCode)
                .then(function () {
                    vm.showSetPasswordConfirmation = true;
                    vm.resetComplete = true;

                    //reset the values in the resetPasswordCodeInfo angular so if someone logs out the change password isn't shown again
                    resetPasswordCodeInfo.resetCodeModel = null;

                }, function (reason) {
                    if (reason.data && reason.data.Message) {
                        vm.errorMsg = reason.data.Message;
                    }
                    else {
                        vm.errorMsg = reason.errorMsg;
                    }
                    vm.setPasswordForm.password.$setValidity("auth", false);
                    vm.setPasswordForm.confirmPassword.$setValidity("auth", false);
                });

            vm.setPasswordForm.password.$viewChangeListeners.push(function () {
                if (vm.setPasswordForm.password.$invalid) {
                    vm.setPasswordForm.password.$setValidity('auth', true);
                }
            });

            vm.setPasswordForm.confirmPassword.$viewChangeListeners.push(function () {
                if (vm.setPasswordForm.confirmPassword.$invalid) {
                    vm.setPasswordForm.confirmPassword.$setValidity('auth', true);
                }
            });
        }

        function newPasswordKeyUp(event) {
            vm.passwordVal = event.target.value;
        }

        ////

        function setGreeting() {
            const date = new Date();
            localizationService.localize("login_greeting" + date.getDay()).then(function (label) {
                $scope.greeting = label;
            });
        }

        function upload(file) {

            vm.avatarFile.uploadProgress = 0;

            Upload.upload({
                url: umbRequestHelper.getApiUrl("currentUserApiBaseUrl", "PostSetAvatar"),
                fields: {},
                file: file
            }).progress(function (evt) {

                if (vm.avatarFile.uploadStatus !== "done" && vm.avatarFile.uploadStatus !== "error") {
                    // set uploading status on file
                    vm.avatarFile.uploadStatus = "uploading";

                    // calculate progress in percentage
                    var progressPercentage = parseInt(100.0 * evt.loaded / evt.total, 10);

                    // set percentage property on file
                    vm.avatarFile.uploadProgress = progressPercentage;
                }

            }).success(function (data, status, headers, config) {

                vm.avatarFile.uploadProgress = 100;

                // set done status on file
                vm.avatarFile.uploadStatus = "done";

                vm.invitedUser.avatars = data;

                vm.avatarFile.uploaded = true;

            }).error(function (evt, status, headers, config) {

                // set status done
                vm.avatarFile.uploadStatus = "error";

                // If file not found, server will return a 404 and display this message
                if (status === 404) {
                    vm.avatarFile.serverErrorMessage = "File not found";
                }
                else if (status == 400) {
                    //it's a validation error
                    vm.avatarFile.serverErrorMessage = evt.message;
                }
                else {
                    //it's an unhandled error
                    //if the service returns a detailed error
                    if (evt.InnerException) {
                        vm.avatarFile.serverErrorMessage = evt.InnerException.ExceptionMessage;

                        //Check if its the common "too large file" exception
                        if (evt.InnerException.StackTrace && evt.InnerException.StackTrace.indexOf("ValidateRequestEntityLength") > 0) {
                            vm.avatarFile.serverErrorMessage = "File too large to upload";
                        }

                    } else if (evt.Message) {
                        vm.avatarFile.serverErrorMessage = evt.Message;
                    }
                }
            });
        }

        function show2FALoginDialog(viewPath) {
            vm.twoFactor.submitCallback = function submitCallback() {
                vm.onLogin();
            }
            vm.twoFactor.cancelCallback = function cancelCallback() {
              vm.showLogin();
            }
            vm.twoFactor.view = viewPath;
            vm.view = "2fa-login";
            SetTitle();
        }

        function resetInputValidation() {
            vm.loginStates.submitButton = "init";
            vm.confirmPassword = "";
            vm.password = "";
            vm.login = "";
            if (vm.loginForm) {
                vm.loginForm.username.$setValidity('auth', true);
                vm.loginForm.password.$setValidity('auth', true);
            }
            if (vm.requestPasswordResetForm) {
                vm.requestPasswordResetForm.email.$setValidity("auth", true);
            }
            if (vm.setPasswordForm) {
                vm.setPasswordForm.password.$setValidity('auth', true);
                vm.setPasswordForm.confirmPassword.$setValidity('auth', true);
            }
        }


        function SetTitle() {
            var title = null;
            switch (vm.view.toLowerCase()) {
                case "login":
                    title = "Login";
                    break;
                case "password-reset-code-expired":
                case "request-password-reset":
                    title = "Password Reset";
                    break;
                case "set-password":
                    title = "Change Password";
                    break;
                case "2fa-login":
                    title = "Two Factor Authentication";
                    break;
            }

            $scope.$emit("$changeTitle", title);
        }

    }

})();

----
application/navresize.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:navResize
* @restrict A
 *
 * @description
 * Handles how the navigation responds to window resizing and controls how the draggable resize panel works
**/
angular.module("umbraco.directives")
    .directive('navResize', function (appState, eventsService, windowResizeListener) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs, ctrl) {

                var minScreenSize = 1100;
                var resizeEnabled = false;

                function setTreeMode() {
                    appState.setGlobalState("showNavigation", appState.getGlobalState("isTablet") === false);
                }

                function enableResize() {
                    //only enable when the size is correct and it's not already enabled
                    if (!resizeEnabled && appState.getGlobalState("isTablet") === false) {
                        element.resizable(
                        {
                            containment: $("#mainwrapper"),
                            autoHide: true,
                            handles: "e",
                            alsoResize: ".navigation-inner-container",
                            resize: function(e, ui) {
                                var wrapper = $("#mainwrapper");
                                var contentPanel = $("#contentwrapper");
                                var umbNotification = $("#umb-notifications-wrapper");
                                var bottomBar = contentPanel.find(".umb-bottom-bar");
                                var navOffeset = $("#navOffset");

                                var leftPanelWidth = ui.element.width();

                                contentPanel.css({ left: leftPanelWidth });
                                bottomBar.css({ left: leftPanelWidth });
                                umbNotification.css({ left: leftPanelWidth });

                                navOffeset.css({ "margin-left": ui.element.outerWidth() });
                            },
                            stop: function (e, ui) {

                            }
                        });

                        resizeEnabled = true;
                    }
                }

                function resetResize() {
                    if (resizeEnabled) {
                        //kill the resize
                        element.resizable("destroy");
                        element.css("width", "");

                        var navInnerContainer = element.find(".navigation-inner-container");

                        navInnerContainer.css("width", "");
                        $("#contentwrapper").css("left", "");
                        $("#umb-notifications-wrapper").css("left", "");
                        $("#navOffset").css("margin-left", "");

                        resizeEnabled = false;
                    }
                }

                var evts = [];

                //Listen for global state changes
                evts.push(eventsService.on("appState.globalState.changed", function (e, args) {
                    if (args.key === "showNavigation") {
                        if (args.value === false) {
                            resetResize();
                        }
                        else {
                            enableResize();
                        }
                    }
                }));

                var resizeCallback = function(size) {
                    //set the global app state
                    appState.setGlobalState("isTablet", (size.width <= minScreenSize));
                    setTreeMode();
                };

                windowResizeListener.register(resizeCallback);

                //ensure to unregister from all events and kill jquery plugins
                scope.$on('$destroy', function () {
                    windowResizeListener.unregister(resizeCallback);
                    for (var e in evts) {
                        eventsService.unsubscribe(evts[e]);
                    }
                    var navInnerContainer = element.find(".navigation-inner-container");
                    navInnerContainer.resizable("destroy");
                });

                //init
                //set the global app state
                appState.setGlobalState("isTablet", ($(window).width() <= minScreenSize));
                setTreeMode();
            }
        };
    });

----
application/umbsections.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbSections
* @restrict E
**/
function sectionsDirective($timeout, $window, navigationService, treeService, sectionService, appState, eventsService, $location, historyService) {
    return {
        restrict: "E",    // restrict to an element
        replace: true,   // replace the html element with the template
        templateUrl: 'views/components/application/umb-sections.html',
        link: function (scope, element, attr, ctrl) {

            var sectionItemsWidth = [];
            var evts = [];

            //setup scope vars
            scope.sections = [];
            scope.visibleSections = 0;
            scope.currentSection = appState.getSectionState("currentSection");
            scope.showTray = false;
            scope.stickyNavigation = appState.getGlobalState("stickyNavigation");

            function loadSections() {
                sectionService.getSectionsForUser()
                    .then(function (result) {
                        scope.sections = result;
                        scope.visibleSections = scope.sections.length;

                        // store the width of each section so we can hide/show them based on browser width 
                        // we store them because the sections get removed from the dom and then we 
                        // can't tell when to show them gain
                        $timeout(function () {
                            $("#applications .sections li:not(:last)").each(function (index) {
                                sectionItemsWidth.push($(this).outerWidth());
                            });
                        });
                        calculateWidth();
                    });
            }

            function calculateWidth() {
                $timeout(function () {
                    //total width minus room for avatar, search, and help icon
                    var containerWidth = $(".umb-app-header").outerWidth() - $(".umb-app-header__actions").outerWidth();
                    var trayToggleWidth = $("#applications .sections li.expand").outerWidth();
                    var sectionsWidth = 0;
                    
                    // detect how many sections we can show on the screen
                    for (var i = 0; i < sectionItemsWidth.length; i++) {
                        var sectionItemWidth = sectionItemsWidth[i];
                        sectionsWidth += sectionItemWidth;

                        if (sectionsWidth + trayToggleWidth > containerWidth) {
                            scope.visibleSections =  i;
                            return;
                        }
                    }

                    scope.visibleSections = scope.sections.length;
                });
            }

            //Listen for global state changes
            evts.push(eventsService.on("appState.globalState.changed", function (e, args) {
                if (args.key === "showTray") {
                    scope.showTray = args.value;
                }
                if (args.key === "stickyNavigation") {
                    scope.stickyNavigation = args.value;
                }
            }));

            evts.push(eventsService.on("appState.sectionState.changed", function (e, args) {
                if (args.key === "currentSection") {
                    scope.currentSection = args.value;
                }
            }));

            evts.push(eventsService.on("app.reInitialize", function (e, args) {
                //re-load the sections if we're re-initializing (i.e. package installed)
                loadSections();
            }));

            //ensure to unregister from all events!
            scope.$on('$destroy', function () {
                for (var e in evts) {
                    eventsService.unsubscribe(evts[e]);
                }
            });

            //on page resize
            window.onresize = calculateWidth;

            scope.sectionClick = function (event, section) {

                if (event.ctrlKey ||
                    event.shiftKey ||
                    event.metaKey || // apple
                    (event.button && event.button === 1) // middle click, >IE9 + everyone else
                ) {
                    return;
                }

                navigationService.hideSearch();
                navigationService.showTree(section.alias);

                //in some cases the section will have a custom route path specified, if there is one we'll use it
                if (section.routePath) {
                    $location.path(section.routePath);
                }
                else {
                    var lastAccessed = historyService.getLastAccessedItemForSection(section.alias);
                    var path = lastAccessed != null ? lastAccessed.link : section.alias;
                    $location.path(path);
                }
                navigationService.clearSearch();

            };

            scope.sectionDblClick = function (section) {
                navigationService.reloadSection(section.alias);
            };

            scope.trayClick = function () {
                if (appState.getGlobalState("showTray") === true) {
                    navigationService.hideTray();
                } else {
                    navigationService.showTray();
                }
            };

            scope.currentSectionInOverflow = function () {
                var currentSection = scope.sections.filter(s => s.alias === scope.currentSection);

                return currentSection.length > 0 && scope.sections.indexOf(currentSection[0]) > scope.visibleSections - 1;
            };

            loadSections();

        }
    };
}

angular.module('umbraco.directives').directive("umbSections", sectionsDirective);

----
application/_readme.md
#Application

Directives used for the main application window. Navigation, sections etc.

----
application/umbappheader.directive.js
(function () {
    "use strict";

    function AppHeaderDirective(eventsService, appState, userService, focusService, $timeout, editorService) {

        function link(scope, element) {

            var evts = [];

            // the null is important because we do an explicit bool check on this in the view
            // the avatar is by default the umbraco logo
            scope.authenticated = null;
            scope.user = null;
            scope.avatar = [
                { value: "assets/img/application/logo.png" },
                { value: "assets/img/application/logo@2x.png" },
                { value: "assets/img/application/logo@3x.png" }
            ];
            scope.hideBackofficeLogo = Umbraco.Sys.ServerVariables.umbracoSettings.hideBackofficeLogo;

            // when a user logs out or timesout
            evts.push(eventsService.on("app.notAuthenticated", function () {
                scope.authenticated = false;
                scope.user = null;
            }));

            // when the application is ready and the user is authorized setup the data
            evts.push(eventsService.on("app.ready", function (evt, data) {

                scope.authenticated = true;
                scope.user = data.user;

                if (scope.user.avatars) {
                    scope.avatar = [];
                    if (Utilities.isArray(scope.user.avatars)) {
                        for (var i = 0; i < scope.user.avatars.length; i++) {
                            scope.avatar.push({ value: scope.user.avatars[i] });
                        }
                    }
                }

            }));

            evts.push(eventsService.on("app.userRefresh", function (evt) {
                userService.refreshCurrentUser().then(function (data) {
                    scope.user = data;

                    if (scope.user.avatars) {
                        scope.avatar = [];
                        if (Utilities.isArray(scope.user.avatars)) {
                            for (var i = 0; i < scope.user.avatars.length; i++) {
                                scope.avatar.push({ value: scope.user.avatars[i] });
                            }
                        }
                    }
                });
            }));

            scope.rememberFocus = focusService.rememberFocus;

            scope.searchClick = function () {
                var showSearch = appState.getSearchState("show");
                appState.setSearchState("show", !showSearch);
            };

            // toggle the help dialog by raising the global app state to toggle the help drawer
            scope.helpClick = function () {
                var showDrawer = appState.getDrawerState("showDrawer");
                var drawer = { view: "help", show: !showDrawer };
                appState.setDrawerState("view", drawer.view);
                appState.setDrawerState("showDrawer", drawer.show);
            };

            scope.avatarClick = function () {
                const userEditor = {
                  size: "small",
                  view: "views/common/infiniteeditors/user/user.html",
                  close: function() {
                    editorService.close();
                  }
                };

                editorService.open(userEditor);
            };

            scope.logoModal = {
                show: false,
                text: "",
                timer: null
            };
            scope.showLogoModal = function() {
                $timeout.cancel(scope.logoModal.timer);
                scope.logoModal.show = true;
                scope.logoModal.text = "version "+Umbraco.Sys.ServerVariables.application.version;
                $timeout(function () {
                    const anchorLink = element[0].querySelector('.umb-app-header__logo-modal');
                    if(anchorLink) {
                        anchorLink.focus();
                    }
                    const anchorButton = element[0].querySelector('#umbraco-logo-mark');
                    anchorButton.classList.add("active");
                });
            };
            scope.keepLogoModal = function() {
                $timeout.cancel(scope.logoModal.timer);
            };
            scope.hideLogoModal = function() {
                if(scope.logoModal.show === true) {
                    $timeout.cancel(scope.logoModal.timer);
                    scope.logoModal.timer = $timeout(function () {
                        scope.logoModal.show = false;
                    }, 100);
                  const anchorButton = element[0].querySelector('#umbraco-logo-mark');
                  anchorButton.classList.remove("active");
                }
            };
            scope.stopClickEvent = function($event) {
                $event.stopPropagation();
            };

            scope.toggleLogoModal = function() {
                if(scope.logoModal.show) {
                    $timeout.cancel(scope.logoModal.timer);
                    scope.logoModal.show = false;
                } else {
                    scope.showLogoModal();
                }
            };

            scope.skipToMenu = function() {
                document.querySelector('#applications a').focus();
            };

            scope.skipToContent = function() {
                var focusableElements = document.querySelectorAll('.umb-app-content a, .umb-app-content button');
                for(var i=0; i < focusableElements.length; i++){
                    if(focusableElements[i].offsetParent !== null) {
                        focusableElements[i].focus();
                        break;
                    }
                }
            };

        }

        var directive = {
            transclude: true,
            restrict: "E",
            replace: true,
            templateUrl: "views/components/application/umb-app-header.html",
            link: link,
            scope: {}
        };

        return directive;

    }

    angular.module("umbraco.directives").directive("umbAppHeader", AppHeaderDirective);

})();

----
application/umbnavigation.directive.js
﻿/**
* @ngdoc directive
* @name umbraco.directives.directive:umbNavigation
* @restrict E
**/
function umbNavigationDirective() {
    return {
        restrict: "E",    // restrict to an element
        replace: true,   // replace the html element with the template
        templateUrl: 'views/components/application/umb-navigation.html'
    };
}

angular.module('umbraco.directives').directive("umbNavigation", umbNavigationDirective);

----
application/umbbackdrop.directive.js
(function () {
    "use strict";

    function BackdropDirective($timeout, $http) {

        function link(scope, el, attr, ctrl) {

            var events = [];

            scope.clickBackdrop = function (event) {
                if (scope.disableEventsOnClick === true) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            };

            function onInit() {

                if (scope.highlightElement) {
                    setHighlight();
                }

            }

            function setHighlight() {

                scope.loading = true;

                $timeout(function () {

                    // The element to highlight
                    var highlightElement = $(scope.highlightElement);

                    if (highlightElement && highlightElement.length > 0) {

                        var offset = highlightElement.offset();
                        var width = highlightElement.outerWidth();
                        var height = highlightElement.outerHeight();

                        // Rounding numbers
                        var topDistance = offset.top.toFixed();
                        var topAndHeight = (offset.top + height).toFixed();
                        var leftDistance = offset.left.toFixed();
                        var leftAndWidth = (offset.left + width).toFixed();

                        // The four rectangles
                        var rectTop = el.find(".umb-backdrop__rect--top");
                        var rectRight = el.find(".umb-backdrop__rect--right");
                        var rectBottom = el.find(".umb-backdrop__rect--bottom");
                        var rectLeft = el.find(".umb-backdrop__rect--left");

                        // Add the css
                        scope.rectTopCss = { "height": topDistance, "left": leftDistance + "px", opacity: scope.backdropOpacity };
                        scope.rectRightCss = { "left": leftAndWidth + "px", "top": topDistance + "px", "height": height, opacity: scope.backdropOpacity };
                        scope.rectBottomCss = { "height": "100%", "top": topAndHeight + "px", "left": leftDistance + "px", opacity: scope.backdropOpacity };
                        scope.rectLeftCss = { "width": leftDistance, opacity: scope.backdropOpacity };

                        // Prevent interaction in the highlighted area
                        if (scope.highlightPreventClick) {
                            var preventClickElement = el.find(".umb-backdrop__highlight-prevent-click");
                            preventClickElement.css({ "width": width, "height": height, "left": offset.left, "top": offset.top });
                        }

                    }

                    scope.loading = false;

                });

            }

            function resize() {
                setHighlight();
            }

            events.push(scope.$watch("highlightElement", function (newValue, oldValue) {
                if (!newValue) { return; }
                if (newValue === oldValue) { return; }
                setHighlight();
            }));

            $(window).on("resize.umbBackdrop", resize);

            scope.$on("$destroy", function () {
                // unbind watchers
                for (var e in events) {
                    events[e]();
                }
                $(window).off("resize.umbBackdrop");
            });

            onInit();

        }

        var directive = {
            transclude: true,
            restrict: "E",
            replace: true,
            templateUrl: "views/components/application/umb-backdrop.html",
            link: link,
            scope: {
                backdropOpacity: "=?",
                highlightElement: "=?",
                highlightPreventClick: "=?",
                disableEventsOnClick: "=?"
            }
        };

        return directive;

    }

    angular.module("umbraco.directives").directive("umbBackdrop", BackdropDirective);

})();

----
application/umbtour/umbtourstep.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTourStep
@restrict E
@scope

@description
<b>Added in Umbraco 7.8</b>. The tour step component is a component that can be used in custom views for tour steps.

@param {callback} onClose The callback which should be performened when the close button of the tour step is clicked
@param {boolean=} hideClose A boolean indicating if the close button needs to be shown

**/
(function () {
    'use strict';

    function TourStepDirective() {

        function link(scope, element, attrs, ctrl) {

            scope.close = function () {
                if (scope.onClose) {
                   scope.onClose();
                }
            }

        }

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/application/umbtour/umb-tour-step.html',
            scope: {
                size: "@?",
                onClose: "&?",
                hideClose: "=?"
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbTourStep', TourStepDirective);

})();

----
application/umbtour/umbtourstepcontent.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTourStepContent
@restrict E
@scope

@description
<b>Added in Umbraco 7.8</b>. The tour step content component is a component that can be used in custom views for tour steps.
It's meant to be used in the umb-tour-step directive.
All markup in the body of the directive will be shown after the content attribute

@param {string} content The content that needs to be shown
**/
(function () {
    'use strict';

    function TourStepContentDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/application/umbtour/umb-tour-step-content.html',
            scope: {
                content: "="
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbTourStepContent', TourStepContentDirective);

})();

----
application/umbtour/umbtourstepcounter.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTourStepCounter
@restrict E
@scope

@description
<b>Added in Umbraco 7.8</b>. The tour step counter component is a component that can be used in custom views for tour steps.
It's meant to be used in the umb-tour-step-footer directive. It will show the progress you have made in a tour eg. step 2/12


@param {int} currentStep The current step the tour is on
@param {int} totalSteps The current step the tour is on
**/
(function () {
    'use strict';

    function TourStepCounterDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/application/umbtour/umb-tour-step-counter.html',
            scope: {
                currentStep: "=",
                totalSteps: "="
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbTourStepCounter', TourStepCounterDirective);

})();

----
application/umbtour/umbtourstepfooter.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTourStepFooter
@restrict E
@scope

@description
<b>Added in Umbraco 7.8</b>. The tour step footer component is a component that can be used in custom views for tour steps. It's meant to be used in the umb-tour-step directive.
All markup in the body of the directive will be shown as the footer of the tour step


**/
(function () {
    'use strict';

    function TourStepFooterDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/application/umbtour/umb-tour-step-footer.html'
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbTourStepFooter', TourStepFooterDirective);

})();

----
application/umbtour/umbtourstepheader.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbTourStepHeader
@restrict E
@scope

@description
<b>Added in Umbraco 7.8</b>. The tour step header component is a component that can be used in custom views for tour steps. It's meant to be used in the umb-tour-step directive.


@param {string} title The title that needs to be shown
**/
(function () {
    'use strict';

    function TourStepHeaderDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/application/umbtour/umb-tour-step-header.html',
            scope: {
                title: "="
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbTourStepHeader', TourStepHeaderDirective);

})();

----
application/umbdrawer/umbdrawerfooter.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbDrawerFooter
@restrict E
@scope

@description
Use this directive to render a drawer footer

<h3>Markup example</h3>
<pre>
	<umb-drawer-view>
        
        <umb-drawer-header
            title="Drawer Title"
            description="Drawer description">
        </umb-drawer-header>

        <umb-drawer-content>
            <!-- Your content here -->
            <pre>{{ model | json }}</pre>
        </umb-drawer-content>

        <umb-drawer-footer>
            <!-- Your content here -->
        </umb-drawer-footer>

	</umb-drawer-view>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbDrawerView umbDrawerView}</li>
    <li>{@link umbraco.directives.directive:umbDrawerHeader umbDrawerHeader}</li>
    <li>{@link umbraco.directives.directive:umbDrawerContent umbDrawerContent}</li>
</ul>

**/

(function() {
    'use strict';

    function DrawerFooterDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/application/umbdrawer/umb-drawer-footer.html'
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbDrawerFooter', DrawerFooterDirective);

})();

----
application/umbdrawer/umbdrawercontent.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbDrawerContent
@restrict E
@scope

@description
Use this directive to render drawer content

<h3>Markup example</h3>
<pre>
	<umb-drawer-view>
        
        <umb-drawer-header
            title="Drawer Title"
            description="Drawer description">
        </umb-drawer-header>

        <umb-drawer-content>
            <!-- Your content here -->
            <pre>{{ model | json }}</pre>
        </umb-drawer-content>

        <umb-drawer-footer>
            <!-- Your content here -->
        </umb-drawer-footer>

	</umb-drawer-view>
</pre>


<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbDrawerView umbDrawerView}</li>
    <li>{@link umbraco.directives.directive:umbDrawerHeader umbDrawerHeader}</li>
    <li>{@link umbraco.directives.directive:umbDrawerFooter umbDrawerFooter}</li>
</ul>

**/

(function() {
    'use strict';

    function DrawerContentDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/application/umbdrawer/umb-drawer-content.html'
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbDrawerContent', DrawerContentDirective);

})();

----
application/umbdrawer/umbdrawerheader.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbDrawerHeader
@restrict E
@scope

@description
Use this directive to render a drawer header

<h3>Markup example</h3>
<pre>
	<umb-drawer-view>
        
        <umb-drawer-header
            title="Drawer Title"
            description="Drawer description">
        </umb-drawer-header>

        <umb-drawer-content>
            <!-- Your content here -->
            <pre>{{ model | json }}</pre>
        </umb-drawer-content>

        <umb-drawer-footer>
            <!-- Your content here -->
        </umb-drawer-footer>

	</umb-drawer-view>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbDrawerView umbDrawerView}</li>
    <li>{@link umbraco.directives.directive:umbDrawerContent umbDrawerContent}</li>
    <li>{@link umbraco.directives.directive:umbDrawerFooter umbDrawerFooter}</li>
</ul>

@param {string} title (<code>attribute</code>): Set a drawer title.
@param {string} description (<code>attribute</code>): Set a drawer description.
**/

(function() {
    'use strict';

    function DrawerHeaderDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/application/umbdrawer/umb-drawer-header.html',
            scope: {
                "title": "@?",
                "description": "@?"
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbDrawerHeader', DrawerHeaderDirective);

})();

----
application/umbdrawer/umbdrawer.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbDrawer
@restrict E
@scope

@description
The drawer component is a global component and is already added to the umbraco markup. It is registered in globalState and can be opened and configured by raising events.

<h3>Markup example - how to open the drawer</h3>
<pre>
    <div ng-controller="My.DrawerController as vm">

        <umb-button
            type="button"
            label="Toggle drawer"
            action="vm.toggleDrawer()">
        </umb-button>

    </div>
</pre>

<h3>Controller example - how to open the drawer</h3>
<pre>
    (function () {
        "use strict";

        function DrawerController(appState) {

            var vm = this;

            vm.toggleDrawer = toggleDrawer;

            function toggleDrawer() {

                var showDrawer = appState.getDrawerState("showDrawer");            

                var model = {
                    firstName: "Super",
                    lastName: "Man"
                };

                appState.setDrawerState("view", "/App_Plugins/path/to/drawer.html");
                appState.setDrawerState("model", model);
                appState.setDrawerState("showDrawer", !showDrawer);
                
            }

        }

        angular.module("umbraco").controller("My.DrawerController", DrawerController);

    })();
</pre>

<h3>Use the following components in the custom drawer to render the content</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbDrawerView umbDrawerView}</li>
    <li>{@link umbraco.directives.directive:umbDrawerHeader umbDrawerHeader}</li>
    <li>{@link umbraco.directives.directive:umbDrawerContent umbDrawerContent}</li>
    <li>{@link umbraco.directives.directive:umbDrawerFooter umbDrawerFooter}</li>
</ul>

@param {string} view (<code>binding</code>): Set the drawer view
@param {string} model (<code>binding</code>): Pass in custom data to the drawer

**/

function Drawer($location, $routeParams, helpService, userService, localizationService, dashboardResource) {
    
        return {
    
            restrict: "E",    // restrict to an element
            replace: true,   // replace the html element with the template
            templateUrl: 'views/components/application/umbdrawer/umb-drawer.html',
            transclude: true,
            scope: {
                view: "=?",
                model: "=?"
            },
    
            link: function (scope, element, attr, ctrl) {
    
                function onInit() {
                    setView();
                }
    
                function setView() {
                    if (scope.view) {
                        //we do this to avoid a hidden dialog to start loading unconfigured views before the first activation
                        var configuredView = scope.view;
                        if (scope.view.indexOf(".html") === -1) {
                            var viewAlias = scope.view.toLowerCase();
                            configuredView = "views/common/drawers/" + viewAlias + "/" + viewAlias + ".html";
                        }
                        if (configuredView !== scope.configuredView) {
                            scope.configuredView = configuredView;
                        }
                    }
                }
    
                onInit();
               
            }
    
        };
    }
    
    angular.module('umbraco.directives').directive("umbDrawer", Drawer);

----
application/umbdrawer/umbdrawerview.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbDrawerView
@restrict E
@scope

@description
Use this directive to render drawer view

<h3>Markup example</h3>
<pre>
	<umb-drawer-view>
        
        <umb-drawer-header
            title="Drawer Title"
            description="Drawer description">
        </umb-drawer-header>

        <umb-drawer-content>
            <!-- Your content here -->
            <pre>{{ model | json }}</pre>
        </umb-drawer-content>

        <umb-drawer-footer>
            <!-- Your content here -->
        </umb-drawer-footer>

	</umb-drawer-view>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbDrawerHeader umbDrawerHeader}</li>
    <li>{@link umbraco.directives.directive:umbDrawerContent umbDrawerContent}</li>
    <li>{@link umbraco.directives.directive:umbDrawerFooter umbDrawerFooter}</li>
</ul>

**/

(function() {
    'use strict';

    function DrawerViewDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'views/components/application/umbdrawer/umb-drawer-view.html'
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbDrawerView', DrawerViewDirective);

})();

----
events/onDragOver.directive.js
(function () {
    'use strict';

    function onDragOverDirective(){

        function link(scope, elm, attrs) {
            var f = function () {
                scope.$apply(attrs.onDragOver);
            };
            elm.on("dragover", f);
            scope.$on("$destroy", function () { elm.off("dragover", f); });
        }

        var directive = {
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('onDragOver', onDragOverDirective);

})();

----
events/onDragEnter.directive.js
(function () {
    'use strict';

    function onDragEnterDirective(){

        function link(scope, elm, attrs) {
            var f = function () {
                scope.$apply(attrs.onDragEnter);
            };
            elm.on("dragenter", f);
            scope.$on("$destroy", function () { elm.off("dragenter", f); });
        }

        var directive = {
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('onDragEnter', onDragEnterDirective);

})();

----
events/onDelayedMouseleave.directive.js
(function () {
    'use strict';

    function onDelayedMouseleaveDirective($timeout, $parse){

        function link(scope, element, attrs, ctrl) {
            var active = false;
            var fn = $parse(attrs.onDelayedMouseleave);

            var leave_f = function (event) {
                var callback = function () {
                    fn(scope, { $event: event });
                };

                active = false;
                $timeout(function () {
                    if (active === false) {
                        scope.$apply(callback);
                    }
                }, 650);
            };

            var enter_f = function (event, args) {
                active = true;
            };


            element.on("mouseleave", leave_f);
            element.on("mouseenter", enter_f);

            //unsub events
            scope.$on("$destroy", function () {
                element.off("mouseleave", leave_f);
                element.off("mouseenter", enter_f);
            });
        }

        var directive = {
            restrict: 'A',
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('onDelayedMouseleave', onDelayedMouseleaveDirective);

})();

----
events/onDragStart.directive.js
(function () {
    'use strict';

    function onDragStartDirective($timeout){

        function link(scope, elm, attrs) {
            var f = function () {
                scope.$apply(attrs.onDragStart);
            };
            elm.on("dragstart", f);
            scope.$on("$destroy", function () { elm.off("dragstart", f); });
        }

        var directive = {
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('onDragStart', onDragStartDirective);

})();

----
events/deepBlur.directive.js
    // A slightly modified version of https://github.com/myplanet/angular-deep-blur/blob/master/angular-deep-blur.js - Kudos to Ufuk Kayserilioglu (paracycle)
    (function () {
        'use strict';

        function DeepBlurDirective($timeout){

            function controller($scope, $element, $attrs) {
                var leaveExpr = $attrs.deepBlur,
                    dom = $element[0];

                function containsDom(parent, dom) {
                    while (dom) {
                        if (dom === parent) {
                            return true;
                        }
                        dom = dom.parentNode;
                    }
                    return false;
                }

                function onBlur(e) {
                    var targetElement = e.relatedTarget;

                    if (!containsDom(dom, targetElement)) {
                        $timeout(function () {
                            $scope.$apply(leaveExpr);
                        }, 10);
                    }
                }

                dom.addEventListener('blur', onBlur, true);
            }

            var directive = {
                restrict: 'A',
                controller: controller
            };

            return directive;

        }

        angular.module('umbraco.directives').directive('deepBlur', DeepBlurDirective);

    })();

----
events/onDragLeave.directive.js
(function () {
    'use strict';

    function onDragLeaveDirective($timeout){

        return function (scope, elm, attrs) {
            var f = function (event) {
                var rect = this.getBoundingClientRect();
                var getXY = function getCursorPosition(event) {
                    var x, y;

                    if (typeof event.clientX === 'undefined') {
                        // try touch screen
                        x = event.pageX + document.documentElement.scrollLeft;
                        y = event.pageY + document.documentElement.scrollTop;
                    } else {
                        x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                        y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
                    }

                    return { x: x, y: y };
                };

                var e = getXY(event.originalEvent);

                // Check the mouseEvent coordinates are outside of the rectangle
                if (e.x > rect.left + rect.width - 1 || e.x < rect.left || e.y > rect.top + rect.height - 1 || e.y < rect.top) {
                    scope.$apply(attrs.onDragLeave);
                }
            };

            elm.on("dragleave", f);
            scope.$on("$destroy", function () { elm.off("dragleave", f); });
        };

    }

    angular.module('umbraco.directives').directive('onDragLeave', onDragLeaveDirective);

})();

----
events/onDragEnd.directive.js
(function () {
    'use strict';

    function onDragEndDirective(){

        function link(scope, elm, attrs) {
            var f = function () {
                scope.$apply(attrs.onDragEnd);
            };
            elm.on("dragend", f);
            scope.$on("$destroy", function () { elm.off("dragend", f); });
        }

        var directive = {
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('onDragEnd', onDragEndDirective);

})();

----
events/onOutsideClick.directive.js
(function () {
    'use strict';

    function onOutsideClickDirective($timeout, angularHelper){

        return function (scope, element, attrs) {

            var eventBindings = [];

            function oneTimeClick(event) {
                var el = event.target.nodeName;

                //ignore link and button clicks
                var els = ["INPUT", "A", "BUTTON"];
                if (els.indexOf(el) >= 0) { return; }

                // ignore clicks on new overlay
                var parents = $(event.target).parents("a,button,.umb-overlay,.umb-tour");
                if (parents.length > 0) {
                    return;
                }

                // ignore clicks on dialog from old dialog service
                var oldDialog = $(event.target).parents("#old-dialog-service");
                if (oldDialog.length === 1) {
                    return;
                }

                // ignore clicks in tinyMCE dropdown(floatpanel)
                var floatpanel = $(event.target).closest(".mce-floatpanel");
                if (floatpanel.length === 1) {
                    return;
                }

                // ignore clicks in flatpickr datepicker
                var flatpickr = $(event.target).closest(".flatpickr-calendar");
                if (flatpickr.length === 1) {
                    return;
                }

                //ignore clicks inside this element
                if ($(element).has($(event.target)).length > 0) {
                    return;
                }

                // please to not use angularHelper.safeApply here, it won't work
                scope.$evalAsync(attrs.onOutsideClick);
            }


            $timeout(function () {

                if ("bindClickOn" in attrs) {

                    eventBindings.push(scope.$watch(function () {
                        return attrs.bindClickOn;
                    }, function (newValue) {
                        if (newValue === "true") {
                            $(document).on("click", oneTimeClick);
                        } else {
                            $(document).off("click", oneTimeClick);
                        }
                    }));

                } else {
                    $(document).on("click", oneTimeClick);
                }

                scope.$on("$destroy", function () {
                    $(document).off("click", oneTimeClick);

                    // unbind watchers
                    for (var e in eventBindings) {
                        eventBindings[e]();
                    }

                });
            }); // Temp removal of 1 sec timeout to prevent bug where overlay does not open. We need to find a better solution.

        };

    }

    angular.module('umbraco.directives').directive('onOutsideClick', onOutsideClickDirective);

})();

----
events/onRightClick.directive.js
(function () {
    'use strict';

    function onRightClickDirective($parse){

        document.oncontextmenu = function (e) {
            if (e.target.hasAttribute('on-right-click')) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        };

        return function (scope, el, attrs) {
            el.on('contextmenu', function (e) {
                e.preventDefault();
                e.stopPropagation();
                var fn = $parse(attrs.onRightClick);
                scope.$apply(function () {
                    fn(scope, { $event: e });
                });
                return false;
            });
        };

    }

    angular.module('umbraco.directives').directive('onRightClick', onRightClickDirective);

})();

----
events/onDrop.directive.js
(function () {
    'use strict';

    function onDropDirective(){

        function link(scope, elm, attrs) {
            var f = function () {
                scope.$apply(attrs.onDrop);
            };
            elm.on("drop", f);
            scope.$on("$destroy", function () { elm.off("drop", f); });
        }

        var directive = {
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('onDrop', onDropDirective);

})();

----
notifications/umbnotifications.directive.js
/**
 * @ngdoc directive
 * @name umbraco.directives.directive:umbNotifications
 */

(function() {
   'use strict';

   function NotificationDirective(notificationsService) {

      function link(scope, el, attr, ctrl) {

         //subscribes to notifications in the notification service
         scope.notifications = notificationsService.current;
         scope.$watch('notificationsService.current', function (newVal, oldVal, scope) {
             if (newVal) {
                 scope.notifications = newVal;
             }
         });

      }

      var directive = {
         restrict: "E",
         replace: true,
         templateUrl: 'views/components/notifications/umb-notifications.html',
         link: link
      };

      return directive;

   }

   angular.module('umbraco.directives').directive('umbNotifications', NotificationDirective);

})();

----
editor/umbeditormenu.directive.js
(function () {
    'use strict';

    function EditorMenuDirective(treeService, navigationService, appState) {

        function link(scope, el, attr, ctrl) {

            scope.dropdown = {
                isOpen: false
            };

            function onInit() {

                getOptions();

            }

            //adds a handler to the context menu item click, we need to handle this differently
            //depending on what the menu item is supposed to do.
            scope.executeMenuItem = action => {
                //the action is called as it would be by the tree. to ensure that the action targets the correct node, 
                //we need to set the current node in appState before calling the action. otherwise we break all actions
                //that use the current node (and that's pretty much all of them)
                appState.setMenuState("currentNode", scope.currentNode);                
                navigationService.executeMenuAction(action, scope.currentNode, scope.currentSection);
                scope.dropdown.isOpen = false;
            };

            //callback method to go and get the options async
            function getOptions() {

                if (!scope.currentNode) {
                    return;
                }

                if (!scope.actions) {
                    treeService.getMenu({ treeNode: scope.currentNode }).then(data => {
                        scope.actions = data.menuItems;

                        // Map action icons using legacy icon font or svg icons.
                        Utilities.forEach(scope.actions, action => {
                          action.icon = (action.useLegacyIcon ? 'icon-' : '') + action.icon;
                        });
                    });
                }
            };

            onInit();

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editor-menu.html',
            link: link,
            scope: {
                currentNode: "=",
                currentSection: "@",
                isDisabled: "<?"
            }
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbEditorMenu', EditorMenuDirective);

})();

----
editor/umbeditors.directive.js
(function () {
    'use strict';

    function EditorsDirective($timeout, eventsService, focusLockService) {

        function link(scope, el, attr, ctrl) {

            var evts = [];
            var allowedNumberOfVisibleEditors = 3;
            var aboveBackDropCssClass = 'above-backdrop';
            var sectionId = '#leftcolumn';
            var isLeftColumnAbove = false;
            scope.editors = [];

            /* we need to keep a count of open editors because the length of the editors array is first changed when animations are done
             we do this because some infinite editors close more than one editor at the time and we get the wrong count from editors.length
             because of the animation */
            let editorCount = 0;

            function addEditor(editor) {
                editor.inFront = true;
                editor.moveRight = true;
                editor.level = 0;
                editor.styleIndex = 0;

                // push the new editor to the dom
                scope.editors.push(editor);

                if(scope.editors.length === 1){
                    isLeftColumnAbove = $(sectionId).hasClass(aboveBackDropCssClass);

                    if(isLeftColumnAbove){
                        $(sectionId).removeClass(aboveBackDropCssClass);
                    }

                    // Inert content in the #mainwrapper
                    focusLockService.addInertAttribute();
                }
                
                $timeout(() => {
                    editor.moveRight = false;
                })

                editor.animating = true;
                setTimeout(revealEditorContent.bind(this, editor), 400);

                updateEditors();

            }

            function removeEditor(editor) {
                editor.moveRight = true;

                editor.animating = true;
                setTimeout(removeEditorFromDOM.bind(this, editor), 400);

                updateEditors(-1);

                if(scope.editors.length === 1) {
                    if(isLeftColumnAbove){
                        $('#leftcolumn').addClass(aboveBackDropCssClass);
                    }

                    isLeftColumnAbove = false;
                }

                // when the last editor is closed remove the focus lock
                if (editorCount === 0) {
                    // Remove the inert attribute from the #mainwrapper
                    focusLockService.removeInertAttribute();
                }
            }

            function revealEditorContent(editor) {

                editor.animating = false;

                scope.$digest();

            }

            function removeEditorFromDOM(editor) {

                // push the new editor to the dom
                var index = scope.editors.indexOf(editor);
                if (index !== -1) {
                    scope.editors.splice(index, 1);
                }
 
                updateEditors();

                scope.$digest();

            }

            /** update layer positions. With ability to offset positions, needed for when an item is moving out, then we dont want it to influence positions */
            function updateEditors(offset) {

                offset = offset || 0;// fallback value.

                var len = scope.editors.length;
                var calcLen = len + offset;
                var ceiling = Math.min(calcLen, allowedNumberOfVisibleEditors);
                var origin = Math.max(calcLen - 1, 0) - ceiling;
                var i = 0;
                while (i < len) {
                    var iEditor = scope.editors[i];
                    iEditor.styleIndex = Math.min(i + 1, allowedNumberOfVisibleEditors);
                    iEditor.level = Math.max(i - origin, -1);
                    iEditor.inFront = iEditor.level >= ceiling;
                    i++;
                }
            }

            evts.push(eventsService.on("appState.editors.open", function (name, args) {
                editorCount = editorCount + 1;
                addEditor(args.editor);
            }));

            evts.push(eventsService.on("appState.editors.close", function (name, args) {
                // remove the closed editor
                if (args && args.editor) {
                    editorCount = editorCount - 1;
                    removeEditor(args.editor);
                }
                // close all editors
                if (args && !args.editor && args.editors.length === 0) {
                    editorCount = 0;
                    scope.editors = [];                    
                    // Remove the inert attribute from the #mainwrapper
                    focusLockService.removeInertAttribute();
                }
            }));

            //ensure to unregister from all events!
            scope.$on('$destroy', function () {
                for (var e in evts) {
                    eventsService.unsubscribe(evts[e]);
                }
            });

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editors.html',
            link: link
        };

        return directive;

    }

    // This directive allows for us to run a custom $compile for the view within the repeater which allows
    // us to maintain a $scope hierarchy with the rendered view based on the $scope that initiated the
    // infinite editing. The retain the $scope hiearchy a special $parentScope property is passed in to the model.
    function EditorRepeaterDirective($http, $templateCache, $compile, angularHelper) {
        function link(scope, el) {

            var editor = scope && scope.$parent ? scope.$parent.model : null;
            if (!editor) {
                return;
            }

            var unsubscribe = [];

            //if a custom parent scope is defined then we need to manually compile the view
            if (editor.$parentScope) {
                var element = el.find(".scoped-view");
                $http.get(editor.view, { cache: $templateCache })
                    .then(function (response) {
                        var templateScope = editor.$parentScope.$new();

                        unsubscribe.push(function () {
                            templateScope.$destroy();
                        });

                        // NOTE: the 'model' name here directly affects the naming convention used in infinite editors, this why you access the model
                        // like $scope.model.If this is changed, everything breaks.This is because we are entirely reliant upon ng-include and inheriting $scopes.
                        // by default without a $parentScope used for infinite editing the 'model' propety will be set because the view creates the scopes in 
                        // ng-repeat by ng-repeat="model in editors"
                        templateScope.model = editor;

                        element.show();

                        // if a parentForm is supplied then we can link them but to do that we need to inject a top level form
                        if (editor.$parentForm) {
                            element.html("<ng-form name='infiniteEditorForm'>" + response.data + "</ng-form>");
                        }
                        
                        $compile(element)(templateScope);

                        // if a parentForm is supplied then we can link them
                        if (editor.$parentForm) {
                            editor.$parentForm.$addControl(templateScope.infiniteEditorForm);
                        }
                    });
            }

            scope.$on('$destroy', function () {
                for (var i = 0; i < unsubscribe.length; i++) {
                    unsubscribe[i]();
                }
            });
        }

        var directive = {
            restrict: 'E',
            replace: true,
            transclude: true,
            scope: {
                editors: "="
            },
            template: "<div ng-transclude></div>",            
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbEditors', EditorsDirective);
    angular.module('umbraco.directives').directive('umbEditorRepeater', EditorRepeaterDirective);

})();

----
editor/umbeditornavigation.directive.js
(function () {
    'use strict';

    function EditorNavigationDirective($window, $timeout, eventsService, windowResizeListener) {

        function link(scope) {

            const unsubscribe = [];

            scope.showNavigation = true;
            scope.showMoreButton = false;
            scope.showDropdown = false;
            scope.overflowingItems = 0;
            scope.itemsLimit = Number.isInteger(scope.limit) ? scope.limit : 6;

            scope.moreButton = {
                alias: "more",
                active: false,
                name: "More"
            };

            scope.openNavigationItem = item => {
                
                scope.showDropdown = false;
                runItemAction(item);
                setItemToActive(item);
                if (scope.onSelect) {
                    scope.onSelect({"item": item});
                }
                eventsService.emit("app.tabChange", item);
            };

            scope.openAnchorItem = (item, anchor) => {
                if (scope.onAnchorSelect) {
                    scope.onAnchorSelect({"item": item, "anchor": anchor});
                }
                if (item.active !== true) {
                    scope.openNavigationItem(item);
                }
            };

            scope.toggleDropdown = () => {
                scope.showDropdown = !scope.showDropdown;
            };

            scope.hideDropdown = () => {
                scope.showDropdown = false;
            };

            function onInit() {
                var firstRun = true;
                calculateVisibleItems($window.innerWidth);
;
                unsubscribe.push(scope.$watch("navigation", (newVal, oldVal) => {
                    const newLength = newVal.length;
                    const oldLength = oldVal.length;

                    if (firstRun || newLength !== undefined && newLength !== oldLength) {
                        firstRun = false;
                        scope.showNavigation = newLength > 1;
                        calculateVisibleItems($window.innerWidth);
                    }

                    setMoreButtonErrorState();
                }, true));
            }

            function calculateVisibleItems(windowWidth) {
                // if we don't get a windowWidth stick with the default item limit
                if (!windowWidth) {
                    return;
                }

                // if we haven't set a specific limit prop we base the amount of visible items on the window width
                if (scope.limit === undefined) {
                    scope.itemsLimit = 0;

                    // set visible items based on browser width
                    if (windowWidth > 1500) {
                        scope.itemsLimit = 6;
                    } 
                    else if (windowWidth > 700) {
                        scope.itemsLimit = 4;
                    }
                }

                // toggle more button
                if(scope.navigation.length > scope.itemsLimit) {
                    scope.showMoreButton = true;
                    scope.overflowingItems = scope.itemsLimit - scope.navigation.length;
                } else {
                    scope.showMoreButton = false;
                    scope.overflowingItems = 0;
                }

                scope.moreButton.name = scope.itemsLimit === 0 ? "Menu" : "More";
                setMoreButtonActiveState();
                setMoreButtonErrorState();
            }

            function runItemAction(selectedItem) {
                if (selectedItem.action) {
                    selectedItem.action(selectedItem);
                }
            }

            function setItemToActive(selectedItem) {
                if (selectedItem.view) {
                    
                    // deselect all items
                    Utilities.forEach(scope.navigation, item => {
                        item.active = false;
                    });
                    
                    // set clicked item to active
                    selectedItem.active = true;
                    setMoreButtonActiveState();
                    setMoreButtonErrorState();
                }
            }

            function setMoreButtonActiveState() {
                // set active state on more button if any of the overflown items is active
                scope.moreButton.active = scope.navigation.findIndex(item => item.active) + 1 > scope.itemsLimit;
            };

            function setMoreButtonErrorState() {
                if (scope.overflowingItems === 0) {
                    return;
                }

                const overflow = scope.navigation.slice(scope.itemsLimit, scope.navigation.length);
                const active = scope.navigation.find(item => item.active)
                // set error state on more button if any of the overflown items has an error. We use it show the error badge and color the item
                scope.moreButton.hasError = overflow.filter(item => item.hasError).length > 0;
                // set special active/error state on button if the current selected item is has an error
                // we don't want to show the error badge in this case so we need a special state for that
                scope.moreButton.activeHasError = active.hasError;
            };

            var resizeCallback = size => {
                if (size && size.width) {
                    calculateVisibleItems(size.width);
                }
            };

            windowResizeListener.register(resizeCallback);

            unsubscribe.push(scope.$watch('limit', (newVal) => {
                scope.itemsLimit = newVal;
                calculateVisibleItems($window.innerWidth);
            }));

            scope.$on('$destroy', function () {
                windowResizeListener.unregister(resizeCallback);

                for (var u in unsubscribe) {
                    unsubscribe[u]();
                }
            });

            onInit();
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editor-navigation.html',
            scope: {
                navigation: "=",
                onSelect: "&",
                onAnchorSelect: "&",
                limit: "<"
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives.html').directive('umbEditorNavigation', EditorNavigationDirective);

})();

----
editor/umbeditortabbar.directive.js
(function () {
  'use strict';

  /**
   * A component to render the editor tab bar
   */
  
  function umbEditorTabBarController() {

    const vm = this;

  }

  const umbEditorTabBarComponent = {
    templateUrl: 'views/components/editor/umb-editor-tab-bar.html',
    controllerAs: 'vm',
    transclude: true,
    controller: umbEditorTabBarController
  };

  angular.module('umbraco.directives').component('umbEditorTabBar', umbEditorTabBarComponent);
})();

----
editor/umbeditorview.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorView
@restrict E
@scope

@description
Use this directive to construct the main editor window.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-header
                    name="vm.content.name"
                    hide-alias="true"
                    hide-description="true"
                    hide-icon="true">
                </umb-editor-header>

                <umb-editor-container>
                    // main content here
                </umb-editor-container>

                <umb-editor-footer>
                    // footer content here
                </umb-editor-footer>

            </umb-editor-view>

        </form>

    </div>
</pre>
<h3>Controller example</h3>
<pre>
    (function () {

        "use strict";

        function Controller() {

            var vm = this;

        }

        angular.module("umbraco").controller("MySection.Controller", Controller);
    })();
</pre>


<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorHeader umbEditorHeader}</li>
    <li>{@link umbraco.directives.directive:umbEditorContainer umbEditorContainer}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooter umbEditorFooter}</li>
</ul>

@param {boolean} footer Whether the directive should make place for a {@link umbraco.directives.directive:umbEditorFooter umbEditorFooter} at the bottom (`true` by default).
**/

(function() {
   'use strict';

   function EditorViewDirective() {

       function link(scope, el, attr) {

           if(attr.footer) {
               scope.footer = attr.footer;
           }

       }

      var directive = {
         transclude: true,
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/editor/umb-editor-view.html',
         link: link
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEditorView', EditorViewDirective);

})();

----
editor/umbeditorfootercontentright.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorFooterContentRight
@restrict E

@description
Use this directive to align content right inside the main editor footer.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-footer>

                    <umb-editor-footer-content-left>
                        // align content left
                    </umb-editor-footer-content-left>

                    <umb-editor-footer-content-right>
                        // align content right
                    </umb-editor-footer-content-right>

                </umb-editor-footer>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorView umbEditorView}</li>
    <li>{@link umbraco.directives.directive:umbEditorHeader umbEditorHeader}</li>
    <li>{@link umbraco.directives.directive:umbEditorContainer umbEditorContainer}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooter umbEditorFooter}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooterContentLeft umbEditorFooterContentLeft}</li>
</ul>
**/

(function() {
   'use strict';

   function EditorFooterContentRightDirective() {

      var directive = {
         transclude: true,
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/editor/umb-editor-footer-content-right.html'
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEditorFooterContentRight', EditorFooterContentRightDirective);

})();

----
editor/umbbreadcrumbs.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbBreadcrumbs
@restrict E
@scope

@description
Use this directive to generate a list of breadcrumbs.

<h3>Markup example</h3>
<pre>
    <div ng-controller="My.Controller as vm">
        <umb-breadcrumbs
            ng-if="vm.ancestors && vm.ancestors.length > 0"
            ancestors="vm.ancestors"
            entity-type="content"
            on-open="clickBreadcrumb(ancestor)">
        </umb-breadcrumbs>
    </div>
</pre>

<h3>Controller example</h3>
<pre>
    (function () {
        "use strict";

        function Controller(myService) {

            var vm = this;
            vm.ancestors = [];

            myService.getAncestors().then(function(ancestors){
                vm.ancestors = ancestors;
            });

            $scope.clickBreadcrumb = function(ancestor) {
                // manipulate breadcrumb display
            }
        }

        angular.module("umbraco").controller("My.Controller", Controller);
    })();
</pre>

@param {array} ancestors Array of ancestors
@param {string} entityType The content entity type (member, media, content).
@param {callback=} onOpen Function callback when an ancestor is clicked. This will override the default link behaviour.
**/

(function () {
    'use strict';

    function BreadcrumbsDirective($location, navigationService) {

        function link(scope, el, attr, ctrl) {

            scope.allowOnOpen = false;

            scope.open = function(ancestor) {
                if(scope.onOpen && scope.allowOnOpen) {
                    scope.onOpen({'ancestor': ancestor});
                }
            };

            scope.openPath = function (ancestor, event) {
                // targeting a new tab/window?
                if (event.ctrlKey || 
                    event.shiftKey ||
                    event.metaKey || // apple
                    (event.button && event.button === 1) // middle click, >IE9 + everyone else
                ) {
                    // yes, let the link open itself
                    return;
                }
                event.stopPropagation();
                event.preventDefault();

                var path = scope.pathTo(ancestor);
                $location.path(path);
                navigationService.clearSearch(["cculture", "csegment"]);
            }

            scope.pathTo = function (ancestor) {
                return "/" + scope.entityType + "/" + scope.entityType + "/edit/" + ancestor.id;
            }

            function onInit() {
                if ("onOpen" in attr) {
                    scope.allowOnOpen = true;
                }
            }
            
            onInit();

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-breadcrumbs.html',
            scope: {
                ancestors: "=",
                forNewEntity: "=",
                entityType: "@",
                onOpen: "&"
            },
            link: link
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbBreadcrumbs', BreadcrumbsDirective);

})();

----
editor/_readme.md
#Editor

Directives only used to construct the main editor window. Includes header, footer, menu and navigation.

----
editor/umbeditorcontentheader.directive.js
(function () {
    'use strict';

    function EditorContentHeader(serverValidationManager, localizationService, editorState, contentEditingHelper, contentTypeHelper) {
        function link(scope) {

            var unsubscribe = [];

            if (!scope.serverValidationNameField) {
                scope.serverValidationNameField = "Name";
            }
            if (!scope.serverValidationAliasField) {
                scope.serverValidationAliasField = "Alias";
            }

            scope.isNew = scope.editor.content.state == "NotCreated";

            localizationService.localizeMany(
                [
                    scope.isNew ? "placeholders_a11yCreateItem" : "placeholders_a11yEdit",
                    "placeholders_a11yName",
                    scope.isNew ? "general_new" : "general_edit"
                ]
            ).then(function (data) {
                scope.a11yMessage = data[0];
                scope.a11yName = data[1];
                var title = data[2] + ": ";
                if (!scope.isNew) {
                    scope.a11yMessage += " " + scope.editor.content.name;
                    title += scope.editor.content.name;
                } else {
                    var name = editorState.current.contentTypeName;
                    scope.a11yMessage += " " + name;
                    scope.a11yName = name + " " + scope.a11yName;
                    title += name;
                }

                scope.$emit("$changeTitle", title);
            });
            scope.vm = {};
            scope.vm.hasVariants = false;
            scope.vm.hasSubVariants = false;
            scope.vm.hasCulture = false;
            scope.vm.hasSegments = false;
            scope.vm.dropdownOpen = false;
            scope.vm.variantsWithError = [];
            scope.vm.defaultVariant = null;
            scope.vm.errorsOnOtherVariants = false;// indicating wether to show that other variants, than the current, have errors.

            function updateVaraintErrors() {
                scope.content.variants.forEach(function (variant) {
                    variant.hasError = scope.variantHasError(variant);

                });
                checkErrorsOnOtherVariants();
            }

            function checkErrorsOnOtherVariants() {
                var check = false;
                scope.content.variants.forEach(function (variant) {
                    if (variant.active !== true && variant.hasError) {
                        check = true;
                    }
                });
                scope.vm.errorsOnOtherVariants = check;
            }

            function onVariantValidation(valid, errors, allErrors, culture, segment) {

                // only want to react to property errors:
                if (errors.findIndex(error => { return error.propertyAlias !== null; }) === -1) {
                    // we dont have any errors for properties, meaning we will back out.
                    return;
                }

                // If error coming back is invariant, we will assign the error to the default variant by picking the defaultVariant language.
                if (culture === "invariant" && scope.vm.defaultVariant) {
                    culture = scope.vm.defaultVariant.language.culture;
                }

                var index = scope.vm.variantsWithError.findIndex((item) => item.culture === culture && item.segment === segment)
                if (valid === true) {
                    if (index !== -1) {
                        scope.vm.variantsWithError.splice(index, 1);
                    }
                } else {
                    if (index === -1) {
                        scope.vm.variantsWithError.push({ "culture": culture, "segment": segment });
                    }
                }
                scope.$evalAsync(updateVaraintErrors);
            }

            function onInit() {
                // find default + check if we have variants.
                scope.content.variants.forEach(function (variant) {
                    if (variant.language !== null && variant.language.isDefault) {
                        scope.vm.defaultVariant = variant;
                    }
                    if (variant.language !== null) {
                        scope.vm.hasCulture = true;
                    }
                    if (variant.segment !== null) {
                        scope.vm.hasSegments = true;
                    }
                });

                scope.vm.hasVariants = scope.content.variants.length > 1 && (scope.vm.hasCulture || scope.vm.hasSegments);
                scope.vm.hasSubVariants = scope.content.variants.length > 1 &&(scope.vm.hasCulture && scope.vm.hasSegments);

                updateVaraintErrors();

                scope.vm.variantMenu = [];
                if (scope.vm.hasCulture) {
                    scope.content.variants.forEach((v) => {
                        if (v.language !== null && v.segment === null) {
                            const subVariants = scope.content.variants.filter((subVariant) => subVariant.language.culture === v.language.culture && subVariant.segment !== null).sort(contentEditingHelper.sortVariants);

                            var variantMenuEntry = {
                                key: String.CreateGuid(),
                                open: v.language && v.language.culture === scope.editor.culture,
                                variant: v,
                                subVariants
                            };
                            scope.vm.variantMenu.push(variantMenuEntry);
                        }
                    });
                } else {
                    scope.content.variants.forEach((v) => {
                        scope.vm.variantMenu.push({
                            key: String.CreateGuid(),
                            variant: v
                        });
                    });
                }

                scope.editor.variantApps.forEach((app) => {
                    // only render quick links on the content app if there are no tabs
                    if (app.alias === "umbContent") {
                        const hasTabs = scope.editor.content.tabs && scope.editor.content.tabs.filter(group => group.type === contentTypeHelper.TYPE_TAB).length > 0;
                        app.anchors = hasTabs ? [] : scope.editor.content.tabs;
                    }
                });

                scope.content.variants.forEach(function (variant) {

                    // if we are looking for the variant with default language then we also want to check for invariant variant.
                    if (variant.language && scope.vm.defaultVariant && variant.language.culture === scope.vm.defaultVariant.language.culture && variant.segment === null) {
                        unsubscribe.push(serverValidationManager.subscribe(null, "invariant", null, onVariantValidation, null));
                    }
                    unsubscribe.push(serverValidationManager.subscribe(null, variant.language !== null ? variant.language.culture : null, null, onVariantValidation, variant.segment));
                });
                
                scope.vm.variantMenu.sort(sortVariantsMenu);
            }

            function sortVariantsMenu (a, b) {
                return contentEditingHelper.sortVariants(a.variant, b.variant);
            }

            scope.goBack = function () {
                if (scope.onBack) {
                    scope.onBack();
                }
            };

            scope.selectVariant = function (event, variant) {

                if (scope.onSelectVariant) {
                    scope.vm.dropdownOpen = false;
                    scope.onSelectVariant({ "variant": variant });
                }
            };

            scope.selectNavigationItem = function (item) {
                if (scope.onSelectNavigationItem) {
                    scope.onSelectNavigationItem({ "item": item });
                }
            }

            scope.selectAnchorItem = function (item, anchor) {
                if (scope.onSelectAnchorItem) {
                    scope.onSelectAnchorItem({ "item": item, "anchor": anchor });
                }
            }

            scope.closeSplitView = function () {
                if (scope.onCloseSplitView) {
                    scope.onCloseSplitView();
                }
            };

            scope.openInSplitView = function (event, variant) {
                if (scope.onOpenInSplitView) {
                    scope.vm.dropdownOpen = false;
                    scope.onOpenInSplitView({ "variant": variant });
                }
            };

            /**
             * Check whether a variant has a error, used to display errors in variant switcher.
             * @param {any} culture
             */
            scope.variantHasError = function (variant) {
                if (scope.vm.variantsWithError.find((item) => (!variant.language || item.culture === variant.language.culture) && item.segment === variant.segment) !== undefined) {
                    return true;
                }
                return false;
            }

            scope.toggleDropdown = function () {
                scope.vm.dropdownOpen = !scope.vm.dropdownOpen;
                
                if (scope.vm.dropdownOpen) {
                    scope.vm.variantMenu.sort(sortVariantsMenu);
                }
            };

            unsubscribe.push(scope.$watch('splitViewOpen', (newVal) => {
                scope.vm.navigationItemLimit = newVal === true ? 0 : undefined;
            }));

            onInit();

            scope.$on('$destroy', function () {
                for (var u in unsubscribe) {
                    unsubscribe[u]();
                }
            });
        }


        var directive = {
            transclude: true,
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editor-content-header.html',
            scope: {
                name: "=",
                nameDisabled: "<?",
                nameReadonly: "<?",
                menu: "=",
                hideActionsMenu: "<?",
                disableActionsMenu: "<?",
                content: "=",
                editor: "=",
                hideChangeVariant: "<?",
                onSelectNavigationItem: "&?",
                onSelectAnchorItem: "&?",
                showBackButton: "<?",
                onBack: "&?",
                splitViewOpen: "=?",
                onOpenInSplitView: "&?",
                onCloseSplitView: "&?",
                onSelectVariant: "&?",
                serverValidationNameField: "@?",
                serverValidationAliasField: "@?"
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbEditorContentHeader', EditorContentHeader);

})();

----
editor/umbeditorsubviews.directive.js
(function () {
    'use strict';

    /**
     * A directive that just repeats over a list of defined views which are all able to access the same common model.
     * This is only used in simple cases, whereas media and content use umbEditorSubView (singular) which allows
     * passing in a view model specific to the view and the entire content model for support if required.
     **/
    function EditorSubViewsDirective() {

        function link(scope, el, attr, ctrl) {

        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editor-sub-views.html',
            scope: {
                subViews: "=",
                model: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbEditorSubViews', EditorSubViewsDirective);

})();

----
editor/umbeditorsubview.js
(function () {
    'use strict';

    /**
     * A directive that renders a defined view with a view model and a the whole content model.
     **/
    function EditorSubViewDirective() {

        function link(scope) {
            //The model can contain: view, viewModel, name, alias, icon

            if (!scope.model.view) {
                throw "No view defined for the content app";
            }
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editor-sub-view.html',
            scope: {
                model: "=",
                variantContent: "=?",
                content: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbEditorSubView', EditorSubViewDirective);

})();

----
editor/umbeditorcontainer.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorContainer
@restrict E

@description
Use this directive to construct a main content area inside the main editor window.

<h3>Markup example</h3>
<pre>
    <div ng-controller="Umbraco.Controller as vm">

        <umb-editor-view>

            <umb-editor-header
                // header configuration>
            </umb-editor-header>

            <umb-editor-container>
                // main content here
            </umb-editor-container>

            <umb-editor-footer>
                // footer content here
            </umb-editor-footer>

        </umb-editor-view>

    </div>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorView umbEditorView}</li>
    <li>{@link umbraco.directives.directive:umbEditorHeader umbEditorHeader}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooter umbEditorFooter}</li>
</ul>
**/

(function () {
    'use strict';

    function EditorContainerDirective(overlayHelper) {

        function link(scope, el, attr, ctrl) {

            scope.numberOfOverlays = 0;

            // TODO: this shouldn't be a watch, this should be based on an event handler
            scope.$watch(function () {
                return overlayHelper.getNumberOfOverlays();
            }, function (newValue) {
                scope.numberOfOverlays = newValue;
            });

        }

        var directive = {
            transclude: true,
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editor-container.html',
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbEditorContainer', EditorContainerDirective);

})();

----
editor/umbeditorheader.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorHeader
@restrict E
@scope

@description
Use this directive to construct a header inside the main editor window.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-header
                    name="vm.content.name"
                    hide-alias="true"
                    hide-description="true"
                    hide-icon="true">
                </umb-editor-header>

                <umb-editor-container>
                    // main content here
                </umb-editor-container>

                <umb-editor-footer>
                    // footer content here
                </umb-editor-footer>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Markup example - with tabs</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" val-form-manager novalidate>

            <umb-editor-view umb-tabs>

                <umb-editor-header
                    name="vm.content.name"
                    tabs="vm.content.tabs"
                    hide-alias="true"
                    hide-description="true"
                    hide-icon="true">
                </umb-editor-header>

                <umb-editor-container>
                    <umb-tabs-content class="form-horizontal" view="true">
                        <umb-tab id="tab{{tab.id}}" ng-repeat="tab in vm.content.tabs" rel="{{tab.id}}">

                            <div ng-show="tab.alias==='tab1'">
                                // tab 1 content
                            </div>

                            <div ng-show="tab.alias==='tab2'">
                                // tab 2 content
                            </div>

                        </umb-tab>
                    </umb-tabs-content>
                </umb-editor-container>

                <umb-editor-footer>
                    // footer content here
                </umb-editor-footer>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Controller example - with tabs</h3>
<pre>
    (function () {
        "use strict";

        function Controller() {

            var vm = this;
            vm.content = {
                name: "",
                tabs: [
                    {
                        id: 1,
                        label: "Tab 1",
                        alias: "tab1",
                        active: true
                    },
                    {
                        id: 2,
                        label: "Tab 2",
                        alias: "tab2",
                        active: false
                    }
                ]
            };

        }

        angular.module("umbraco").controller("MySection.Controller", Controller);
    })();
</pre>

<h3>Markup example - with sub views</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" val-form-manager novalidate>

            <umb-editor-view>

                <umb-editor-header
                    name="vm.content.name"
                    navigation="vm.content.navigation"
                    hide-alias="true"
                    hide-description="true"
                    hide-icon="true">
                </umb-editor-header>

                <umb-editor-container>

                    <umb-editor-sub-views
                        sub-views="vm.content.navigation"
                        model="vm.content">
                    </umb-editor-sub-views>

                </umb-editor-container>

                <umb-editor-footer>
                    // footer content here
                </umb-editor-footer>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Controller example - with sub views</h3>
<pre>
    (function () {

        "use strict";

        function Controller() {

            var vm = this;
            vm.content = {
                name: "",
                navigation: [
                    {
                        "alias": "section1",
                        "name": "Section 1",
                        "icon": "icon-document-dashed-line",
                        "view": "/App_Plugins/path/to/html.html",
                        "active": true
                    },
                    {
                        "alias": "section2",
                        "name": "Section 2",
                        "icon": "icon-list",
                        "view": "/App_Plugins/path/to/html.html",
                    }
                ]
            };

        }

        angular.module("umbraco").controller("MySection.Controller", Controller);
    })();
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorView umbEditorView}</li>
    <li>{@link umbraco.directives.directive:umbEditorContainer umbEditorContainer}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooter umbEditorFooter}</li>
</ul>

@param {string} name The content name.
@param {boolean=} nameRequired Require name to be defined. (True by default)
@param {array=} tabs Array of tabs. See example above.
@param {array=} navigation Array of sub views. See example above.
@param {boolean=} nameLocked Set to <code>true</code> to lock the name.
@param {number=} nameMaxLength Maximum length of the name.
@param {object=} menu Add a context menu to the editor.
@param {string=} icon Show and edit the content icon. Opens an overlay to change the icon.
@param {boolean=} hideIcon Set to <code>true</code> to hide icon.
@param {string=} alias show and edit the content alias.
@param {boolean=} aliasLocked Set to <code>true</code> to lock the alias.
@param {boolean=} hideAlias Set to <code>true</code> to hide alias.
@param {string=} description Add a description to the content.
@param {boolean=} descriptionLocked Set to <code>true</code> to lock the description.
@param {boolean=} hideDescription Set to <code>true</code> to hide description.
@param {boolean=} setpagetitle If true the page title will be set to reflect the type of data the header is working with
@param {string=} editorfor The localization to use to aid accessibility on the edit and create screen
@param {boolean=} loading Whether a loading indicator should be shown as part of the header.
**/

(function () {
    'use strict';

    function EditorHeaderDirective(editorService, localizationService, editorState, $rootScope) {

        function link(scope) {

            scope.vm = {};
            scope.vm.dropdownOpen = false;
            scope.vm.currentVariant = "";
            scope.initializing = true;
            scope.accessibility = {};
            scope.accessibility.a11yMessage = "";
            scope.accessibility.a11yName = "";
            scope.accessibility.a11yMessageVisible = false;
            scope.accessibility.a11yNameVisible = false;

            // trim the name if required
            scope.nameMaxLength = scope.nameMaxLength || 255;
            if (scope.name && scope.name.length > scope.nameMaxLength) {
                scope.name = scope.name.substring(0, scope.nameMaxLength - 1) + '…';
            }

            // need to call localizationService service outside of routine to set a11y due to promise requirements
            if (editorState.current) {
                //to do make work for user create/edit
                // to do make it work for user group create/ edit
                // to make it work for language edit/create
                setAccessibilityForEditorState();
                scope.initializing = false;
            } else if (scope.name) {
                setAccessibilityForName();
                scope.initializing = false;
            } else {
                scope.initializing = false;
            }
            scope.goBack = function () {
                if (scope.onBack) {
                    scope.onBack();
                }
            };

            scope.selectNavigationItem = function(item) {
                if(scope.onSelectNavigationItem) {
                    scope.onSelectNavigationItem({"item": item});
                }
            }

            scope.openIconPicker = function () {
                var iconPicker = {
                    icon: scope.icon.split(' ')[0],
                    color: scope.icon.split(' ')[1],
                    size: "medium",
                    submit: function (model) {
                        if (model.icon) {
                            if (model.color) {
                                scope.icon = model.icon + " " + model.color;
                            } else {
                                scope.icon = model.icon;
                            }
                            // set the icon form to dirty
                            scope.iconForm.$setDirty();
                        }
                        editorService.close();
                    },
                    close: function () {
                        editorService.close();
                    }
                };
                editorService.iconPicker(iconPicker);
            };

            function setAccessibilityForName() {
                var setTitle = false;
                if (scope.setpagetitle !== undefined) {
                    setTitle = scope.setpagetitle;
                }
                if (setTitle) {
                    setAccessibilityHeaderDirective(false, scope.editorfor, scope.nameLocked, scope.name, "", true);
                }
            }
            function setAccessibilityForEditorState() {
                var isNew = editorState.current.id === 0 ||
                    editorState.current.id === "0" ||
                    editorState.current.id === -1 ||
                    editorState.current.id === 0 ||
                    editorState.current.id === "-1";

                var contentTypeName = "";
                if (editorState.current.contentTypeName) {
                    contentTypeName = editorState.current.contentTypeName;
                }

                var setTitle = false;
                if (scope.setpagetitle !== undefined) {
                    setTitle = scope.setpagetitle;
                }
                setAccessibilityHeaderDirective(isNew, scope.editorfor, scope.nameLocked, scope.name, contentTypeName, setTitle);
            }

            function setAccessibilityHeaderDirective(isNew, editorFor, nameLocked, entityName, contentTypeName, setTitle) {

                var localizeVars = [
                    isNew ? "visuallyHiddenTexts_createItem" : "visuallyHiddenTexts_edit",
                    "visuallyHiddenTexts_name",
                    isNew ? "general_new" : "general_edit"
                ];

                if (editorFor) {
                    localizeVars.push(editorFor);
                }
                localizationService.localizeMany(localizeVars).then(function(data) {
                    if (nameLocked) {
                        scope.accessibility.a11yName = entityName;
                        if (setTitle) {
                            SetPageTitle(entityName);
                        }
                    } else {

                        scope.accessibility.a11yMessage = data[0];
                        scope.accessibility.a11yName = data[1];
                        var title = data[2] + ":";
                        if (!isNew) {
                            scope.accessibility.a11yMessage += " " + entityName;
                            title += " " + entityName;
                        } else {
                            var name = "";
                            if (contentTypeName) {
                                name = editorState.current.contentTypeName;
                            } else if (editorFor) {
                                name = data[3];
                            }
                            if (name !== "") {
                                scope.accessibility.a11yMessage += " " + name;
                                scope.accessibility.a11yName = name + " " + scope.accessibility.a11yName;
                                title += " " + name;
                            }
                        }
                        if (setTitle && title !== data[2] + ":") {
                            SetPageTitle(title);
                        }

                    }

                    scope.accessibility.a11yMessageVisible = !isNullOrWhitespace(scope.accessibility.a11yMessage);
                    scope.accessibility.a11yNameVisible = !isNullOrWhitespace(scope.accessibility.a11yName);

                });
            }

            function isNullOrWhitespace(str) {
               return str === null || str === undefined || str.trim() === '';
            }

            function SetPageTitle(title) {
                scope.$emit("$changeTitle", title);
            }

            var unbindEventHandler = $rootScope.$on('$setAccessibleHeader', function (event, isNew, editorFor, nameLocked, name, contentTypeName, setTitle) {
                setAccessibilityHeaderDirective(isNew, editorFor, nameLocked, name, contentTypeName, setTitle);
            });
            scope.$on('$destroy', function () {
                unbindEventHandler();
            });
        }



        var directive = {
            transclude: true,
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editor-header.html',
            scope: {
                name: "=",
                nameLocked: "=",
                nameRequired: "=?",
                nameMaxLength: "=?",
                menu: "=",
                hideActionsMenu: "<?",
                icon: "=",
                hideIcon: "@",
                alias: "=",
                aliasLocked: "<",
                hideAlias: "=",
                description: "=",
                hideDescription: "@",
                descriptionLocked: "@",
                navigation: "=",
                onSelectNavigationItem: "&?",
                key: "=",
                onBack: "&?",
                showBackButton: "<?",
                editorfor: "=",
                setpagetitle: "=",
                loading: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbEditorHeader', EditorHeaderDirective);

})();

----
editor/umbeditornavigationitem.directive.js
(function () {
    'use strict';
    
    function UmbEditorNavigationItemController($scope, $element, $attrs) {
        
        var vm = this;

        vm.close = function () {
            vm.expanded = false;
        };

        vm.clicked = function () {
            vm.expanded = vm.item.anchors && vm.item.anchors.length > 1 && !vm.expanded;
            vm.onOpen({item:vm.item});
        };
        
        vm.anchorClicked = function(anchor, $event) {
            vm.onOpenAnchor({item:vm.item, anchor:anchor});
            $event.stopPropagation();
            $event.preventDefault();
        };
        
        // needed to make sure that we update what anchors are active.
        vm.mouseOver = function() {
            $scope.$digest();
        }
        
        var componentNode = $element[0];
        
        componentNode.classList.add('umb-sub-views-nav-item');
        componentNode.addEventListener('mouseover', vm.mouseOver);

        //ensure to unregister from all dom-events
        $scope.$on('$destroy', function () {
            componentNode.removeEventListener("mouseover", vm.mouseOver);
        });
        
    }
    
    angular
        .module('umbraco.directives.html')
        .component('umbEditorNavigationItem', {
            templateUrl: 'views/components/editor/umb-editor-navigation-item.html',
            controller: UmbEditorNavigationItemController,
            controllerAs: 'vm',
            bindings: {
                item: '=',
                onOpen: '&',
                onOpenAnchor: '&',
                hotkey: '<'
            }
        });

})();

----
editor/umbeditor.directive.js
(function () {
    'use strict';

    function EditorDirective() {

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/editor/umb-editor.html',
            scope: {
                model: "="
            }
        };

        return directive;

    }

    angular.module('umbraco.directives').directive('umbEditor', EditorDirective);

})();

----
editor/umbeditorfootercontentleft.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorFooterContentLeft
@restrict E

@description
Use this directive to align content left inside the main editor footer.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-footer>

                    <umb-editor-footer-content-left>
                        // align content left
                    </umb-editor-footer-content-left>

                    <umb-editor-footer-content-right>
                        // align content right
                    </umb-editor-footer-content-right>

                </umb-editor-footer>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorView umbEditorView}</li>
    <li>{@link umbraco.directives.directive:umbEditorHeader umbEditorHeader}</li>
    <li>{@link umbraco.directives.directive:umbEditorContainer umbEditorContainer}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooter umbEditorFooter}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooterContentRight umbEditorFooterContentRight}</li>
</ul>
**/

(function() {
   'use strict';

   function EditorFooterContentLeftDirective() {

      var directive = {
         transclude: true,
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/editor/umb-editor-footer-content-left.html'
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEditorFooterContentLeft', EditorFooterContentLeftDirective);

})();

----
editor/umbeditorfooter.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorFooter
@restrict E

@description
Use this directive to construct a footer inside the main editor window.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-header
                    // header configuration>
                </umb-editor-header>

                <umb-editor-container>
                    // main content here
                </umb-editor-container>

                <umb-editor-footer>
                    // footer content here
                </umb-editor-footer>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorView umbEditorView}</li>
    <li>{@link umbraco.directives.directive:umbEditorHeader umbEditorHeader}</li>
    <li>{@link umbraco.directives.directive:umbEditorContainer umbEditorContainer}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooterContentLeft umbEditorFooterContentLeft}</li>
    <li>{@link umbraco.directives.directive:umbEditorFooterContentRight umbEditorFooterContentRight}</li>
</ul>
**/

(function() {
   'use strict';

   function EditorFooterDirective() {

      var directive = {
         transclude: true,
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/editor/umb-editor-footer.html'
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEditorFooter', EditorFooterDirective);

})();

----
editor/subheader/umbeditorsubheadercontentright.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorSubHeaderContentRight
@restrict E

@description
Use this directive to rigt align content in a sub header in the main editor window.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-container>

                    <umb-editor-sub-header>

                        <umb-editor-sub-header-content-left>
                            // left content here
                        </umb-editor-sub-header-content-left>

                        <umb-editor-sub-header-content-right>
                            // right content here
                        </umb-editor-sub-header-content-right>

                    </umb-editor-sub-header>

                </umb-editor-container>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorSubHeader umbEditorSubHeader}</li>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderContentLeft umbEditorSubHeaderContentLeft}</li>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderSection umbEditorSubHeaderSection}</li>
</ul>
**/

(function() {
   'use strict';

   function EditorSubHeaderContentRightDirective() {

      var directive = {
         transclude: true,
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/editor/subheader/umb-editor-sub-header-content-right.html'
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEditorSubHeaderContentRight', EditorSubHeaderContentRightDirective);

})();

----
editor/subheader/umbeditorsubheader.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorSubHeader
@restrict E

@description
Use this directive to construct a sub header in the main editor window.
The sub header is sticky and will follow along down the page when scrolling.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-container>

                    <umb-editor-sub-header>
                        // sub header content here
                    </umb-editor-sub-header>

                </umb-editor-container>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderContentLeft umbEditorSubHeaderContentLeft}</li>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderContentRight umbEditorSubHeaderContentRight}</li>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderSection umbEditorSubHeaderSection}</li>
</ul>
**/

(function() {
   'use strict';

   function EditorSubHeaderDirective() {

      var directive = {
         transclude: true,
         restrict: 'E',
         replace: true,
         scope: {
             "appearance": "@?"
         },
         templateUrl: 'views/components/editor/subheader/umb-editor-sub-header.html'
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEditorSubHeader', EditorSubHeaderDirective);

})();

----
editor/subheader/umbeditorsubheadercontentleft.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorSubHeaderContentLeft
@restrict E

@description
Use this directive to left align content in a sub header in the main editor window.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-container>

                    <umb-editor-sub-header>

                        <umb-editor-sub-header-content-left>
                            // left content here
                        </umb-editor-sub-header-content-left>

                        <umb-editor-sub-header-content-right>
                            // right content here
                        </umb-editor-sub-header-content-right>

                    </umb-editor-sub-header>

                </umb-editor-container>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorSubHeader umbEditorSubHeader}</li>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderContentRight umbEditorSubHeaderContentRight}</li>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderSection umbEditorSubHeaderSection}</li>
</ul>
**/

(function() {
   'use strict';

   function EditorSubHeaderContentLeftDirective() {

      var directive = {
         transclude: true,
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/editor/subheader/umb-editor-sub-header-content-left.html'
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEditorSubHeaderContentLeft', EditorSubHeaderContentLeftDirective);

})();

----
editor/subheader/umbeditorsubheadersection.directive.js
/**
@ngdoc directive
@name umbraco.directives.directive:umbEditorSubHeaderSection
@restrict E

@description
Use this directive to create sections, divided by borders, in a sub header in the main editor window.

<h3>Markup example</h3>
<pre>
    <div ng-controller="MySection.Controller as vm">

        <form name="mySectionForm" novalidate>

            <umb-editor-view>

                <umb-editor-container>

                    <umb-editor-sub-header>

                        <umb-editor-sub-header-content-right>

                            <umb-editor-sub-header-section>
                                // section content here
                            </umb-editor-sub-header-section>

                            <umb-editor-sub-header-section>
                                // section content here
                            </umb-editor-sub-header-section>

                            <umb-editor-sub-header-section>
                                // section content here
                            </umb-editor-sub-header-section>

                        </umb-editor-sub-header-content-right>

                    </umb-editor-sub-header>

                </umb-editor-container>

            </umb-editor-view>

        </form>

    </div>
</pre>

<h3>Use in combination with</h3>
<ul>
    <li>{@link umbraco.directives.directive:umbEditorSubHeader umbEditorSubHeader}</li>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderContentLeft umbEditorSubHeaderContentLeft}</li>
    <li>{@link umbraco.directives.directive:umbEditorSubHeaderContentRight umbEditorSubHeaderContentRight}</li>
</ul>
**/

(function() {
   'use strict';

   function EditorSubHeaderSectionDirective() {

      var directive = {
         transclude: true,
         restrict: 'E',
         replace: true,
         templateUrl: 'views/components/editor/subheader/umb-editor-sub-header-section.html'
      };

      return directive;
   }

   angular.module('umbraco.directives').directive('umbEditorSubHeaderSection', EditorSubHeaderSectionDirective);

})();

----
localization/localize.directive.js
angular.module('umbraco.directives')
/**
* @ngdoc directive
* @name umbraco.directives.directive:localize
* @restrict EA
* @function
* @description
* <div>
*   Used to localize text in HTMl-elements or attributes using translation keys. Translations are stored in umbraco/config/lang/ or the /lang-folder of a package i App_Plugins.
* </div>
* <div>
*   <strong>Component/Element</strong><br />
    *   Localize a specific token to put into the HTML as an item
* </div>
* <div>
*   <strong>Attribute</strong><br />
    *   Add a HTML attribute to an element containing the HTML attribute name you wish to localise
    *   Using the format of '@section_key' or 'section_key'
* </div>
* ##Basic Usage
* <pre>
* <!-- Component -->
* <localize key="general_close">Close</localize>
* <localize key="section_key">Fallback value</localize>
*
* <!-- Attribute -->
* <input type="text" localize="placeholder" placeholder="@placeholders_entername" />
* <input type="text" localize="placeholder,title" title="@section_key" placeholder="@placeholders_entername" />
* <div localize="title" title="@section_key"></div>
* </pre>
* ##Use with tokens
* Also supports tokens inside the translation key, example of a translation
* <pre>
*   <key alias="characters_left">You have %0% characters left of %1%</key>
* </pre>
* Can be used like this:
* <pre>
*   <localize key="general_characters_left" tokens="[5,100]" watch-tokens="true">You have %0% characters left of %1%</localize>
*   <!-- Renders: You have 5 characters left of 100 -->
* </pre>
* Where the "tokens"-attribute is an array of tokens for the translations, "watch-tokens" will make the component watch the expression passed.
**/
.directive('localize', function ($log, localizationService) {
    return {
        restrict: 'E',
        scope: {
            key: '@',
            tokens: '=',
            watchTokens: '@'
        },
        replace: true,
        link: function (scope, element, attrs) {
            var key = scope.key;
                scope.text = '';

                // A render function to be able to update tokens as values update.
            function render() {
                element.html(localizationService.tokenReplace(scope.text, scope.tokens || null));
            }

            // As per component definition in ngdoc above, the initial inner html of the element is to be used as fallback value
                var fallbackValue = element.html();
                localizationService.localize(key, null, fallbackValue).then(function (value) {
                scope.text = value;
                render();
            });

            if (scope.watchTokens === 'true') {
                scope.$watch("tokens", render, true);
            }
        }
    };
})
.directive('localize', function ($log, localizationService) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
                //Support one or more attribute properties to update
            var keys = attrs.localize.split(',');

            Utilities.forEach(keys, (value, key) => {
                var attr = element.attr(value);
                if (attr) {
                        // Localizing is done async, so make sure the key isn't visible
                        element.removeAttr(value);

                    if (attr[0] === '@') {
                        //If the translation key starts with @ then remove it
                        attr = attr.substring(1);
                    }

                    var t = localizationService.tokenize(attr, scope);

                    localizationService.localize(t.key, t.tokens).then(function (val) {
                        element.attr(value, val);
                    });
                }
            });
        }
    };
});

----
upload/umbsinglefileupload.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbSingleFileUpload
* @function
* @restrict A
* @scope
* @description
*  A single file upload field that will reset itself based on the object passed in for the rebuild parameter. This
*  is required because the only way to reset an upload control is to replace it's html.
**/
function umbSingleFileUpload($compile) {

    // cause we have the same template twice I choose to extract it to its own variable:
    var innerTemplate = "<input type='file' umb-file-upload accept='{{acceptFileExt}}' ng-click='handleClick($event)' />";

    return {
        restrict: "E",
        scope: {
            rebuild: "=",
            acceptFileExt: "<?"
        },
        replace: true,
        template: "<div class='umb-single-file-upload'>"+innerTemplate+"</div>",
        link: function (scope, el, attrs) {

            scope.readonly = false;

            scope.$watch("rebuild", function (newVal, oldVal) {
                if (newVal && newVal !== oldVal) {
                    //recompile it!
                    el.html(innerTemplate);
                    $compile(el.contents())(scope);
                }
            });

            scope.handleClick = function ($event) {
                if (scope.readonly) {
                    $event.preventDefault();
                    $event.stopPropagation();
                }
            };

            attrs.$observe('readonly', (value) => {
                scope.readonly = value !== undefined;
            });

        }
    };
}

angular.module('umbraco.directives').directive("umbSingleFileUpload", umbSingleFileUpload);

----
upload/umbfiledropzone.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbFileDropzone
* @restrict E
* @function
* @description Show a dropzone that allows the user to drag files and have them be uploaded to the media library
**/
angular.module("umbraco.directives")
  .directive('umbFileDropzone',
    function ($timeout, Upload, localizationService, umbRequestHelper, overlayService, mediaHelper, mediaTypeHelper) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'views/components/upload/umb-file-dropzone.html',
        scope: {
          parentId: '@',
          contentTypeAlias: '@',
          propertyAlias: '@',
          accept: '@',
          maxFileSize: '@',

          compact: '@',
          hideDropzone: '@',
          acceptedMediatypes: '<',

          filesQueued: '<',
          filesUploaded: '<'
        },
        link: function (scope, element, attrs) {
          scope.queue = [];
          scope.totalQueued = 0;
          scope.processing = [];
          scope.processed = [];
          scope.totalMessages = 0;
          // TODO - Make configurable in appsettings
          scope.batchSize = 10;
          scope.processingCount = 0;

          function _filterFile(file) {
            var ignoreFileNames = ['Thumbs.db'];
            var ignoreFileTypes = ['directory'];

            // ignore files with names from the list
            // ignore files with types from the list
            // ignore files which starts with "."
            if (ignoreFileNames.indexOf(file.name) === -1 &&
              ignoreFileTypes.indexOf(file.type) === -1 &&
              file.name.indexOf(".") !== 0) {
              return true;
            } else {
              return false;
            }
          }

          /**
           * Initial entrypoint to handle the queued files. It will determine if the files are acceptable
           * and determine if the user needs to pick a media type
           * @param files
           * @param event
           * @returns void
           * @private
           */
          function _filesQueued(files, event) {
            //Push into the queue
            Utilities.forEach(files, file => {
              if (_filterFile(file) === true) {
                file.messages = [];
                scope.queue.push(file);
              }
            });

            // Add all of the processing and processed files to account for uploading
            // files in stages (dragging files X at a time into the dropzone).
            scope.totalQueued = scope.queue.length + scope.processingCount + scope.processed.length;

            // Upload not allowed
            if (!scope.acceptedMediatypes || !scope.acceptedMediatypes.length) {
              files.map(file => {
                file.messages.push({ message: "File type is not allowed here", type: "Error" });
              });
            }

            // If we have Accepted Media Types, we will ask to choose Media Type
            if (scope.acceptedMediatypes) {

              // If the media type dialog returns a positive answer, it is safe to assume that the
              // contentTypeAlias has been chosen and we can return early because the dialog will start processing
              // the queue automatically
              if (_requestChooseMediaTypeDialog()) {
                return;
              }
            }

            // Start the processing of the queue here because the media type dialog was not shown and therefore
            // did not do it earlier
            _processQueueItems();
          }

          /**
           * Run through the queue and start processing files
           * @returns void
           * @private
           */
          function _processQueueItems() {

            if (scope.processingCount === scope.batchSize) {
              return;
            }

            // if we have processed all files, either by successful
            // upload, or attending to all messages, we deem the
            // action complete, else continue processing files
            scope.totalMessages = scope.processed.filter(e => e.messages.length > 0).length;

            if (scope.totalQueued === scope.processed.length) {
              if (scope.totalMessages === 0) {
                if (scope.filesUploaded) {
                  //queue is empty, trigger the done action
                  scope.filesUploaded(scope.done);
                }

                //auto-clear the done queue after 3 secs
                var currentLength = scope.processed.length;
                $timeout(function () {
                  scope.processed.splice(0, currentLength);
                }, 3000);
              }
            } else if (scope.queue.length) {

              var file = scope.queue.shift();
              scope.processing.push(file);
              _upload(file);

              // If we still have items to process
              // do so right away for parallel uploads
              if (scope.queue.length > 0) {
                _processQueueItems();
              }
            }
          }

          /**
           * Upload a specific file and use the scope.contentTypeAlias for the type or fall back to letting
           * the backend auto select a type.
           * @param file
           * @returns void
           * @private
           */
          function _upload(file) {

            scope.propertyAlias = scope.propertyAlias ? scope.propertyAlias : "umbracoFile";
            scope.contentTypeAlias = scope.contentTypeAlias ? scope.contentTypeAlias : "umbracoAutoSelect";

            scope.processingCount++;

            Upload.upload({
              url: umbRequestHelper.getApiUrl("mediaApiBaseUrl", "PostAddFile"),
              fields: {
                'currentFolder': scope.parentId,
                'contentTypeAlias': scope.contentTypeAlias,
                'propertyAlias': scope.propertyAlias,
                'path': file.path
              },
              file: file
            })
              .progress(function (evt) {
                if (file.uploadStat !== "done" && file.uploadStat !== "error") {
                  // calculate progress in percentage
                  var progressPercentage = parseInt(100.0 * evt.loaded / evt.total, 10);
                  // set percentage property on file
                  file.uploadProgress = progressPercentage;
                }
              })
              .success(function (data, status, headers, config) {
                // Set server messages
                file.messages = data.notifications;
                file.done = true;
                scope.processed.push(file);
                scope.processingCount--;
                _processQueueItems();
              })
              .error(function (evt, status, headers, config) {
                //if the service returns a detailed error
                if (evt.InnerException) {
                  file.messages.push({ message: evt.InnerException.ExceptionMessage, type: "Error" });
                  //Check if its the common "too large file" exception
                  if (evt.InnerException.StackTrace &&
                    evt.InnerException.StackTrace.indexOf("ValidateRequestEntityLength") > 0) {
                    file.messages.push({ message: "File too large to upload", type: "Error", header: "Error" });
                  }
                } else if (status === 413) {
                  file.messages.push({ message: "File too large to upload", type: "Error", header: "Error" });
                } else if (evt.Message) {
                  file.messages.push({ message: evt.Message, type: "Error", header: "Error" });
                } else if (evt && typeof evt === "string") {
                  file.messages.push({ message: evt, type: "Error", header: "Error" });
                } else if (status === 404) {
                  // If file not found, server will return a 404 and display this message
                  file.messages.push({ message: "File not found", type: "Error" });
                } else if (status !== 200) {
                  file.messages.push({ message: "An unknown error occurred", type: "Error", header: "Error" });
                }

                file.done = true;
                scope.processed.push(file);
                scope.processingCount--;
                _processQueueItems();
              });
          }

          /**
           * Opens the media type dialog and lets the user choose a media type. If the queue is empty it will not show.
           * @returns {boolean}
           * @private
           */
          function _requestChooseMediaTypeDialog() {

            if (scope.queue.length === 0) {
              // if queue has no items so there is nothing to choose a type for
              return false;
            }

            if (scope.acceptedMediatypes.length === 1) {
              // if only one accepted type, then we wont ask to choose.
              return false;
            }

            var uploadFileExtensions = scope.queue.map(file => mediaHelper.getFileExtension(file.name));

            var filteredMediaTypes = mediaTypeHelper.getTypeAcceptingFileExtensions(scope.acceptedMediatypes, uploadFileExtensions);

            var mediaTypesNotFile = filteredMediaTypes.filter(mediaType => mediaType.alias !== "File");

            if (mediaTypesNotFile.length <= 1) {
              // if only one  or less accepted types when we have filtered type 'file' out, then we wont ask to choose.
              return false;
            }

            localizationService.localizeMany(["defaultdialogs_selectMediaType", "mediaType_autoPickMediaType"]).then(function (translations) {

              filteredMediaTypes.push({
                alias: "umbracoAutoSelect",
                name: translations[1],
                icon: "icon-wand"
              });

              const dialog = {
                view: "itempicker",
                filter: filteredMediaTypes.length > 8,
                availableItems: filteredMediaTypes,
                submit: function (model) {
                  scope.contentTypeAlias = model.selectedItem.alias;
                  _processQueueItems();

                  overlayService.close();
                },
                close: function () {

                  scope.queue.map(function (file) {
                    file.messages.push({ message: "No files uploaded, no mediatype selected", type: "Error" });
                  });
                  scope.queue = [];

                  overlayService.close();
                }
              };

              dialog.title = translations[0];
              overlayService.open(dialog);
            });

            return true; // yes, we did open the choose-media dialog, therefore we return true.
          }

          scope.dismissMessages = function (file) {
            file.messages = [];
            _processQueueItems();
          }

          scope.dismissAllMessages = function () {
            Utilities.forEach(scope.processed, file => {
              file.messages = [];
            });
            _processQueueItems();
          }

          scope.handleFiles = function (files, event, invalidFiles) {
            const allFiles = [...files, ...invalidFiles];

            // add unique key for each files to use in ng-repeats
            Utilities.forEach(allFiles, file => {
              file.key = String.CreateGuid();
            });

            if (scope.filesQueued) {
              scope.filesQueued(allFiles, event);
            }
            _filesQueued(allFiles, event);
          };
        }
      };
    });

----
upload/umbfileupload.directive.js
/**
* @ngdoc directive
* @name umbraco.directives.directive:umbFileUpload
* @function
* @restrict A
* @scope
* @description
*  Listens for file input control changes and emits events when files are selected for use in other controllers.
**/
function umbFileUpload() {
    return {
        restrict: "A",
        scope: true,        //create a new scope
        link: function (scope, el, attrs) {
            el.on('change', function (event) {
                var files = event.target.files;
                //emit event upward
                scope.$emit("filesSelected", { files: files });
                //clear the element value - this allows us to pick the same file again and again
                el.val('');
            });

            el.on('dragover dragenter', function () {
                scope.$emit("isDragover", { value: true });
            })
            .on('dragleave dragend drop', function () {
                scope.$emit("isDragover", { value: false });
            });
        }
    };
}

angular.module('umbraco.directives').directive("umbFileUpload", umbFileUpload);

----
upload/umbpropertyfileupload.directive.js
﻿(function() {
    'use strict';

    /**
     * A component to manage file uploads for content properties
     * @param {any} $scope
     * @param {any} fileManager
     * @param {any} mediaHelper
     * @param {any} angularHelper
     */
    function umbPropertyFileUploadController($scope, $q, fileManager, mediaHelper, angularHelper, $attrs) {

        //NOTE: this component supports multiple files, though currently the uploader does not but perhaps sometime in the future
        // we'd want it to, so i'll leave the multiple file support in place

        var vm = this;

        vm.$onInit = onInit;
        vm.$onChanges = onChanges;
        vm.$postLink = postLink;
        vm.clear = clearFiles;

        vm.readonly = false;

        $attrs.$observe('readonly', (value) => {
            vm.readonly = value !== undefined;
        });

        /** Clears the file collections when content is saving (if we need to clear) or after saved */
        function clearFiles() {
            //clear the files collection (we don't want to upload any!)
            fileManager.setFiles({
                propertyAlias: vm.propertyAlias,
                culture: vm.culture,
                segment: vm.segment,
                files: []
            });
            //clear the current files
            vm.files = [];

            //notify the callback
            notifyFilesSelected(null);
            notifyFilesChanged(null);
        }

        function notifyFilesSelected(val, files) {

            if (!val) {
                val = null;
            }
            if (!files) {
                files = null;
            }

            //notify the callback
            vm.onFilesSelected({ value: val, files: files });

            //need to explicity setDirty here to track changes
            vm.fileUploadForm.$setDirty();
        }

        function notifyFilesChanged(files) {
            if (!files) {
                files = null;
            }

            //notify the callback
            vm.onFilesChanged({ files: files });
        }

        function notifyInit(val, files) {
            if (!val) {
                val = null;
            }
            if (!files) {
                files = null;
            }

            if (vm.onInit) {
                vm.onInit({ value: val, files: files });
            }
        }

        /** Called when the component initializes */
        function onInit() {
            $scope.$on("filesSelected", onFilesSelected);
            $scope.$on("isDragover", isDragover);

            initialize();
        }

        /** Called when the component has linked all elements, this is when the form controller is available */
        function postLink() {

        }

        function initialize() {

            //normalize culture to null if it's not there
            if (!vm.culture) {
                vm.culture = null;
            }

            //normalize segment to null if it's not there
            if (!vm.segment) {
                vm.segment = null;
            }

            // TODO: need to figure out what we can do for things like Nested Content

            var existingClientFiles = checkPendingClientFiles();
            //create the property to show the list of files currently saved
            if (existingClientFiles.length > 0) {
                updateModelFromSelectedFiles(existingClientFiles).then(function (newVal) {
                    //notify the callback
                    notifyInit(newVal, vm.files);
                });
            }
            else if (vm.value) {

                var files = vm.value.split(",");

                vm.files = _.map(files, function (file) {
                    var f = {
                        fileName: file,
                        fileSrc: file,
                        isImage: mediaHelper.detectIfImageByExtension(file),
                        extension: getExtension(file)
                    };

                    return f;
                });

                //notify the callback
                notifyInit();
            }
            else {
                vm.files = [];

                //notify the callback
                notifyInit();
            }
        }

        function checkPendingClientFiles() {

            //normalize culture to null if it's not there
            if (!vm.culture) {
                vm.culture = null;
            }

            //normalize segment to null if it's not there
            if (!vm.segment) {
                vm.segment = null;
            }

            //check the file manager to see if there's already local files pending for this editor
            var existingClientFiles = _.map(
                _.filter(fileManager.getFiles(),
                    function (f) {
                        return f.alias === vm.propertyAlias && f.culture === vm.culture && f.segment === vm.segment;
                    }),
                function (f) {
                    return f.file;
                });
            return existingClientFiles;
        }

        /**
         * Watch for model changes
         * @param {any} changes
         */
        function onChanges(changes) {

            if (changes.value && !changes.value.isFirstChange() && changes.value.currentValue !== changes.value.previousValue) {

                if (!changes.value.currentValue && changes.value.previousValue) {
                    //if the value has been cleared, clear the files (ignore if the previous value is also falsy)
                    vm.files = [];
                }
                else if (changes.value.currentValue && !changes.value.previousValue && vm.files.length === 0) {
                    //if a new value has been added after being cleared

                    var existingClientFiles = checkPendingClientFiles();
                    //create the property to show the list of files currently saved
                    if (existingClientFiles.length > 0) {
                        updateModelFromSelectedFiles(existingClientFiles).then(function () {
                            //raise this event which means the files have changed but this wasn't the instance that
                            //added the file
                            notifyFilesChanged(vm.files);
                        });
                    }
                }

            }
        }

        function getExtension(fileName) {
            var extension = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length);
            return extension.toLowerCase();
        }

        /**
         * Updates the vm.files model from the selected files and returns a promise containing the csv of all file names selected
         * @param {any} files
         */
        function updateModelFromSelectedFiles(files) {

            //we return a promise because the FileReader api is async
            var promises = [];

            //clear the current files
            vm.files = [];
            var newVal = "";

            var reader = new FileReader();

            //for each file load in the contents from the file reader and set it as an fileSrc
            //property of the vm.files array item
            var fileCount = files.length;
            for (var i = 0; i < fileCount; i++) {
                var index = i; //capture

                var isImage = mediaHelper.detectIfImageByExtension(files[i].name);
                var extension = getExtension(files[i].name);

                var f = {
                    isImage: isImage,
                    extension: extension,
                    fileName: files[i].name,
                    isClientSide: true,
                    fileData: files[i]
                };

                // Save the file object to the files collection
                vm.files.push(f);

                //special check for a comma in the name
                newVal += files[i].name.split(',').join('-') + ",";

                // TODO: I would love to remove this part. But I'm affright it would be breaking if removed. Its not used by File upload anymore as each preview handles the client-side data on their own.
                if (isImage || extension === "svg") {

                    var deferred = $q.defer();

                    reader.onload = function(e) {
                        vm.files[index].fileSrc = e.target.result;
                        deferred.resolve(newVal);
                    };
                    promises.push(deferred.promise);
                    reader.readAsDataURL(files[i]);
                }
                else {
                    promises.push($q.when(newVal));
                }
            }

            return $q.all(promises).then(function (p) {
                //return the last value in the list of promises which will be the final value
                return $q.when(p[p.length - 1]);
            });
        }

        /**
         * listen for when a file is selected
         * @param {any} event
         * @param {any} args
         */
        function onFilesSelected(event, args) {
            if (vm.readonly) return;

            if (args.files && args.files.length > 0) {

                //set the files collection
                fileManager.setFiles({
                    propertyAlias: vm.propertyAlias,
                    files: args.files,
                    culture: vm.culture,
                    segment: vm.segment
                });

                updateModelFromSelectedFiles(args.files).then(function(newVal) {
                    angularHelper.safeApply($scope,
                        function() {
                            //pass in the file names and the model files
                            notifyFilesSelected(newVal, vm.files);
                            notifyFilesChanged(vm.files);
                        });
                });
            }
            else {
                angularHelper.safeApply($scope);
            }
        }

        function isDragover(e, args) {
            if (vm.readonly) return;

            vm.dragover = args.value;
            angularHelper.safeApply($scope);
        }

    };

    var umbPropertyFileUploadComponent = {
        templateUrl: 'views/components/upload/umb-property-file-upload.html',
        bindings: {
            culture: "@?",
            segment: "@?",
            propertyAlias: "@",
            value: "<",
            hideSelection: "<",
            dragover: "<",
            /**
             * Called when a file is selected on this instance
             */
            onFilesSelected: "&",
            /**
             * Called when the file collection changes (i.e. a new file has been selected but maybe it wasn't this instance that caused the change)
             */
            onFilesChanged: "&",
            onInit: "&",
            required: "=",
            acceptFileExt: "<?"
        },
        transclude: true,
        controllerAs: 'vm',
        controller: umbPropertyFileUploadController
    };

    angular.module("umbraco.directives")
        .component('umbPropertyFileUpload', umbPropertyFileUploadComponent);

})();

----
grid/grid.rte.directive.js
angular.module("umbraco.directives")
    .directive('gridRte', function (tinyMceService, angularHelper, assetsService, $q, $timeout, eventsService, tinyMceAssets) {
        return {
            scope: {
                uniqueId: '=',
                value: '=',
                configuration: "=", //this is the RTE configuration
                datatypeKey: '@',
                ignoreUserStartNodes: '@'
            },
            templateUrl: 'views/components/grid/grid-rte.html',
            replace: true,
            link: function (scope, element, attrs) {

                // TODO: A lot of the code below should be shared between the grid rte and the normal rte

                scope.isLoading = true;

                var promises = [];
                
                //To id the html textarea we need to use the datetime ticks because we can have multiple rte's per a single property alias
                // because now we have to support having 2x (maybe more at some stage) content editors being displayed at once. This is because
                // we have this mini content editor panel that can be launched with MNTP.
                scope.textAreaHtmlId = scope.uniqueId + "_" + String.CreateGuid();

                var editorConfig = scope.configuration ? scope.configuration : null;
                if (!editorConfig || Utilities.isString(editorConfig)) {
                    editorConfig = tinyMceService.defaultPrevalues();
                    //for the grid by default, we don't want to include the macro toolbar
                    editorConfig.toolbar = _.without(editorConfig, "umbmacro");
                }

                //ensure the grid's global config is being passed up to the RTE, these 2 properties need to be in this format
                //since below we are just passing up `scope` as the actual model and for 2 way binding to work with `value` that
                //is the way it needs to be unless we start adding watchers. We'll just go with this for now but it's super ugly.
                scope.config = {
                    ignoreUserStartNodes: scope.ignoreUserStartNodes === "true"
                }
                scope.dataTypeKey = scope.datatypeKey; //Yes - this casing is rediculous, but it's because the var starts with `data` so it can't be `data-type-id` :/

                //stores a reference to the editor
                var tinyMceEditor = null;

                //queue file loading
                tinyMceAssets.forEach(function (tinyJsAsset) {
                    promises.push(assetsService.loadJs(tinyJsAsset, scope));
                });
                promises.push(tinyMceService.getTinyMceEditorConfig({
                    htmlId: scope.textAreaHtmlId,
                    stylesheets: editorConfig.stylesheets,
                    toolbar: editorConfig.toolbar,
                    mode: editorConfig.mode
                }));

                $q.all(promises).then(function (result) {

                    var standardConfig = result[promises.length - 1];

                    //create a baseline Config to extend upon
                    var baseLineConfigObj = {
                        maxImageSize: editorConfig.maxImageSize,
                        toolbar_sticky: true
                    };

                    Utilities.extend(baseLineConfigObj, standardConfig);

                    baseLineConfigObj.setup = function (editor) {

                        //set the reference
                        tinyMceEditor = editor;

                        //initialize the standard editor functionality for Umbraco
                        tinyMceService.initializeEditor({
                            editor: editor,
                            toolbar: editorConfig.toolbar,
                            model: scope,
                            // Form is found in the scope of the grid controller above us, not in our isolated scope
                            // https://github.com/umbraco/Umbraco-CMS/issues/7461
                            currentForm: angularHelper.getCurrentForm(scope.$parent)
                        });

                        //custom initialization for this editor within the grid
                        editor.on('init', function (e) {

                            // Used this init event - as opposed to property init_instance_callback
                            // to turn off the loader
                            scope.isLoading = false;

                            //force overflow to hidden to prevent no needed scroll
                            editor.getBody().style.overflow = "hidden";

                            $timeout(function () {
                                if (scope.value === null) {
                                    editor.focus();
                                }
                            }, 400);

                        });
                    };

                    /** Loads in the editor */
                    function loadTinyMce() {

                        //we need to add a timeout here, to force a redraw so TinyMCE can find
                        //the elements needed
                        $timeout(function () {
                            tinymce.init(baseLineConfigObj);
                        }, 150, false);
                    }

                    loadTinyMce();

                    // TODO: This should probably be in place for all RTE, not just for the grid, which means
                    // this code can live in tinyMceService.initializeEditor
                    var tabShownListener = eventsService.on("app.tabChange", function (e, args) {

                        var tabId = args.id;
                        var myTabId = element.closest(".umb-tab-pane").attr("rel");

                        if (String(tabId) === myTabId) {
                            //the tab has been shown, trigger the mceAutoResize (as it could have timed out before the tab was shown)
                            if (tinyMceEditor !== undefined && tinyMceEditor != null) {
                                tinyMceEditor.execCommand('mceAutoResize', false, null, null);
                            }
                        }

                    });
                    
                    //when the element is disposed we need to unsubscribe!
                    // NOTE: this is very important otherwise if this is part of a modal, the listener still exists because the dom
                    // element might still be there even after the modal has been hidden.
                    scope.$on('$destroy', function () {
                        eventsService.unsubscribe(tabShownListener);
                        //ensure we unbind this in case the blur doesn't fire above
                        if (tinyMceEditor !== undefined && tinyMceEditor != null) {
                            tinyMceEditor.destroy()
                        }
                    });

                });

            }
        };
    });

----
media/umbmedianodeinfo.directive.js
(function () {
    'use strict';

    function MediaNodeInfoDirective($timeout, $location, $q, eventsService, userService, dateHelper, editorService, mediaHelper, mediaResource) {

        function link(scope, element, attrs, ctrl) {

            var evts = [];

            scope.allowChangeMediaType = false;

            function onInit() {

                userService.getCurrentUser().then(user => {
                    // only allow change of media type if user has access to the settings sections
                    Utilities.forEach(user.sections, section => {
                        if (section.alias === "settings") {
                            scope.allowChangeMediaType = true;
                        }
                    });
                });

                // get media type details
                scope.mediaType = scope.node.contentType;

                // set the media link initially
                setMediaLink();

                // make sure dates are formatted to the user's locale
                formatDatesToLocal();

                // set media file extension initially
                setMediaExtension();
            }

            function formatDatesToLocal() {
                // get current backoffice user and format dates
                userService.getCurrentUser().then(currentUser => {
                    scope.node.createDateFormatted = dateHelper.getLocalDate(scope.node.createDate, currentUser.locale, 'LLL');
                    scope.node.updateDateFormatted = dateHelper.getLocalDate(scope.node.updateDate, currentUser.locale, 'LLL');
                });
            }

            function setMediaLink(){
                scope.nodeUrl = scope.node.mediaLink;
                // grab the file name from the URL and use it as the display name in the file link
                var match = /.*\/(.*)/.exec(scope.nodeUrl);
                if (match) {
                    scope.nodeFileName = match[1];
                } else {
                    scope.nodeFileName = scope.nodeUrl;
                }
            }

            function setMediaExtension() {
                scope.node.extension = mediaHelper.getFileExtension(scope.nodeUrl);
            }

            scope.openMediaType = mediaType => {
                var editor = {
                    id: mediaType.id,
                    submit: model => {
                        editorService.close();
                    },
                    close: () => {
                        editorService.close();
                    }
                };
                editorService.mediaTypeEditor(editor);
            };

            scope.openSVG = () => {
                var popup = window.open('', '_blank');
                var html = '<!DOCTYPE html><body><img src="' + scope.nodeUrl + '"/>' +
                    '<script>history.pushState(null, null,"' + $location.$$absUrl + '");</script></body>';
                
                popup.document.open();
                popup.document.write(html);
                popup.document.close();
            }

            // watch for content updates - reload content when node is saved, published etc.
            scope.$watch('node.updateDate', function(newValue, oldValue){
                if(!newValue) { return; }
                if(newValue === oldValue) { return; }

                // Update the media link
                setMediaLink();

                // Update the create and update dates
                formatDatesToLocal();

                //Update the media file format
                setMediaExtension();
            });

            //ensure to unregister from all events!
            scope.$on('$destroy', function () {
                for (var e in evts) {
                    eventsService.unsubscribe(evts[e]);
                }
            });

            onInit();
        }

        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'views/components/media/umb-media-node-info.html',
            scope: {
                node: "="
            },
            link: link
        };

        return directive;
    }

    angular.module('umbraco.directives').directive('umbMediaNodeInfo', MediaNodeInfoDirective);

})();

--END--